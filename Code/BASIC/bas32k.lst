0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    8045H             ; BASIC Work space
0041   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   0200                     .ORG    00200H
0130   0200             
0131   0200 C3 06 02    COLD:   JP      STARTB          ; Jump for cold start
0132   0203 C3 A4 02    WARM:   JP      WARMST          ; Jump for warm start
0133   0206             STARTB:
0134   0206 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   020A C3 11 02            JP      CSTART          ; Jump to initialise
0136   020D             
0137   020D B7 0A               .WORD   DEINT           ; Get integer -32768 to 32767
0138   020F 2D 12               .WORD   ABPASS          ; Return integer in AB
0139   0211             
0140   0211             
0141   0211 21 45 80    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   0214 F9                  LD      SP,HL           ; Set up a temporary stack
0143   0215 C3 4C 1E            JP      INITST          ; Go to initialise
0144   0218             
0145   0218 11 DE 04    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   021B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   021D 21 45 80            LD      HL,WRKSPC       ; Into workspace RAM
0148   0220 1A          COPY:   LD      A,(DE)          ; Get source
0149   0221 77                  LD      (HL),A          ; To destination
0150   0222 23                  INC     HL              ; Next destination
0151   0223 13                  INC     DE              ; Next source
0152   0224 05                  DEC     B               ; Count bytes
0153   0225 C2 20 02            JP      NZ,COPY         ; More to move
0154   0228 F9                  LD      SP,HL           ; Temporary stack
0155   0229 CD DF 06            CALL    CLREG           ; Clear registers and stack
0156   022C CD AD 0C            CALL    PRNTCRLF        ; Output CRLF
0157   022F 32 EF 80            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   0232 32 3E 81            LD      (PROGST),A      ; Initialise program area
0159   0235 21 F3 02    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   0238 CD 4B 13            CALL    PRS             ; Output "Memory size"
0161   023B CD FC 06            CALL    PROMPT          ; Get input with '?'
0162   023E CD 05 0A            CALL    GETCHR          ; Get next character
0163   0241 B7                  OR      A               ; Set flags
0164   0242 C2 5A 02            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   0245 21 A2 81            LD      HL,STLOOK       ; Point to start of RAM
0166   0248 23          MLOOP:  INC     HL              ; Next byte
0167   0249 7C                  LD      A,H             ; Above address FFFF ?
0168   024A B5                  OR      L
0169   024B CA 6C 02            JP      Z,SETTOP        ; Yes - 64K RAM
0170   024E 7E                  LD      A,(HL)          ; Get contents
0171   024F 47                  LD      B,A             ; Save it
0172   0250 2F                  CPL                     ; Flip all bits
0173   0251 77                  LD      (HL),A          ; Put it back
0174   0252 BE                  CP      (HL)            ; RAM there if same
0175   0253 70                  LD      (HL),B          ; Restore old contents
0176   0254 CA 48 02            JP      Z,MLOOP         ; If RAM - test next byte
0177   0257 C3 6C 02            JP      SETTOP          ; Top of RAM found
0178   025A             
0179   025A CD D1 0A    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   025D B7                  OR      A               ; Set flags on last byte
0181   025E C2 AD 05            JP      NZ,SNERR        ; ?SN Error if bad character
0182   0261 EB                  EX      DE,HL           ; Address into HL
0183   0262 2B                  DEC     HL              ; Back one byte
0184   0263 3E D9               LD      A,11011001B     ; Test byte
0185   0265 46                  LD      B,(HL)          ; Get old contents
0186   0266 77                  LD      (HL),A          ; Load test byte
0187   0267 BE                  CP      (HL)            ; RAM there if same
0188   0268 70                  LD      (HL),B          ; Restore old contents
0189   0269 C2 35 02            JP      NZ,MSIZE        ; Ask again if no RAM
0190   026C             
0191   026C 2B          SETTOP: DEC     HL              ; Back one byte
0192   026D 11 A1 81            LD      DE,STLOOK-1     ; See if enough RAM
0193   0270 CD 75 08            CALL    CPDEHL          ; Compare DE with HL
0194   0273 DA 35 02            JP      C,MSIZE         ; Ask again if not enough RAM
0195   0276 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   0279 22 F4 80            LD      (LSTRAM),HL     ; Save last available RAM
0197   027C 19                  ADD     HL,DE           ; Allocate string space
0198   027D 22 9F 80            LD      (STRSPC),HL     ; Save string space
0199   0280 CD BA 06            CALL    CLRPTR          ; Clear program area
0200   0283 2A 9F 80            LD      HL,(STRSPC)     ; Get end of memory
0201   0286 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   0289 19                  ADD     HL,DE           ; Adjust HL
0203   028A 11 3E 81            LD      DE,PROGST       ; Start of program text
0204   028D 7D                  LD      A,L             ; Get LSB
0205   028E 93                  SUB     E               ; Adjust it
0206   028F 6F                  LD      L,A             ; Re-save
0207   0290 7C                  LD      A,H             ; Get MSB
0208   0291 9A                  SBC     A,D             ; Adjust it
0209   0292 67                  LD      H,A             ; Re-save
0210   0293 E5                  PUSH    HL              ; Save bytes free
0211   0294 21 BC 02            LD      HL,SIGNON       ; Sign-on message
0212   0297 CD 4B 13            CALL    PRS             ; Output string
0213   029A E1                  POP     HL              ; Get bytes free back
0214   029B CD EE 19            CALL    PRNTHL          ; Output amount of free memory
0215   029E 21 AD 02            LD      HL,BFREE        ; " Bytes free" message
0216   02A1 CD 4B 13            CALL    PRS             ; Output string
0217   02A4             
0218   02A4 31 AB 80    WARMST: LD      SP,STACK        ; Temporary stack
0219   02A7 CD DF 06    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   02AA C3 F8 05            JP      PRNTOK          ; Go to get command line
0221   02AD             
0222   02AD 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   02B1 65 73 20 66 
0222   02B5 72 65 65 0D 
0222   02B9 0A 00 00 
0223   02BC             
0224   02BC 5A 38 30 20 SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   02C0 42 41 53 49 
0224   02C4 43 20 56 65 
0224   02C8 72 20 34 2E 
0224   02CC 37 62 0D 0A 
0225   02D0 43 6F 70 79         .BYTE   "Copyright ",40,"C",41
0225   02D4 72 69 67 68 
0225   02D8 74 20 28 43 
0225   02DC 29 
0226   02DD 20 31 39 37         .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   02E1 38 20 62 79 
0226   02E5 20 4D 69 63 
0226   02E9 72 6F 73 6F 
0226   02ED 66 74 0D 0A 
0226   02F1 00 00 
0227   02F3             
0228   02F3 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0228   02F7 72 79 20 74 
0228   02FB 6F 70 00 
0229   02FE             
0230   02FE             ; FUNCTION ADDRESS TABLE
0231   02FE             
0232   02FE 63 18       FNCTAB: .WORD   SGN
0233   0300 27 19               .WORD   INT
0234   0302 79 18               .WORD   ABS
0235   0304 48 80               .WORD   USR
0236   0306 0B 12               .WORD   FRE
0237   0308 90 15               .WORD   INP
0238   030A 39 12               .WORD   POS
0239   030C ED 1A               .WORD   SQR
0240   030E CC 1B               .WORD   RND
0241   0310 08 17               .WORD   LOG
0242   0312 3B 1B               .WORD   EXP
0243   0314 41 1C               .WORD   COS
0244   0316 47 1C               .WORD   SIN
0245   0318 A8 1C               .WORD   TAN
0246   031A BD 1C               .WORD   ATN
0247   031C E4 15               .WORD   PEEK
0248   031E 28 1D               .WORD   DEEK
0249   0320 96 80               .WORD   POINT
0250   0322 BD 14               .WORD   LEN
0251   0324 D5 12               .WORD   STR
0252   0326 57 15               .WORD   VAL
0253   0328 CC 14               .WORD   ASC
0254   032A DD 14               .WORD   CHR
0255   032C 4A 1D               .WORD   HEX
0256   032E DD 1D               .WORD   BIN
0257   0330 ED 14               .WORD   LEFT
0258   0332 1D 15               .WORD   RIGHT
0259   0334 27 15               .WORD   MID
0260   0336             
0261   0336             ; RESERVED WORD LIST
0262   0336             
0263   0336 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   0339 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   033C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   0340 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   0344 C9 4E 50 55         .BYTE   'I'+80H,"NPUT"
0267   0348 54 
0268   0349 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   034C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   0350 CC 45 54            .BYTE   'L'+80H,"ET"
0271   0353 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   0357 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   035A C9 46               .BYTE   'I'+80H,"F"
0274   035C D2 45 53 54         .BYTE   'R'+80H,"ESTORE"
0274   0360 4F 52 45 
0275   0363 C7 4F 53 55         .BYTE   'G'+80H,"OSUB"
0275   0367 42 
0276   0368 D2 45 54 55         .BYTE   'R'+80H,"ETURN"
0276   036C 52 4E 
0277   036E D2 45 4D            .BYTE   'R'+80H,"EM"
0278   0371 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   0375 CF 55 54            .BYTE   'O'+80H,"UT"
0280   0378 CF 4E               .BYTE   'O'+80H,"N"
0281   037A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   037E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   0382 C4 45 46            .BYTE   'D'+80H,"EF"
0284   0385 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   0389 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   038D D3 43 52 45         .BYTE   'S'+80H,"CREEN"
0286   0391 45 4E 
0287   0393 CC 49 4E 45         .BYTE   'L'+80H,"INES"
0287   0397 53 
0288   0398 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   039B D7 49 44 54         .BYTE   'W'+80H,"IDTH"
0289   039F 48 
0290   03A0 CD 4F 4E 49         .BYTE   'M'+80H,"ONITOR"
0290   03A4 54 4F 52 
0291   03A7 D3 45 54            .BYTE   'S'+80H,"ET"
0292   03AA D2 45 53 45         .BYTE   'R'+80H,"ESET"
0292   03AE 54 
0293   03AF D0 52 49 4E         .BYTE   'P'+80H,"RINT"
0293   03B3 54 
0294   03B4 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   03B8 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   03BC C3 4C 45 41         .BYTE   'C'+80H,"LEAR"
0296   03C0 52 
0297   03C1 C3 4C 4F 41         .BYTE   'C'+80H,"LOAD"
0297   03C5 44 
0298   03C6 C3 53 41 56         .BYTE   'C'+80H,"SAVE"
0298   03CA 45 
0299   03CB CE 45 57            .BYTE   'N'+80H,"EW"
0300   03CE             
0301   03CE D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   03D2 D4 4F               .BYTE   'T'+80H,"O"
0303   03D4 C6 4E               .BYTE   'F'+80H,"N"
0304   03D6 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   03DA D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   03DE CE 4F 54            .BYTE   'N'+80H,"OT"
0307   03E1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   03E5             
0309   03E5 AB                  .BYTE   '+'+80H
0310   03E6 AD                  .BYTE   '-'+80H
0311   03E7 AA                  .BYTE   '*'+80H
0312   03E8 AF                  .BYTE   '/'+80H
0313   03E9 DE                  .BYTE   '^'+80H
0314   03EA C1 4E 44            .BYTE   'A'+80H,"ND"
0315   03ED CF 52               .BYTE   'O'+80H,"R"
0316   03EF BE                  .BYTE   '>'+80H
0317   03F0 BD                  .BYTE   '='+80H
0318   03F1 BC                  .BYTE   '<'+80H
0319   03F2             
0320   03F2 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   03F5 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   03F8 C1 42 53            .BYTE   'A'+80H,"BS"
0323   03FB D5 53 52            .BYTE   'U'+80H,"SR"
0324   03FE C6 52 45            .BYTE   'F'+80H,"RE"
0325   0401 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   0404 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   0407 D3 51 52            .BYTE   'S'+80H,"QR"
0328   040A D2 4E 44            .BYTE   'R'+80H,"ND"
0329   040D CC 4F 47            .BYTE   'L'+80H,"OG"
0330   0410 C5 58 50            .BYTE   'E'+80H,"XP"
0331   0413 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   0416 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   0419 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   041C C1 54 4E            .BYTE   'A'+80H,"TN"
0335   041F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   0423 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   0427 D0 4F 49 4E         .BYTE   'P'+80H,"OINT"
0337   042B 54 
0338   042C CC 45 4E            .BYTE   'L'+80H,"EN"
0339   042F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   0433 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   0436 C1 53 43            .BYTE   'A'+80H,"SC"
0342   0439 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   043D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   0441 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   0445 CC 45 46 54         .BYTE   'L'+80H,"EFT$"
0345   0449 24 
0346   044A D2 49 47 48         .BYTE   'R'+80H,"IGHT$"
0346   044E 54 24 
0347   0450 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   0454 80                  .BYTE   80H             ; End of list marker
0349   0455             
0350   0455             ; KEYWORD ADDRESS TABLE
0351   0455             
0352   0455 4F 0A       WORDTB: .WORD   PEND
0353   0457 4C 09               .WORD   FOR
0354   0459 27 0E               .WORD   NEXT
0355   045B 9C 0B               .WORD   DATA
0356   045D 2E 0D               .WORD   INPUT
0357   045F 63 10               .WORD   DIM
0358   0461 5D 0D               .WORD   READ
0359   0463 B3 0B               .WORD   LET
0360   0465 59 0B               .WORD   GOTO
0361   0467 3C 0B               .WORD   RUN
0362   0469 2B 0C               .WORD   IF
0363   046B 15 0A               .WORD   RESTOR
0364   046D 48 0B               .WORD   GOSUB
0365   046F 77 0B               .WORD   RETURN
0366   0471 9E 0B               .WORD   REM
0367   0473 4D 0A               .WORD   STOP
0368   0475 9C 15               .WORD   POUT
0369   0477 0D 0C               .WORD   ON
0370   0479 8E 0A               .WORD   NULL
0371   047B A2 15               .WORD   WAIT
0372   047D 41 12               .WORD   DEF
0373   047F EB 15               .WORD   POKE
0374   0481 33 1D               .WORD   DOKE
0375   0483 9E 0B               .WORD   REM
0376   0485 19 1D               .WORD   LINES
0377   0487 0C 1D               .WORD   CLS
0378   0489 11 1D               .WORD   WIDTH
0379   048B 49 1E               .WORD   MONITR
0380   048D 99 80               .WORD   PSET
0381   048F 9C 80               .WORD   RESET
0382   0491 4F 0C               .WORD   PRINT
0383   0493 7B 0A               .WORD   CONT
0384   0495 C1 08               .WORD   LIST
0385   0497 F6 0A               .WORD   CLEAR
0386   0499 9E 0B               .WORD   REM
0387   049B 9E 0B               .WORD   REM
0388   049D B9 06               .WORD   NEW
0389   049F             
0390   049F             ; RESERVED WORD TOKEN VALUES
0391   049F             
0392   049F             ZEND    .EQU    080H            ; END
0393   049F             ZFOR    .EQU    081H            ; FOR
0394   049F             ZDATA   .EQU    083H            ; DATA
0395   049F             ZGOTO   .EQU    088H            ; GOTO
0396   049F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   049F             ZREM    .EQU    08EH            ; REM
0398   049F             ZPRINT  .EQU    09EH            ; PRINT
0399   049F             ZNEW    .EQU    0A4H            ; NEW
0400   049F             
0401   049F             ZTAB    .EQU    0A5H            ; TAB
0402   049F             ZTO     .EQU    0A6H            ; TO
0403   049F             ZFN     .EQU    0A7H            ; FN
0404   049F             ZSPC    .EQU    0A8H            ; SPC
0405   049F             ZTHEN   .EQU    0A9H            ; THEN
0406   049F             ZNOT    .EQU    0AAH            ; NOT
0407   049F             ZSTEP   .EQU    0ABH            ; STEP
0408   049F             
0409   049F             ZPLUS   .EQU    0ACH            ; +
0410   049F             ZMINUS  .EQU    0ADH            ; -
0411   049F             ZTIMES  .EQU    0AEH            ; *
0412   049F             ZDIV    .EQU    0AFH            ; /
0413   049F             ZOR     .EQU    0B2H            ; OR
0414   049F             ZGTR    .EQU    0B3H            ; >
0415   049F             ZEQUAL  .EQU    0B4H            ; M
0416   049F             ZLTH    .EQU    0B5H            ; <
0417   049F             ZSGN    .EQU    0B6H            ; SGN
0418   049F             ZPOINT  .EQU    0C7H            ; POINT
0419   049F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   049F             
0421   049F             ; ARITHMETIC PRECEDENCE TABLE
0422   049F             
0423   049F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   04A0 D5 19               .WORD   PADD            ; FPREG = <last> + FPREG
0425   04A2             
0426   04A2 79                  .BYTE   79H             ; Precedence value
0427   04A3 09 16               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   04A5             
0429   04A5 7C                  .BYTE   7CH             ; Precedence value
0430   04A6 47 17               .WORD   MULT            ; PPREG = <last> * FPREG
0431   04A8             
0432   04A8 7C                  .BYTE   7CH             ; Precedence value
0433   04A9 A8 17               .WORD   DIV             ; FPREG = <last> / FPREG
0434   04AB             
0435   04AB 7F                  .BYTE   7FH             ; Precedence value
0436   04AC F6 1A               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   04AE             
0438   04AE 50                  .BYTE   50H             ; Precedence value
0439   04AF BC 0F               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   04B1             
0441   04B1 46                  .BYTE   46H             ; Precedence value
0442   04B2 BB 0F               .WORD   POR             ; FPREG = <last> OR FPREG
0443   04B4             
0444   04B4             ; BASIC ERROR CODE LIST
0445   04B4             
0446   04B4 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   04B6 53 4E               .BYTE   "SN"            ; Syntax error
0448   04B8 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   04BA 4F 44               .BYTE   "OD"            ; Out of DATA
0450   04BC 46 43               .BYTE   "FC"            ; Illegal function call
0451   04BE 4F 56               .BYTE   "OV"            ; Overflow error
0452   04C0 4F 4D               .BYTE   "OM"            ; Out of memory
0453   04C2 55 4C               .BYTE   "UL"            ; Undefined line
0454   04C4 42 53               .BYTE   "BS"            ; Bad subscript
0455   04C6 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   04C8 2F 30               .BYTE   "/0"            ; Division by zero
0457   04CA 49 44               .BYTE   "ID"            ; Illegal direct
0458   04CC 54 4D               .BYTE   "TM"            ; Type mis-match
0459   04CE 4F 53               .BYTE   "OS"            ; Out of string space
0460   04D0 4C 53               .BYTE   "LS"            ; String too long
0461   04D2 53 54               .BYTE   "ST"            ; String formula too complex
0462   04D4 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   04D6 55 46               .BYTE   "UF"            ; Undefined FN function
0464   04D8 4D 4F               .BYTE   "MO"            ; Missing operand
0465   04DA 48 58               .BYTE   "HX"            ; HEX error
0466   04DC 42 4E               .BYTE   "BN"            ; BIN error
0467   04DE             
0468   04DE             ; INITIALISATION TABLE -------------------------------------------------------
0469   04DE             
0470   04DE C3 A4 02    INITAB: JP      WARMST          ; Warm start jump
0471   04E1 C3 CC 0A            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   04E4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   04E6 C9                  RET
0474   04E7 D6 00               SUB     0               ; Division support routine
0475   04E9 6F                  LD      L,A
0476   04EA 7C                  LD      A,H
0477   04EB DE 00               SBC     A,0
0478   04ED 67                  LD      H,A
0479   04EE 78                  LD      A,B
0480   04EF DE 00               SBC     A,0
0481   04F1 47                  LD      B,A
0482   04F2 3E 00               LD      A,0
0483   04F4 C9                  RET
0484   04F5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   04F8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   04FC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   0500 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   0504 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   0508 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   050C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   0510 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   0514 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   0518 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   051C DB 00               IN      A,(0)           ; INP (x) skeleton
0495   051E C9                  RET
0496   051F 01                  .BYTE   1               ; POS (x) number (1)
0497   0520 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   0521 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   0522 00                  .BYTE   0               ; No nulls after input bytes
0500   0523 00                  .BYTE   0               ; Output enabled (^O off)
0501   0524 14 00               .WORD   20              ; Initial lines counter
0502   0526 14 00               .WORD   20              ; Initial lines number
0503   0528 00 00               .WORD   0               ; Array load/save check sum
0504   052A 00                  .BYTE   0               ; Break not by NMI
0505   052B 00                  .BYTE   0               ; Break flag
0506   052C C3 F2 07            JP      TTYLIN          ; Input reflection (set to TTY)
0507   052F C3 00 00            JP      $0000           ; POINT reflection unused
0508   0532 C3 00 00            JP      $0000           ; SET reflection
0509   0535 C3 00 00            JP      $0000          	; RESET reflection
0510   0538 A2 81               .WORD   STLOOK          ; Temp string space
0511   053A FE FF               .WORD   -2              ; Current line number (cold)
0512   053C 3F 81               .WORD   PROGST+1        ; Start of program text
0513   053E             INITBE:
0514   053E             
0515   053E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   053E             
0517   053E 20 45 72 72 ERRMSG: .BYTE   " Error",0
0517   0542 6F 72 00 
0518   0545 20 69 6E 20 INMSG:  .BYTE   " in ",0
0518   0549 00 
0519   054A             ZERBYT  .EQU    $-1             ; A zero byte
0520   054A 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
0520   054E 00 00 
0521   0550 42 72 65 61 BRKMSG: .BYTE   "Break",0
0521   0554 6B 00 
0522   0556             
0523   0556 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   0559 39                  ADD     HL,SP           ; same index as specified
0525   055A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   055B 23                  INC     HL              ; Point to index address
0527   055C FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   055E C0                  RET     NZ              ; No - exit
0529   055F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   0560 23                  INC     HL
0531   0561 46                  LD      B,(HL)
0532   0562 23                  INC     HL              ; Point to sign of STEP
0533   0563 E5                  PUSH    HL              ; Save pointer to sign
0534   0564 69                  LD      L,C             ; HL = address of "FOR" index
0535   0565 60                  LD      H,B
0536   0566 7A                  LD      A,D             ; See if an index was specified
0537   0567 B3                  OR      E               ; DE = 0 if no index specified
0538   0568 EB                  EX      DE,HL           ; Specified index into HL
0539   0569 CA 70 05            JP      Z,INDFND        ; Skip if no index given
0540   056C EB                  EX      DE,HL           ; Index back into DE
0541   056D CD 75 08            CALL    CPDEHL          ; Compare index with one given
0542   0570 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   0573 E1                  POP     HL              ; Restore pointer to sign
0544   0574 C8                  RET     Z               ; Return if block found
0545   0575 09                  ADD     HL,BC           ; Point to next block
0546   0576 C3 5A 05            JP      LOKFOR          ; Keep on looking
0547   0579             
0548   0579 CD 93 05    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   057C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   057D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   057E C1                  POP     BC              ; Get end of destination
0552   057F CD 75 08    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   0582 7E                  LD      A,(HL)          ; Get byte
0554   0583 02                  LD      (BC),A          ; Move it
0555   0584 C8                  RET     Z               ; Exit if all done
0556   0585 0B                  DEC     BC              ; Next byte to move to
0557   0586 2B                  DEC     HL              ; Next byte to move
0558   0587 C3 7F 05            JP      MOVLP           ; Loop until all bytes moved
0559   058A             
0560   058A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   058B 2A 1F 81            LD      HL,(ARREND)     ; Lowest free memory
0562   058E 06 00               LD      B,0             ; BC = Number of levels to test
0563   0590 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   0591 09                  ADD     HL,BC
0565   0592 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   0593 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   0594 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   0596 95                  SUB     L
0569   0597 6F                  LD      L,A
0570   0598 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   059A 9C                  SBC     A,H
0572   059B DA A2 05            JP      C,OMERR         ; Not enough - ?OM Error
0573   059E 67                  LD      H,A
0574   059F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   05A0 E1                  POP     HL              ; Restore code string address
0576   05A1 D8                  RET     C               ; Return if enough mmory
0577   05A2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   05A4 C3 C1 05            JP      ERROR
0579   05A7             
0580   05A7 2A 0E 81    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   05AA 22 A1 80            LD      (LINEAT),HL     ; Save as current line
0582   05AD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   05AF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   05B0 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   05B2 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   05B3 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   05B5 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   05B6 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   05B8 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   05B9 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   05BB 01                  .BYTE   01H             ; Skip "LD E,OV
0592   05BC 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   05BE 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   05BF 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   05C1             
0596   05C1 CD DF 06    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   05C4 32 8A 80            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   05C7 CD A0 0C            CALL    STTLIN          ; Start new line
0599   05CA 21 B4 04            LD      HL,ERRORS       ; Point to error codes
0600   05CD 57                  LD      D,A             ; D = 0 (A is 0)
0601   05CE 3E 3F               LD      A,'?'
0602   05D0 CD 86 08            CALL    OUTC            ; Output '?'
0603   05D3 19                  ADD     HL,DE           ; Offset to correct error code
0604   05D4 7E                  LD      A,(HL)          ; First character
0605   05D5 CD 86 08            CALL    OUTC            ; Output it
0606   05D8 CD 05 0A            CALL    GETCHR          ; Get next character
0607   05DB CD 86 08            CALL    OUTC            ; Output it
0608   05DE 21 3E 05            LD      HL,ERRMSG       ; "Error" message
0609   05E1 CD 4B 13    ERRIN:  CALL    PRS             ; Output message
0610   05E4 2A A1 80            LD      HL,(LINEAT)     ; Get line of error
0611   05E7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   05EA CD 75 08            CALL    CPDEHL          ; See if cold start error
0613   05ED CA 11 02            JP      Z,CSTART        ; Cold start error - Restart
0614   05F0 7C                  LD      A,H             ; Was it a direct error?
0615   05F1 A5                  AND     L               ; Line = -1 if direct error
0616   05F2 3C                  INC     A
0617   05F3 C4 E6 19            CALL    NZ,LINEIN       ; No - output line of error
0618   05F6 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   05F7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   05F8             
0621   05F8 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   05F9 32 8A 80            LD      (CTLOFG),A      ; Enable output
0623   05FC CD A0 0C            CALL    STTLIN          ; Start new line
0624   05FF 21 4A 05            LD      HL,OKMSG        ; "Ok" message
0625   0602 CD 4B 13            CALL    PRS             ; Output "Ok"
0626   0605 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   0608 22 A1 80            LD      (LINEAT),HL     ; Save as current line
0628   060B CD F2 07            CALL    GETLIN          ; Get an input line
0629   060E DA 05 06            JP      C,GETCMD        ; Get line again if break
0630   0611 CD 05 0A            CALL    GETCHR          ; Get first character
0631   0614 3C                  INC     A               ; Test if end of line
0632   0615 3D                  DEC     A               ; Without affecting Carry
0633   0616 CA 05 06            JP      Z,GETCMD        ; Nothing entered - Get another
0634   0619 F5                  PUSH    AF              ; Save Carry status
0635   061A CD D1 0A            CALL    ATOH            ; Get line number into DE
0636   061D D5                  PUSH    DE              ; Save line number
0637   061E CD 09 07            CALL    CRUNCH          ; Tokenise rest of line
0638   0621 47                  LD      B,A             ; Length of tokenised line
0639   0622 D1                  POP     DE              ; Restore line number
0640   0623 F1                  POP     AF              ; Restore Carry
0641   0624 D2 E5 09            JP      NC,EXCUTE       ; No line number - Direct mode
0642   0627 D5                  PUSH    DE              ; Save line number
0643   0628 C5                  PUSH    BC              ; Save length of tokenised line
0644   0629 AF                  XOR     A
0645   062A 32 11 81            LD      (LSTBIN),A      ; Clear last byte input
0646   062D CD 05 0A            CALL    GETCHR          ; Get next character
0647   0630 B7                  OR      A               ; Set flags
0648   0631 F5                  PUSH    AF              ; And save them
0649   0632 CD 99 06            CALL    SRCHLN          ; Search for line number in DE
0650   0635 DA 3E 06            JP      C,LINFND        ; Jump if line found
0651   0638 F1                  POP     AF              ; Get status
0652   0639 F5                  PUSH    AF              ; And re-save
0653   063A CA 72 0B            JP      Z,ULERR         ; Nothing after number - Error
0654   063D B7                  OR      A               ; Clear Carry
0655   063E C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   063F D2 55 06            JP      NC,INEWLN       ; Line not found - Insert new
0657   0642 EB                  EX      DE,HL           ; Next line address in DE
0658   0643 2A 1B 81            LD      HL,(PROGND)     ; End of program
0659   0646 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   0647 02                  LD      (BC),A
0661   0648 03                  INC     BC              ; Next destination
0662   0649 13                  INC     DE              ; Next source
0663   064A CD 75 08            CALL    CPDEHL          ; All done?
0664   064D C2 46 06            JP      NZ,SFTPRG       ; More to do
0665   0650 60                  LD      H,B             ; HL - New end of program
0666   0651 69                  LD      L,C
0667   0652 22 1B 81            LD      (PROGND),HL     ; Update end of program
0668   0655             
0669   0655 D1          INEWLN: POP     DE              ; Get address of line,
0670   0656 F1                  POP     AF              ; Get status
0671   0657 CA 7C 06            JP      Z,SETPTR        ; No text - Set up pointers
0672   065A 2A 1B 81            LD      HL,(PROGND)     ; Get end of program
0673   065D E3                  EX      (SP),HL         ; Get length of input line
0674   065E C1                  POP     BC              ; End of program to BC
0675   065F 09                  ADD     HL,BC           ; Find new end
0676   0660 E5                  PUSH    HL              ; Save new end
0677   0661 CD 79 05            CALL    MOVUP           ; Make space for line
0678   0664 E1                  POP     HL              ; Restore new end
0679   0665 22 1B 81            LD      (PROGND),HL     ; Update end of program pointer
0680   0668 EB                  EX      DE,HL           ; Get line to move up in HL
0681   0669 74                  LD      (HL),H          ; Save MSB
0682   066A D1                  POP     DE              ; Get new line number
0683   066B 23                  INC     HL              ; Skip pointer
0684   066C 23                  INC     HL
0685   066D 73                  LD      (HL),E          ; Save LSB of line number
0686   066E 23                  INC     HL
0687   066F 72                  LD      (HL),D          ; Save MSB of line number
0688   0670 23                  INC     HL              ; To first byte in line
0689   0671 11 A6 80            LD      DE,BUFFER       ; Copy buffer to program
0690   0674 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   0675 77                  LD      (HL),A          ; Save destinations
0692   0676 23                  INC     HL              ; Next source
0693   0677 13                  INC     DE              ; Next destination
0694   0678 B7                  OR      A               ; Done?
0695   0679 C2 74 06            JP      NZ,MOVBUF       ; No - Repeat
0696   067C CD C5 06    SETPTR: CALL    RUNFST          ; Set line pointers
0697   067F 23                  INC     HL              ; To LSB of pointer
0698   0680 EB                  EX      DE,HL           ; Address to DE
0699   0681 62          PTRLP:  LD      H,D             ; Address to HL
0700   0682 6B                  LD      L,E
0701   0683 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   0684 23                  INC     HL              ; To MSB of pointer
0703   0685 B6                  OR      (HL)            ; Compare with MSB pointer
0704   0686 CA 05 06            JP      Z,GETCMD        ; Get command line if end
0705   0689 23                  INC     HL              ; To LSB of line number
0706   068A 23                  INC     HL              ; Skip line number
0707   068B 23                  INC     HL              ; Point to first byte in line
0708   068C AF                  XOR     A               ; Looking for 00 byte
0709   068D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   068E 23                  INC     HL              ; Move to next byte
0711   068F C2 8D 06            JP      NZ,FNDEND       ; No - Keep looking
0712   0692 EB                  EX      DE,HL           ; Next line address to HL
0713   0693 73                  LD      (HL),E          ; Save LSB of pointer
0714   0694 23                  INC     HL
0715   0695 72                  LD      (HL),D          ; Save MSB of pointer
0716   0696 C3 81 06            JP      PTRLP           ; Do next line
0717   0699             
0718   0699 2A A3 80    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   069C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   069D 4D                  LD      C,L
0721   069E 7E                  LD      A,(HL)          ; Get address of next line
0722   069F 23                  INC     HL
0723   06A0 B6                  OR      (HL)            ; End of program found?
0724   06A1 2B                  DEC     HL
0725   06A2 C8                  RET     Z               ; Yes - Line not found
0726   06A3 23                  INC     HL
0727   06A4 23                  INC     HL
0728   06A5 7E                  LD      A,(HL)          ; Get LSB of line number
0729   06A6 23                  INC     HL
0730   06A7 66                  LD      H,(HL)          ; Get MSB of line number
0731   06A8 6F                  LD      L,A
0732   06A9 CD 75 08            CALL    CPDEHL          ; Compare with line in DE
0733   06AC 60                  LD      H,B             ; HL = Start of this line
0734   06AD 69                  LD      L,C
0735   06AE 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   06AF 23                  INC     HL
0737   06B0 66                  LD      H,(HL)          ; Get MSB of next line address
0738   06B1 6F                  LD      L,A             ; Next line to HL
0739   06B2 3F                  CCF
0740   06B3 C8                  RET     Z               ; Lines found - Exit
0741   06B4 3F                  CCF
0742   06B5 D0                  RET     NC              ; Line not found,at line after
0743   06B6 C3 9C 06            JP      SRCHLP          ; Keep looking
0744   06B9             
0745   06B9 C0          NEW:    RET     NZ              ; Return if any more on line
0746   06BA 2A A3 80    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   06BD AF                  XOR     A               ; Set program area to empty
0748   06BE 77                  LD      (HL),A          ; Save LSB = 00
0749   06BF 23                  INC     HL
0750   06C0 77                  LD      (HL),A          ; Save MSB = 00
0751   06C1 23                  INC     HL
0752   06C2 22 1B 81            LD      (PROGND),HL     ; Set program end
0753   06C5             
0754   06C5 2A A3 80    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   06C8 2B                  DEC     HL
0756   06C9             
0757   06C9 22 13 81    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   06CC 2A F4 80            LD      HL,(LSTRAM)     ; Get end of RAM
0759   06CF 22 08 81            LD      (STRBOT),HL     ; Clear string space
0760   06D2 AF                  XOR     A
0761   06D3 CD 15 0A            CALL    RESTOR          ; Reset DATA pointers
0762   06D6 2A 1B 81            LD      HL,(PROGND)     ; Get end of program
0763   06D9 22 1D 81            LD      (VAREND),HL     ; Clear variables
0764   06DC 22 1F 81            LD      (ARREND),HL     ; Clear arrays
0765   06DF             
0766   06DF C1          CLREG:  POP     BC              ; Save return address
0767   06E0 2A 9F 80            LD      HL,(STRSPC)     ; Get end of working RAN
0768   06E3 F9                  LD      SP,HL           ; Set stack
0769   06E4 21 F8 80            LD      HL,TMSTPL       ; Temporary string pool
0770   06E7 22 F6 80            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   06EA AF                  XOR     A               ; A = 00
0772   06EB 6F                  LD      L,A             ; HL = 0000
0773   06EC 67                  LD      H,A
0774   06ED 22 19 81            LD      (CONTAD),HL     ; No CONTinue
0775   06F0 32 10 81            LD      (FORFLG),A      ; Clear FOR flag
0776   06F3 22 23 81            LD      (FNRGNM),HL     ; Clear FN argument
0777   06F6 E5                  PUSH    HL              ; HL = 0000
0778   06F7 C5                  PUSH    BC              ; Put back return
0779   06F8 2A 13 81    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   06FB C9                  RET                     ; Return to execution driver
0781   06FC             
0782   06FC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   06FE CD 86 08            CALL    OUTC            ; Output character
0784   0701 3E 20               LD      A,' '           ; Space
0785   0703 CD 86 08            CALL    OUTC            ; Output character
0786   0706 C3 93 80            JP      RINPUT          ; Get input line
0787   0709             
0788   0709 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   070A 32 F3 80            LD      (DATFLG),A      ; Reset literal flag
0790   070D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   070F 11 A6 80            LD      DE,BUFFER       ; Start of input buffer
0792   0712 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   0713 FE 20               CP      ' '             ; Is it a space?
0794   0715 CA 91 07            JP      Z,MOVDIR        ; Yes - Copy direct
0795   0718 47                  LD      B,A             ; Save character
0796   0719 FE 22               CP      '"'             ; Is it a quote?
0797   071B CA B1 07            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   071E B7                  OR      A               ; Is it end of buffer?
0799   071F CA B8 07            JP      Z,ENDBUF        ; Yes - End buffer
0800   0722 3A F3 80            LD      A,(DATFLG)      ; Get data type
0801   0725 B7                  OR      A               ; Literal?
0802   0726 7E                  LD      A,(HL)          ; Get byte to copy
0803   0727 C2 91 07            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   072A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   072C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   072E CA 91 07            JP      Z,MOVDIR        ; Yes - replace it
0807   0731 7E                  LD      A,(HL)          ; Get byte again
0808   0732 FE 30               CP      '0'             ; Is it less than '0'
0809   0734 DA 3C 07            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   0737 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   0739 DA 91 07            JP      C,MOVDIR        ; Yes - copy it direct
0812   073C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   073D 11 35 03            LD      DE,WORDS-1      ; Point to table
0814   0740 C5                  PUSH    BC              ; Save count
0815   0741 01 8D 07            LD      BC,RETNAD       ; Where to return to
0816   0744 C5                  PUSH    BC              ; Save return address
0817   0745 06 7F               LD      B,ZEND-1        ; First token value -1
0818   0747 7E                  LD      A,(HL)          ; Get byte
0819   0748 FE 61               CP      'a'             ; Less than 'a' ?
0820   074A DA 55 07            JP      C,SEARCH        ; Yes - search for words
0821   074D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   074F D2 55 07            JP      NC,SEARCH       ; Yes - search for words
0823   0752 E6 5F               AND     01011111B       ; Force upper case
0824   0754 77                  LD      (HL),A          ; Replace byte
0825   0755 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   0756 EB                  EX      DE,HL
0827   0757 23          GETNXT: INC     HL              ; Get next reserved word
0828   0758 B6                  OR      (HL)            ; Start of word?
0829   0759 F2 57 07            JP      P,GETNXT        ; No - move on
0830   075C 04                  INC     B               ; Increment token value
0831   075D 7E                  LD      A, (HL)         ; Get byte from table
0832   075E E6 7F               AND     01111111B       ; Strip bit 7
0833   0760 C8                  RET     Z               ; Return if end of list
0834   0761 B9                  CP      C               ; Same character as in buffer?
0835   0762 C2 57 07            JP      NZ,GETNXT       ; No - get next word
0836   0765 EB                  EX      DE,HL
0837   0766 E5                  PUSH    HL              ; Save start of word
0838   0767             
0839   0767 13          NXTBYT: INC     DE              ; Look through rest of word
0840   0768 1A                  LD      A,(DE)          ; Get byte from table
0841   0769 B7                  OR      A               ; End of word ?
0842   076A FA 89 07            JP      M,MATCH         ; Yes - Match found
0843   076D 4F                  LD      C,A             ; Save it
0844   076E 78                  LD      A,B             ; Get token value
0845   076F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   0771 C2 78 07            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   0774 CD 05 0A            CALL    GETCHR          ; Get next character
0848   0777 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   0778 23          NOSPC:  INC     HL              ; Next byte
0850   0779 7E                  LD      A,(HL)          ; Get byte
0851   077A FE 61               CP      'a'             ; Less than 'a' ?
0852   077C DA 81 07            JP      C,NOCHNG        ; Yes - don't change
0853   077F E6 5F               AND     01011111B       ; Make upper case
0854   0781 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   0782 CA 67 07            JP      Z,NXTBYT        ; Yes - keep testing
0856   0785 E1                  POP     HL              ; Get back start of word
0857   0786 C3 55 07            JP      SEARCH          ; Look at next word
0858   0789             
0859   0789 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   078A F1                  POP     AF              ; Throw away return
0861   078B EB                  EX      DE,HL
0862   078C C9                  RET                     ; Return to "RETNAD"
0863   078D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   078E 79                  LD      A,C             ; Get token value
0865   078F C1                  POP     BC              ; Restore buffer length
0866   0790 D1                  POP     DE              ; Get destination address
0867   0791 23          MOVDIR: INC     HL              ; Next source in buffer
0868   0792 12                  LD      (DE),A          ; Put byte in buffer
0869   0793 13                  INC     DE              ; Move up buffer
0870   0794 0C                  INC     C               ; Increment length of buffer
0871   0795 D6 3A               SUB     ':'             ; End of statement?
0872   0797 CA 9F 07            JP      Z,SETLIT        ; Jump if multi-statement line
0873   079A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   079C C2 A2 07            JP      NZ,TSTREM       ; No - see if REM
0875   079F 32 F3 80    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   07A2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   07A4 C2 12 07            JP      NZ,CRNCLP       ; No - Leave flag
0878   07A7 47                  LD      B,A             ; Copy rest of buffer
0879   07A8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   07A9 B7                  OR      A               ; End of line ?
0881   07AA CA B8 07            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   07AD B8                  CP      B               ; End of statement ?
0883   07AE CA 91 07            JP      Z,MOVDIR        ; Yes - Get next one
0884   07B1 23          CPYLIT: INC     HL              ; Move up source string
0885   07B2 12                  LD      (DE),A          ; Save in destination
0886   07B3 0C                  INC     C               ; Increment length
0887   07B4 13                  INC     DE              ; Move up destination
0888   07B5 C3 A8 07            JP      NXTCHR          ; Repeat
0889   07B8             
0890   07B8 21 A5 80    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   07BB 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   07BC 13                  INC     DE
0893   07BD 12                  LD      (DE),A          ; A = 00
0894   07BE 13                  INC     DE
0895   07BF 12                  LD      (DE),A          ; A = 00
0896   07C0 C9                  RET
0897   07C1             
0898   07C1 3A 89 80    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   07C4 B7                  OR      A               ; Is it zero?
0900   07C5 3E 00               LD      A,0             ; Zero A - Leave flags
0901   07C7 32 89 80            LD      (NULFLG),A      ; Zero null flag
0902   07CA C2 D5 07            JP      NZ,ECHDEL       ; Set - Echo it
0903   07CD 05                  DEC     B               ; Decrement length
0904   07CE CA F2 07            JP      Z,GETLIN        ; Get line again if empty
0905   07D1 CD 86 08            CALL    OUTC            ; Output null character
0906   07D4 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   07D5 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   07D6 2B                  DEC     HL              ; Back space buffer
0909   07D7 CA E9 07            JP      Z,OTKLN         ; No buffer - Try again
0910   07DA 7E                  LD      A,(HL)          ; Get deleted byte
0911   07DB CD 86 08            CALL    OUTC            ; Echo it
0912   07DE C3 FB 07            JP      MORINP          ; Get more input
0913   07E1             
0914   07E1 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   07E2 2B                  DEC     HL              ; Back space buffer
0916   07E3 CD 86 08            CALL    OUTC            ; Output character in A
0917   07E6 C2 FB 07            JP      NZ,MORINP       ; Not end - Get more
0918   07E9 CD 86 08    OTKLN:  CALL    OUTC            ; Output character in A
0919   07EC CD AD 0C    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   07EF C3 F2 07            JP      TTYLIN          ; Get line again
0921   07F2             
0922   07F2             GETLIN:
0923   07F2 21 A6 80    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   07F5 06 01               LD      B,1             ; Set buffer as empty
0925   07F7 AF                  XOR     A
0926   07F8 32 89 80            LD      (NULFLG),A      ; Clear null flag
0927   07FB CD B0 08    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   07FE 4F                  LD      C,A             ; Save character in C
0929   07FF FE 7F               CP      DEL             ; Delete character?
0930   0801 CA C1 07            JP      Z,DODEL         ; Yes - Process it
0931   0804 3A 89 80            LD      A,(NULFLG)      ; Get null flag
0932   0807 B7                  OR      A               ; Test null flag status
0933   0808 CA 14 08            JP      Z,PROCES        ; Reset - Process character
0934   080B 3E 00               LD      A,0             ; Set a null
0935   080D CD 86 08            CALL    OUTC            ; Output null
0936   0810 AF                  XOR     A               ; Clear A
0937   0811 32 89 80            LD      (NULFLG),A      ; Reset null flag
0938   0814 79          PROCES: LD      A,C             ; Get character
0939   0815 FE 07               CP      CTRLG           ; Bell?
0940   0817 CA 58 08            JP      Z,PUTCTL        ; Yes - Save it
0941   081A FE 03               CP      CTRLC           ; Is it control "C"?
0942   081C CC AD 0C            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   081F 37                  SCF                     ; Flag break
0944   0820 C8                  RET     Z               ; Return if control "C"
0945   0821 FE 0D               CP      CR              ; Is it enter?
0946   0823 CA A8 0C            JP      Z,ENDINP        ; Yes - Terminate input
0947   0826 FE 15               CP      CTRLU           ; Is it control "U"?
0948   0828 CA EC 07            JP      Z,KILIN         ; Yes - Get another line
0949   082B FE 40               CP      '@'             ; Is it "kill line"?
0950   082D CA E9 07            JP      Z,OTKLN         ; Yes - Kill line
0951   0830 FE 5F               CP      '_'             ; Is it delete?
0952   0832 CA E1 07            JP      Z,DELCHR        ; Yes - Delete character
0953   0835 FE 08               CP      BKSP            ; Is it backspace?
0954   0837 CA E1 07            JP      Z,DELCHR        ; Yes - Delete character
0955   083A FE 12               CP      CTRLR           ; Is it control "R"?
0956   083C C2 53 08            JP      NZ,PUTBUF       ; No - Put in buffer
0957   083F C5                  PUSH    BC              ; Save buffer length
0958   0840 D5                  PUSH    DE              ; Save DE
0959   0841 E5                  PUSH    HL              ; Save buffer address
0960   0842 36 00               LD      (HL),0          ; Mark end of buffer
0961   0844 CD 5D 1E            CALL    OUTNCR          ; Output and do CRLF
0962   0847 21 A6 80            LD      HL,BUFFER       ; Point to buffer start
0963   084A CD 4B 13            CALL    PRS             ; Output buffer
0964   084D E1                  POP     HL              ; Restore buffer address
0965   084E D1                  POP     DE              ; Restore DE
0966   084F C1                  POP     BC              ; Restore buffer length
0967   0850 C3 FB 07            JP      MORINP          ; Get another character
0968   0853             
0969   0853 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   0855 DA FB 07            JP      C,MORINP        ; Yes - Ignore
0971   0858 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   0859 FE 49               CP      72+1            ; Test for line overflow
0973   085B 3E 07               LD      A,CTRLG         ; Set a bell
0974   085D D2 6D 08            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   0860 79                  LD      A,C             ; Get character
0976   0861 71                  LD      (HL),C          ; Save in buffer
0977   0862 32 11 81            LD      (LSTBIN),A      ; Save last input byte
0978   0865 23                  INC     HL              ; Move up buffer
0979   0866 04                  INC     B               ; Increment length
0980   0867 CD 86 08    OUTIT:  CALL    OUTC            ; Output the character entered
0981   086A C3 FB 07            JP      MORINP          ; Get another character
0982   086D             
0983   086D CD 86 08    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   0870 3E 08               LD      A,BKSP          ; Set back space
0985   0872 C3 67 08            JP      OUTIT           ; Output it and get more
0986   0875             
0987   0875 7C          CPDEHL: LD      A,H             ; Get H
0988   0876 92                  SUB     D               ; Compare with D
0989   0877 C0                  RET     NZ              ; Different - Exit
0990   0878 7D                  LD      A,L             ; Get L
0991   0879 93                  SUB     E               ; Compare with E
0992   087A C9                  RET                     ; Return status
0993   087B             
0994   087B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   087C E3                  EX      (SP),HL         ; Address of test byte
0996   087D BE                  CP      (HL)            ; Same as in code string?
0997   087E 23                  INC     HL              ; Return address
0998   087F E3                  EX      (SP),HL         ; Put it back
0999   0880 CA 05 0A            JP      Z,GETCHR        ; Yes - Get next character
1000   0883 C3 AD 05            JP      SNERR           ; Different - ?SN Error
1001   0886             
1002   0886 F5          OUTC:   PUSH    AF              ; Save character
1003   0887 3A 8A 80            LD      A,(CTLOFG)      ; Get control "O" flag
1004   088A B7                  OR      A               ; Is it set?
1005   088B C2 80 13            JP      NZ,POPAF        ; Yes - don't output
1006   088E F1                  POP     AF              ; Restore character
1007   088F C5                  PUSH    BC              ; Save buffer length
1008   0890 F5                  PUSH    AF              ; Save character
1009   0891 FE 20               CP      ' '             ; Is it a control code?
1010   0893 DA AA 08            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   0896 3A 87 80            LD      A,(LWIDTH)      ; Get line width
1012   0899 47                  LD      B,A             ; To B
1013   089A 3A F0 80            LD      A,(CURPOS)      ; Get cursor position
1014   089D 04                  INC     B               ; Width 255?
1015   089E CA A6 08            JP      Z,INCLEN        ; Yes - No width limit
1016   08A1 05                  DEC     B               ; Restore width
1017   08A2 B8                  CP      B               ; At end of line?
1018   08A3 CC AD 0C            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   08A6 3C          INCLEN: INC     A               ; Move on one character
1020   08A7 32 F0 80            LD      (CURPOS),A      ; Save new position
1021   08AA F1          DINPOS: POP     AF              ; Restore character
1022   08AB C1                  POP     BC              ; Restore buffer length
1023   08AC CD 46 1E            CALL    MONOUT          ; Send it
1024   08AF C9                  RET
1025   08B0             
1026   08B0 CD 0A 1D    CLOTST: CALL    GETINP          ; Get input character
1027   08B3 E6 7F               AND     01111111B       ; Strip bit 7
1028   08B5 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   08B7 C0                  RET     NZ              ; No don't flip flag
1030   08B8 3A 8A 80            LD      A,(CTLOFG)      ; Get flag
1031   08BB 2F                  CPL                     ; Flip it
1032   08BC 32 8A 80            LD      (CTLOFG),A      ; Put it back
1033   08BF AF                  XOR     A               ; Null character
1034   08C0 C9                  RET
1035   08C1             
1036   08C1 CD D1 0A    LIST:   CALL    ATOH            ; ASCII number to DE
1037   08C4 C0                  RET     NZ              ; Return if anything extra
1038   08C5 C1                  POP     BC              ; Rubbish - Not needed
1039   08C6 CD 99 06            CALL    SRCHLN          ; Search for line number in DE
1040   08C9 C5                  PUSH    BC              ; Save address of line
1041   08CA CD 17 09            CALL    SETLIN          ; Set up lines counter
1042   08CD E1          LISTLP: POP     HL              ; Restore address of line
1043   08CE 4E                  LD      C,(HL)          ; Get LSB of next line
1044   08CF 23                  INC     HL
1045   08D0 46                  LD      B,(HL)          ; Get MSB of next line
1046   08D1 23                  INC     HL
1047   08D2 78                  LD      A,B             ; BC = 0 (End of program)?
1048   08D3 B1                  OR      C
1049   08D4 CA F8 05            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   08D7 CD 20 09            CALL    COUNT           ; Count lines
1051   08DA CD 30 0A            CALL    TSTBRK          ; Test for break key
1052   08DD C5                  PUSH    BC              ; Save address of next line
1053   08DE CD AD 0C            CALL    PRNTCRLF        ; Output CRLF
1054   08E1 5E                  LD      E,(HL)          ; Get LSB of line number
1055   08E2 23                  INC     HL
1056   08E3 56                  LD      D,(HL)          ; Get MSB of line number
1057   08E4 23                  INC     HL
1058   08E5 E5                  PUSH    HL              ; Save address of line start
1059   08E6 EB                  EX      DE,HL           ; Line number to HL
1060   08E7 CD EE 19            CALL    PRNTHL          ; Output line number in decimal
1061   08EA 3E 20               LD      A,' '           ; Space after line number
1062   08EC E1                  POP     HL              ; Restore start of line address
1063   08ED CD 86 08    LSTLP2: CALL    OUTC            ; Output character in A
1064   08F0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   08F1 B7                  OR      A               ; End of line?
1066   08F2 23                  INC     HL              ; To next byte in line
1067   08F3 CA CD 08            JP      Z,LISTLP        ; Yes - get next line
1068   08F6 F2 ED 08            JP      P,LSTLP2        ; No token - output it
1069   08F9 D6 7F               SUB     ZEND-1          ; Find and output word
1070   08FB 4F                  LD      C,A             ; Token offset+1 to C
1071   08FC 11 36 03            LD      DE,WORDS        ; Reserved word list
1072   08FF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   0900 13                  INC     DE              ; Move on to next
1074   0901 B7                  OR      A               ; Is it start of word?
1075   0902 F2 FF 08            JP      P,FNDTOK        ; No - Keep looking for word
1076   0905 0D                  DEC     C               ; Count words
1077   0906 C2 FF 08            JP      NZ,FNDTOK       ; Not there - keep looking
1078   0909 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   090B CD 86 08            CALL    OUTC            ; Output first character
1080   090E 1A                  LD      A,(DE)          ; Get next character
1081   090F 13                  INC     DE              ; Move on to next
1082   0910 B7                  OR      A               ; Is it end of word?
1083   0911 F2 09 09            JP      P,OUTWRD        ; No - output the rest
1084   0914 C3 F0 08            JP      LSTLP3          ; Next byte in line
1085   0917             
1086   0917 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   0918 2A 8D 80            LD      HL,(LINESN)     ; Get LINES number
1088   091B 22 8B 80            LD      (LINESC),HL     ; Save in LINES counter
1089   091E E1                  POP     HL
1090   091F C9                  RET
1091   0920             
1092   0920 E5          COUNT:  PUSH    HL              ; Save code string address
1093   0921 D5                  PUSH    DE
1094   0922 2A 8B 80            LD      HL,(LINESC)     ; Get LINES counter
1095   0925 11 FF FF            LD      DE,-1
1096   0928 ED 5A               ADC     HL,DE           ; Decrement
1097   092A 22 8B 80            LD      (LINESC),HL     ; Put it back
1098   092D D1                  POP     DE
1099   092E E1                  POP     HL              ; Restore code string address
1100   092F F0                  RET     P               ; Return if more lines to go
1101   0930 E5                  PUSH    HL              ; Save code string address
1102   0931 2A 8D 80            LD      HL,(LINESN)     ; Get LINES number
1103   0934 22 8B 80            LD      (LINESC),HL     ; Reset LINES counter
1104   0937 CD 0A 1D            CALL    GETINP          ; Get input character
1105   093A FE 03               CP      CTRLC           ; Is it control "C"?
1106   093C CA 43 09            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   093F E1                  POP     HL              ; Restore code string address
1108   0940 C3 20 09            JP      COUNT           ; Keep on counting
1109   0943             
1110   0943 2A 8D 80    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   0946 22 8B 80            LD      (LINESC),HL     ; Reset LINES counter
1112   0949 C3 A7 02            JP      BRKRET          ; Go and output "Break"
1113   094C             
1114   094C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   094E 32 10 81            LD      (FORFLG),A      ; Save "FOR" flag
1116   0951 CD B3 0B            CALL    LET             ; Set up initial index
1117   0954 C1                  POP     BC              ; Drop RETurn address
1118   0955 E5                  PUSH    HL              ; Save code string address
1119   0956 CD 9C 0B            CALL    DATA            ; Get next statement address
1120   0959 22 0C 81            LD      (LOOPST),HL     ; Save it for start of loop
1121   095C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   095F 39                  ADD     HL,SP           ; Point to it
1123   0960 CD 5A 05    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   0963 D1                  POP     DE              ; Get code string address
1125   0964 C2 7C 09            JP      NZ,FORFND       ; No nesting found
1126   0967 09                  ADD     HL,BC           ; Move into "FOR" block
1127   0968 D5                  PUSH    DE              ; Save code string address
1128   0969 2B                  DEC     HL
1129   096A 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   096B 2B                  DEC     HL
1131   096C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   096D 23                  INC     HL
1133   096E 23                  INC     HL
1134   096F E5                  PUSH    HL              ; Save block address
1135   0970 2A 0C 81            LD      HL,(LOOPST)     ; Get address of loop statement
1136   0973 CD 75 08            CALL    CPDEHL          ; Compare the FOR loops
1137   0976 E1                  POP     HL              ; Restore block address
1138   0977 C2 60 09            JP      NZ,FORSLP       ; Different FORs - Find another
1139   097A D1                  POP     DE              ; Restore code string address
1140   097B F9                  LD      SP,HL           ; Remove all nested loops
1141   097C             
1142   097C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   097D 0E 08               LD      C,8
1144   097F CD 8A 05            CALL    CHKSTK          ; Check for 8 levels of stack
1145   0982 E5                  PUSH    HL              ; Save code string address
1146   0983 2A 0C 81            LD      HL,(LOOPST)     ; Get first statement of loop
1147   0986 E3                  EX      (SP),HL         ; Save and restore code string
1148   0987 E5                  PUSH    HL              ; Re-save code string address
1149   0988 2A A1 80            LD      HL,(LINEAT)     ; Get current line number
1150   098B E3                  EX      (SP),HL         ; Save and restore code string
1151   098C CD 75 0E            CALL    TSTNUM          ; Make sure it's a number
1152   098F CD 7B 08            CALL    CHKSYN          ; Make sure "TO" is next
1153   0992 A6                  .BYTE   ZTO          ; "TO" token
1154   0993 CD 72 0E            CALL    GETNUM          ; Get "TO" expression value
1155   0996 E5                  PUSH    HL              ; Save code string address
1156   0997 CD A0 18            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   099A E1                  POP     HL              ; Restore code string address
1158   099B C5                  PUSH    BC              ; Save "TO" value in block
1159   099C D5                  PUSH    DE
1160   099D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   09A0 51                  LD      D,C             ; C=0
1162   09A1 5A                  LD      E,D             ; D=0
1163   09A2 7E                  LD      A,(HL)          ; Get next byte in code string
1164   09A3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   09A5 3E 01               LD      A,1             ; Sign of step = 1
1166   09A7 C2 B8 09            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   09AA CD 05 0A            CALL    GETCHR          ; Jump over "STEP" token
1168   09AD CD 72 0E            CALL    GETNUM          ; Get step value
1169   09B0 E5                  PUSH    HL              ; Save code string address
1170   09B1 CD A0 18            CALL    BCDEFP          ; Move STEP to BCDE
1171   09B4 CD 54 18            CALL    TSTSGN          ; Test sign of FPREG
1172   09B7 E1                  POP     HL              ; Restore code string address
1173   09B8 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   09B9 D5                  PUSH    DE
1175   09BA F5                  PUSH    AF              ; Save sign of STEP
1176   09BB 33                  INC     SP              ; Don't save flags
1177   09BC E5                  PUSH    HL              ; Save code string address
1178   09BD 2A 13 81            LD      HL,(BRKLIN)     ; Get address of index variable
1179   09C0 E3                  EX      (SP),HL         ; Save and restore code string
1180   09C1 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   09C3 C5                  PUSH    BC              ; Save it
1182   09C4 33                  INC     SP              ; Don't save C
1183   09C5             
1184   09C5 CD 30 0A    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   09C8 22 13 81            LD      (BRKLIN),HL     ; Save code address for break
1186   09CB 7E                  LD      A,(HL)          ; Get next byte in code string
1187   09CC FE 3A               CP      ':'             ; Multi statement line?
1188   09CE CA E5 09            JP      Z,EXCUTE        ; Yes - Execute it
1189   09D1 B7                  OR      A               ; End of line?
1190   09D2 C2 AD 05            JP      NZ,SNERR        ; No - Syntax error
1191   09D5 23                  INC     HL              ; Point to address of next line
1192   09D6 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   09D7 23                  INC     HL
1194   09D8 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   09D9 CA 57 0A            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   09DC 23                  INC     HL              ; Point to line number
1197   09DD 5E                  LD      E,(HL)          ; Get LSB of line number
1198   09DE 23                  INC     HL
1199   09DF 56                  LD      D,(HL)          ; Get MSB of line number
1200   09E0 EB                  EX      DE,HL           ; Line number to HL
1201   09E1 22 A1 80            LD      (LINEAT),HL     ; Save as current line number
1202   09E4 EB                  EX      DE,HL           ; Line number back to DE
1203   09E5 CD 05 0A    EXCUTE: CALL    GETCHR          ; Get key word
1204   09E8 11 C5 09            LD      DE,RUNCNT       ; Where to RETurn to
1205   09EB D5                  PUSH    DE              ; Save for RETurn
1206   09EC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   09ED D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   09EF DA B3 0B            JP      C,LET           ; No - try to assign it
1209   09F2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   09F4 D2 AD 05            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   09F7 07                  RLCA                    ; Double it
1212   09F8 4F                  LD      C,A             ; BC = Offset into table
1213   09F9 06 00               LD      B,0
1214   09FB EB                  EX      DE,HL           ; Save code string address
1215   09FC 21 55 04            LD      HL,WORDTB       ; Keyword address table
1216   09FF 09                  ADD     HL,BC           ; Point to routine address
1217   0A00 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   0A01 23                  INC     HL
1219   0A02 46                  LD      B,(HL)          ; Get MSB of routine address
1220   0A03 C5                  PUSH    BC              ; Save routine address
1221   0A04 EB                  EX      DE,HL           ; Restore code string address
1222   0A05             
1223   0A05 23          GETCHR: INC     HL              ; Point to next character
1224   0A06 7E                  LD      A,(HL)          ; Get next code string byte
1225   0A07 FE 3A               CP      ':'             ; Z if ':'
1226   0A09 D0                  RET     NC              ; NC if > "9"
1227   0A0A FE 20               CP      ' '
1228   0A0C CA 05 0A            JP      Z,GETCHR        ; Skip over spaces
1229   0A0F FE 30               CP      '0'
1230   0A11 3F                  CCF                     ; NC if < '0'
1231   0A12 3C                  INC     A               ; Test for zero - Leave carry
1232   0A13 3D                  DEC     A               ; Z if Null
1233   0A14 C9                  RET
1234   0A15             
1235   0A15 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   0A16 2A A3 80            LD      HL,(BASTXT)     ; Point to start of program
1237   0A19 CA 2A 0A            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   0A1C EB                  EX      DE,HL           ; Restore code string address
1239   0A1D CD D1 0A            CALL    ATOH            ; Get line number to DE
1240   0A20 E5                  PUSH    HL              ; Save code string address
1241   0A21 CD 99 06            CALL    SRCHLN          ; Search for line number in DE
1242   0A24 60                  LD      H,B             ; HL = Address of line
1243   0A25 69                  LD      L,C
1244   0A26 D1                  POP     DE              ; Restore code string address
1245   0A27 D2 72 0B            JP      NC,ULERR        ; ?UL Error if not found
1246   0A2A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   0A2B 22 21 81    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   0A2E EB                  EX      DE,HL           ; Restore code string address
1249   0A2F C9                  RET
1250   0A30             
1251   0A30             
1252   0A30 DF          TSTBRK: RST     18H             ; Check input status
1253   0A31 C8                  RET     Z               ; No key, go back
1254   0A32 D7                  RST     10H             ; Get the key into A
1255   0A33 FE 1B               CP      ESC             ; Escape key?
1256   0A35 28 11               JR      Z,BRK           ; Yes, break
1257   0A37 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   0A39 28 0D               JR      Z,BRK           ; Yes, break
1259   0A3B FE 13               CP      CTRLS           ; Stop scrolling?
1260   0A3D C0                  RET     NZ              ; Other key, ignore
1261   0A3E             
1262   0A3E             
1263   0A3E D7          STALL:  RST     10H             ; Wait for key
1264   0A3F FE 11               CP      CTRLQ           ; Resume scrolling?
1265   0A41 C8                  RET      Z              ; Release the chokehold
1266   0A42 FE 03               CP      CTRLC           ; Second break?
1267   0A44 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   0A46 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   0A48             
1270   0A48 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   0A4A 32 92 80            LD      (BRKFLG),A      ; Store it
1272   0A4D             
1273   0A4D             
1274   0A4D C0          STOP:   RET     NZ              ; Exit if anything else
1275   0A4E F6                  .BYTE   0F6H            ; Flag "STOP"
1276   0A4F C0          PEND:   RET     NZ              ; Exit if anything else
1277   0A50 22 13 81            LD      (BRKLIN),HL     ; Save point of break
1278   0A53 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   0A54 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   0A56 C1                  POP     BC              ; Return not needed and more
1281   0A57 2A A1 80    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   0A5A F5                  PUSH    AF              ; Save STOP / END status
1283   0A5B 7D                  LD      A,L             ; Is it direct break?
1284   0A5C A4                  AND     H
1285   0A5D 3C                  INC     A               ; Line is -1 if direct break
1286   0A5E CA 6A 0A            JP      Z,NOLIN         ; Yes - No line number
1287   0A61 22 17 81            LD      (ERRLIN),HL     ; Save line of break
1288   0A64 2A 13 81            LD      HL,(BRKLIN)     ; Get point of break
1289   0A67 22 19 81            LD      (CONTAD),HL     ; Save point to CONTinue
1290   0A6A AF          NOLIN:  XOR     A
1291   0A6B 32 8A 80            LD      (CTLOFG),A      ; Enable output
1292   0A6E CD A0 0C            CALL    STTLIN          ; Start a new line
1293   0A71 F1                  POP     AF              ; Restore STOP / END status
1294   0A72 21 50 05            LD      HL,BRKMSG       ; "Break" message
1295   0A75 C2 E1 05            JP      NZ,ERRIN        ; "in line" wanted?
1296   0A78 C3 F8 05            JP      PRNTOK          ; Go to command mode
1297   0A7B             
1298   0A7B 2A 19 81    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   0A7E 7C                  LD      A,H             ; Is it zero?
1300   0A7F B5                  OR      L
1301   0A80 1E 20               LD      E,CN            ; ?CN Error
1302   0A82 CA C1 05            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   0A85 EB                  EX      DE,HL           ; Save code string address
1304   0A86 2A 17 81            LD      HL,(ERRLIN)     ; Get line of last break
1305   0A89 22 A1 80            LD      (LINEAT),HL     ; Set up current line number
1306   0A8C EB                  EX      DE,HL           ; Restore code string address
1307   0A8D C9                  RET                     ; CONTinue where left off
1308   0A8E             
1309   0A8E CD D3 15    NULL:   CALL    GETINT          ; Get integer 0-255
1310   0A91 C0                  RET     NZ              ; Return if bad value
1311   0A92 32 86 80            LD      (NULLS),A       ; Set nulls number
1312   0A95 C9                  RET
1313   0A96             
1314   0A96             
1315   0A96 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   0A97 2A 8F 80            LD      HL,(CHKSUM)     ; Get check sum
1317   0A9A 06 00               LD      B,0             ; BC - Value of byte
1318   0A9C 4F                  LD      C,A
1319   0A9D 09                  ADD     HL,BC           ; Add byte to check sum
1320   0A9E 22 8F 80            LD      (CHKSUM),HL     ; Re-save check sum
1321   0AA1 E1                  POP     HL              ; Restore address in array
1322   0AA2 C9                  RET
1323   0AA3             
1324   0AA3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   0AA4 FE 41               CP      'A'             ; < 'a' ?
1326   0AA6 D8                  RET     C               ; Carry set if not letter
1327   0AA7 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   0AA9 3F                  CCF
1329   0AAA C9                  RET                     ; Carry set if not letter
1330   0AAB             
1331   0AAB CD 05 0A    FPSINT: CALL    GETCHR          ; Get next character
1332   0AAE CD 72 0E    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   0AB1 CD 54 18    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   0AB4 FA CC 0A            JP      M,FCERR         ; Negative - ?FC Error
1335   0AB7 3A 2C 81    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   0ABA FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   0ABC DA FC 18            JP      C,FPINT         ; Yes - convert it
1338   0ABF 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   0AC2 11 00 00            LD      DE,0000
1340   0AC5 E5                  PUSH    HL              ; Save code string address
1341   0AC6 CD CF 18            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   0AC9 E1                  POP     HL              ; Restore code string address
1343   0ACA 51                  LD      D,C             ; MSB to D
1344   0ACB C8                  RET     Z               ; Return if in range
1345   0ACC 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   0ACE C3 C1 05            JP      ERROR           ; Output error-
1347   0AD1             
1348   0AD1 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   0AD2 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   0AD5 CD 05 0A    GTLNLP: CALL    GETCHR          ; Get next character
1351   0AD8 D0                  RET     NC              ; Exit if not a digit
1352   0AD9 E5                  PUSH    HL              ; Save code string address
1353   0ADA F5                  PUSH    AF              ; Save digit
1354   0ADB 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   0ADE CD 75 08            CALL    CPDEHL          ; Number in range?
1356   0AE1 DA AD 05            JP      C,SNERR         ; No - ?SN Error
1357   0AE4 62                  LD      H,D             ; HL = Number
1358   0AE5 6B                  LD      L,E
1359   0AE6 19                  ADD     HL,DE           ; Times 2
1360   0AE7 29                  ADD     HL,HL           ; Times 4
1361   0AE8 19                  ADD     HL,DE           ; Times 5
1362   0AE9 29                  ADD     HL,HL           ; Times 10
1363   0AEA F1                  POP     AF              ; Restore digit
1364   0AEB D6 30               SUB     '0'             ; Make it 0 to 9
1365   0AED 5F                  LD      E,A             ; DE = Value of digit
1366   0AEE 16 00               LD      D,0
1367   0AF0 19                  ADD     HL,DE           ; Add to number
1368   0AF1 EB                  EX      DE,HL           ; Number to DE
1369   0AF2 E1                  POP     HL              ; Restore code string address
1370   0AF3 C3 D5 0A            JP      GTLNLP          ; Go to next character
1371   0AF6             
1372   0AF6 CA C9 06    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   0AF9 CD AE 0A            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   0AFC 2B                  DEC     HL              ; Cancel increment
1375   0AFD CD 05 0A            CALL    GETCHR          ; Get next character
1376   0B00 E5                  PUSH    HL              ; Save code string address
1377   0B01 2A F4 80            LD      HL,(LSTRAM)     ; Get end of RAM
1378   0B04 CA 19 0B            JP      Z,STORED        ; No value given - Use stored
1379   0B07 E1                  POP     HL              ; Restore code string address
1380   0B08 CD 7B 08            CALL    CHKSYN          ; Check for comma
1381   0B0B 2C                  .BYTE      ','
1382   0B0C D5                  PUSH    DE              ; Save number
1383   0B0D CD AE 0A            CALL    POSINT          ; Get integer 0 to 32767
1384   0B10 2B                  DEC     HL              ; Cancel increment
1385   0B11 CD 05 0A            CALL    GETCHR          ; Get next character
1386   0B14 C2 AD 05            JP      NZ,SNERR        ; ?SN Error if more on line
1387   0B17 E3                  EX      (SP),HL         ; Save code string address
1388   0B18 EB                  EX      DE,HL           ; Number to DE
1389   0B19 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   0B1A 93                  SUB     E               ; Subtract LSB of string space
1391   0B1B 5F                  LD      E,A             ; Save LSB
1392   0B1C 7C                  LD      A,H             ; Get MSB of new RAM top
1393   0B1D 9A                  SBC     A,D             ; Subtract MSB of string space
1394   0B1E 57                  LD      D,A             ; Save MSB
1395   0B1F DA A2 05            JP      C,OMERR         ; ?OM Error if not enough mem
1396   0B22 E5                  PUSH    HL              ; Save RAM top
1397   0B23 2A 1B 81            LD      HL,(PROGND)     ; Get program end
1398   0B26 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   0B29 09                  ADD     HL,BC           ; Get lowest address
1400   0B2A CD 75 08            CALL    CPDEHL          ; Enough memory?
1401   0B2D D2 A2 05            JP      NC,OMERR        ; No - ?OM Error
1402   0B30 EB                  EX      DE,HL           ; RAM top to HL
1403   0B31 22 9F 80            LD      (STRSPC),HL     ; Set new string space
1404   0B34 E1                  POP     HL              ; End of memory to use
1405   0B35 22 F4 80            LD      (LSTRAM),HL     ; Set new top of RAM
1406   0B38 E1                  POP     HL              ; Restore code string address
1407   0B39 C3 C9 06            JP      INTVAR          ; Initialise variables
1408   0B3C             
1409   0B3C CA C5 06    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   0B3F CD C9 06            CALL    INTVAR          ; Initialise variables
1411   0B42 01 C5 09            LD      BC,RUNCNT       ; Execution driver loop
1412   0B45 C3 58 0B            JP      RUNLIN          ; RUN from line number
1413   0B48             
1414   0B48 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   0B4A CD 8A 05            CALL    CHKSTK          ; Check for 3 levels of stack
1416   0B4D C1                  POP     BC              ; Get return address
1417   0B4E E5                  PUSH    HL              ; Save code string for RETURN
1418   0B4F E5                  PUSH    HL              ; And for GOSUB routine
1419   0B50 2A A1 80            LD      HL,(LINEAT)     ; Get current line
1420   0B53 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   0B54 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   0B56 F5                  PUSH    AF              ; Save token
1423   0B57 33                  INC     SP              ; Don't save flags
1424   0B58             
1425   0B58 C5          RUNLIN: PUSH    BC              ; Save return address
1426   0B59 CD D1 0A    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   0B5C CD 9E 0B            CALL    REM             ; Get end of line
1428   0B5F E5                  PUSH    HL              ; Save end of line
1429   0B60 2A A1 80            LD      HL,(LINEAT)     ; Get current line
1430   0B63 CD 75 08            CALL    CPDEHL          ; Line after current?
1431   0B66 E1                  POP     HL              ; Restore end of line
1432   0B67 23                  INC     HL              ; Start of next line
1433   0B68 DC 9C 06            CALL    C,SRCHLP        ; Line is after current line
1434   0B6B D4 99 06            CALL    NC,SRCHLN       ; Line is before current line
1435   0B6E 60                  LD      H,B             ; Set up code string address
1436   0B6F 69                  LD      L,C
1437   0B70 2B                  DEC     HL              ; Incremented after
1438   0B71 D8                  RET     C               ; Line found
1439   0B72 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   0B74 C3 C1 05            JP      ERROR           ; Output error message
1441   0B77             
1442   0B77 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   0B78 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   0B7A CD 56 05            CALL    BAKSTK          ; Look "GOSUB" block
1445   0B7D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   0B7E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   0B80 1E 04               LD      E,RG            ; ?RG Error
1448   0B82 C2 C1 05            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   0B85 E1                  POP     HL              ; Get RETURN line number
1450   0B86 22 A1 80            LD      (LINEAT),HL     ; Save as current
1451   0B89 23                  INC     HL              ; Was it from direct statement?
1452   0B8A 7C                  LD      A,H
1453   0B8B B5                  OR      L               ; Return to line
1454   0B8C C2 96 0B            JP      NZ,RETLIN       ; No - Return to line
1455   0B8F 3A 11 81            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   0B92 B7                  OR      A               ; If so buffer is corrupted
1457   0B93 C2 F7 05            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   0B96 21 C5 09    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   0B99 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   0B9A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   0B9B E1          NXTDTA: POP     HL              ; Restore code string address
1462   0B9C             
1463   0B9C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   0B9E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   0BA0 06 00               LD      B,0
1466   0BA2 79          NXTSTL: LD      A,C             ; Statement and byte
1467   0BA3 48                  LD      C,B
1468   0BA4 47                  LD      B,A             ; Statement end byte
1469   0BA5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   0BA6 B7                  OR      A               ; End of line?
1471   0BA7 C8                  RET     Z               ; Yes - Exit
1472   0BA8 B8                  CP      B               ; End of statement?
1473   0BA9 C8                  RET     Z               ; Yes - Exit
1474   0BAA 23                  INC     HL              ; Next byte
1475   0BAB FE 22               CP      '"'             ; Literal string?
1476   0BAD CA A2 0B            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   0BB0 C3 A5 0B            JP      NXTSTT          ; Keep looking
1478   0BB3             
1479   0BB3 CD 68 10    LET:    CALL    GETVAR          ; Get variable name
1480   0BB6 CD 7B 08            CALL    CHKSYN          ; Make sure "=" follows
1481   0BB9 B4                  .BYTE      ZEQUAL          ; "=" token
1482   0BBA D5                  PUSH    DE              ; Save address of variable
1483   0BBB 3A F2 80            LD      A,(TYPE)        ; Get data type
1484   0BBE F5                  PUSH    AF              ; Save type
1485   0BBF CD 84 0E            CALL    EVAL            ; Evaluate expression
1486   0BC2 F1                  POP     AF              ; Restore type
1487   0BC3 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   0BC4 22 13 81            LD      (BRKLIN),HL     ; Save address of variable
1489   0BC7 1F                  RRA                     ; Adjust type
1490   0BC8 CD 77 0E            CALL    CHKTYP          ; Check types are the same
1491   0BCB CA 06 0C            JP      Z,LETNUM        ; Numeric - Move value
1492   0BCE E5          LETSTR: PUSH    HL              ; Save address of string var
1493   0BCF 2A 29 81            LD      HL,(FPREG)      ; Pointer to string entry
1494   0BD2 E5                  PUSH    HL              ; Save it on stack
1495   0BD3 23                  INC     HL              ; Skip over length
1496   0BD4 23                  INC     HL
1497   0BD5 5E                  LD      E,(HL)          ; LSB of string address
1498   0BD6 23                  INC     HL
1499   0BD7 56                  LD      D,(HL)          ; MSB of string address
1500   0BD8 2A A3 80            LD      HL,(BASTXT)     ; Point to start of program
1501   0BDB CD 75 08            CALL    CPDEHL          ; Is string before program?
1502   0BDE D2 F5 0B            JP      NC,CRESTR       ; Yes - Create string entry
1503   0BE1 2A 9F 80            LD      HL,(STRSPC)     ; Point to string space
1504   0BE4 CD 75 08            CALL    CPDEHL          ; Is string literal in program?
1505   0BE7 D1                  POP     DE              ; Restore address of string
1506   0BE8 D2 FD 0B            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   0BEB 21 04 81            LD      HL,TMPSTR       ; Temporary string pool
1508   0BEE CD 75 08            CALL    CPDEHL          ; Is string in temporary pool?
1509   0BF1 D2 FD 0B            JP      NC,MVSTPT       ; No - Set up pointer
1510   0BF4 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   0BF5 D1          CRESTR: POP     DE              ; Restore address of string
1512   0BF6 CD AC 14            CALL    BAKTMP          ; Back to last tmp-str entry
1513   0BF9 EB                  EX      DE,HL           ; Address of string entry
1514   0BFA CD E5 12            CALL    SAVSTR          ; Save string in string area
1515   0BFD CD AC 14    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   0C00 E1                  POP     HL              ; Get string pointer
1517   0C01 CD AF 18            CALL    DETHL4          ; Move string pointer to var
1518   0C04 E1                  POP     HL              ; Restore code string address
1519   0C05 C9                  RET
1520   0C06             
1521   0C06 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   0C07 CD AC 18            CALL    FPTHL           ; Move value to variable
1523   0C0A D1                  POP     DE              ; Restore address of variable
1524   0C0B E1                  POP     HL              ; Restore code string address
1525   0C0C C9                  RET
1526   0C0D             
1527   0C0D CD D3 15    ON:     CALL    GETINT          ; Get integer 0-255
1528   0C10 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   0C11 47                  LD      B,A             ; Save in B
1530   0C12 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   0C14 CA 1C 0C            JP      Z,ONGO          ; Yes - Find line number
1532   0C17 CD 7B 08            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   0C1A 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   0C1B 2B                  DEC     HL              ; Cancel increment
1535   0C1C 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   0C1D 0D          ONGOLP: DEC     C               ; Count branches
1537   0C1E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   0C1F CA ED 09            JP      Z,ONJMP         ; Go to that line if right one
1539   0C22 CD D2 0A            CALL    GETLN           ; Get line number to DE
1540   0C25 FE 2C               CP      ','             ; Another line number?
1541   0C27 C0                  RET     NZ              ; No - Drop through
1542   0C28 C3 1D 0C            JP      ONGOLP          ; Yes - loop
1543   0C2B             
1544   0C2B CD 84 0E    IF:     CALL    EVAL            ; Evaluate expression
1545   0C2E 7E                  LD      A,(HL)          ; Get token
1546   0C2F FE 88               CP      ZGOTO           ; "GOTO" token?
1547   0C31 CA 39 0C            JP      Z,IFGO          ; Yes - Get line
1548   0C34 CD 7B 08            CALL    CHKSYN          ; Make sure it's "THEN"
1549   0C37 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   0C38 2B                  DEC     HL              ; Cancel increment
1551   0C39 CD 75 0E    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   0C3C CD 54 18            CALL    TSTSGN          ; Test state of expression
1553   0C3F CA 9E 0B            JP      Z,REM           ; False - Drop through
1554   0C42 CD 05 0A            CALL    GETCHR          ; Get next character
1555   0C45 DA 59 0B            JP      C,GOTO          ; Number - GOTO that line
1556   0C48 C3 EC 09            JP      IFJMP           ; Otherwise do statement
1557   0C4B             
1558   0C4B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   0C4C CD 05 0A            CALL    GETCHR          ; Get next character
1560   0C4F CA AD 0C    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   0C52 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   0C53 FE A5               CP      ZTAB            ; "TAB(" token?
1563   0C55 CA E0 0C            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   0C58 FE A8               CP      ZSPC            ; "SPC(" token?
1565   0C5A CA E0 0C            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   0C5D E5                  PUSH    HL              ; Save code string address
1567   0C5E FE 2C               CP      ','             ; Comma?
1568   0C60 CA C9 0C            JP      Z,DOCOM         ; Yes - Move to next zone
1569   0C63 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   0C65 CA 03 0D            JP      Z,NEXITM        ; Do semi-colon routine
1571   0C68 C1                  POP     BC              ; Code string address to BC
1572   0C69 CD 84 0E            CALL    EVAL            ; Evaluate expression
1573   0C6C E5                  PUSH    HL              ; Save code string address
1574   0C6D 3A F2 80            LD      A,(TYPE)        ; Get variable type
1575   0C70 B7                  OR      A               ; Is it a string variable?
1576   0C71 C2 99 0C            JP      NZ,PRNTST       ; Yes - Output string contents
1577   0C74 CD F9 19            CALL    NUMASC          ; Convert number to text
1578   0C77 CD 09 13            CALL    CRTST           ; Create temporary string
1579   0C7A 36 20               LD      (HL),' '        ; Followed by a space
1580   0C7C 2A 29 81            LD      HL,(FPREG)      ; Get length of output
1581   0C7F 34                  INC     (HL)            ; Plus 1 for the space
1582   0C80 2A 29 81            LD      HL,(FPREG)      ; < Not needed >
1583   0C83 3A 87 80            LD      A,(LWIDTH)      ; Get width of line
1584   0C86 47                  LD      B,A             ; To B
1585   0C87 04                  INC     B               ; Width 255 (No limit)?
1586   0C88 CA 95 0C            JP      Z,PRNTNB        ; Yes - Output number string
1587   0C8B 04                  INC     B               ; Adjust it
1588   0C8C 3A F0 80            LD      A,(CURPOS)      ; Get cursor position
1589   0C8F 86                  ADD     A,(HL)          ; Add length of string
1590   0C90 3D                  DEC     A               ; Adjust it
1591   0C91 B8                  CP      B               ; Will output fit on this line?
1592   0C92 D4 AD 0C            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   0C95 CD 4E 13    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   0C98 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   0C99 C4 4E 13    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   0C9C E1                  POP     HL              ; Restore code string address
1597   0C9D C3 4B 0C            JP      MRPRNT          ; See if more to PRINT
1598   0CA0             
1599   0CA0 3A F0 80    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   0CA3 B7                  OR      A               ; Already at start?
1601   0CA4 C8                  RET     Z               ; Yes - Do nothing
1602   0CA5 C3 AD 0C            JP      PRNTCRLF        ; Start a new line
1603   0CA8             
1604   0CA8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   0CAA 21 A5 80            LD      HL,BUFFER-1     ; Point to buffer
1606   0CAD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   0CAF CD 86 08            CALL    OUTC            ; Output character
1608   0CB2 3E 0A               LD      A,LF            ; Load a LF
1609   0CB4 CD 86 08            CALL    OUTC            ; Output character
1610   0CB7 AF          DONULL: XOR     A               ; Set to position 0
1611   0CB8 32 F0 80            LD      (CURPOS),A      ; Store it
1612   0CBB 3A 86 80            LD      A,(NULLS)       ; Get number of nulls
1613   0CBE 3D          NULLP:  DEC     A               ; Count them
1614   0CBF C8                  RET     Z               ; Return if done
1615   0CC0 F5                  PUSH    AF              ; Save count
1616   0CC1 AF                  XOR     A               ; Load a null
1617   0CC2 CD 86 08            CALL    OUTC            ; Output it
1618   0CC5 F1                  POP     AF              ; Restore count
1619   0CC6 C3 BE 0C            JP      NULLP           ; Keep counting
1620   0CC9             
1621   0CC9 3A 88 80    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   0CCC 47                  LD      B,A             ; Save in B
1623   0CCD 3A F0 80            LD      A,(CURPOS)      ; Get current position
1624   0CD0 B8                  CP      B               ; Within the limit?
1625   0CD1 D4 AD 0C            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   0CD4 D2 03 0D            JP      NC,NEXITM       ; Get next item
1627   0CD7 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   0CD9 D2 D7 0C            JP      NC,ZONELP       ; Repeat if more zones
1629   0CDC 2F                  CPL                     ; Number of spaces to output
1630   0CDD C3 F8 0C            JP      ASPCS           ; Output them
1631   0CE0             
1632   0CE0 F5          DOTAB:  PUSH    AF              ; Save token
1633   0CE1 CD D0 15            CALL    FNDNUM          ; Evaluate expression
1634   0CE4 CD 7B 08            CALL    CHKSYN          ; Make sure ")" follows
1635   0CE7 29                  .BYTE   ")"
1636   0CE8 2B                  DEC     HL              ; Back space on to ")"
1637   0CE9 F1                  POP     AF              ; Restore token
1638   0CEA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   0CEC E5                  PUSH    HL              ; Save code string address
1640   0CED CA F3 0C            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   0CF0 3A F0 80            LD      A,(CURPOS)      ; Get current position
1642   0CF3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   0CF4 83                  ADD     A,E             ; Total number to print
1644   0CF5 D2 03 0D            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   0CF8 3C          ASPCS:  INC     A               ; Output A spaces
1646   0CF9 47                  LD      B,A             ; Save number to print
1647   0CFA 3E 20               LD      A,' '           ; Space
1648   0CFC CD 86 08    SPCLP:  CALL    OUTC            ; Output character in A
1649   0CFF 05                  DEC     B               ; Count them
1650   0D00 C2 FC 0C            JP      NZ,SPCLP        ; Repeat if more
1651   0D03 E1          NEXITM: POP     HL              ; Restore code string address
1652   0D04 CD 05 0A            CALL    GETCHR          ; Get next character
1653   0D07 C3 52 0C            JP      PRNTLP          ; More to print
1654   0D0A             
1655   0D0A 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   0D0E 6F 20 66 72 
1655   0D12 6F 6D 20 73 
1655   0D16 74 61 72 74 
1655   0D1A 0D 0A 00 
1656   0D1D             
1657   0D1D 3A 12 81    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   0D20 B7                  OR      A
1659   0D21 C2 A7 05            JP      NZ,DATSNR       ; READ - ?SN Error
1660   0D24 C1                  POP     BC              ; Throw away code string addr
1661   0D25 21 0A 0D            LD      HL,REDO         ; "Redo from start" message
1662   0D28 CD 4B 13            CALL    PRS             ; Output string
1663   0D2B C3 F8 06            JP      DOAGN           ; Do last INPUT again
1664   0D2E             
1665   0D2E CD B6 12    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   0D31 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   0D32 FE 22               CP      '"'             ; Is there a prompt string?
1668   0D34 3E 00               LD      A,0             ; Clear A and leave flags
1669   0D36 32 8A 80            LD      (CTLOFG),A      ; Enable output
1670   0D39 C2 48 0D            JP      NZ,NOPMPT       ; No prompt - get input
1671   0D3C CD 0A 13            CALL    QTSTR           ; Get string terminated by '"'
1672   0D3F CD 7B 08            CALL    CHKSYN          ; Check for ';' after prompt
1673   0D42 3B                  .BYTE   ';'
1674   0D43 E5                  PUSH    HL              ; Save code string address
1675   0D44 CD 4E 13            CALL    PRS1            ; Output prompt string
1676   0D47 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   0D48 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   0D49 CD FC 06            CALL    PROMPT          ; Get input with "? " prompt
1679   0D4C C1                  POP     BC              ; Restore code string address
1680   0D4D DA 54 0A            JP      C,INPBRK        ; Break pressed - Exit
1681   0D50 23                  INC     HL              ; Next byte
1682   0D51 7E                  LD      A,(HL)          ; Get it
1683   0D52 B7                  OR      A               ; End of line?
1684   0D53 2B                  DEC     HL              ; Back again
1685   0D54 C5                  PUSH    BC              ; Re-save code string address
1686   0D55 CA 9B 0B            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   0D58 36 2C               LD      (HL),','        ; Store comma as separator
1688   0D5A C3 62 0D            JP      NXTITM          ; Get next item
1689   0D5D             
1690   0D5D E5          READ:   PUSH    HL              ; Save code string address
1691   0D5E 2A 21 81            LD      HL,(NXTDAT)     ; Next DATA statement
1692   0D61 F6                  .BYTE   0F6H            ; Flag "READ"
1693   0D62 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   0D63 32 12 81            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   0D66 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   0D67 C3 6E 0D            JP      GTVLUS          ; Get values
1697   0D6A             
1698   0D6A CD 7B 08    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   0D6D 2C                  .BYTE      ','
1700   0D6E CD 68 10    GTVLUS: CALL    GETVAR          ; Get variable name
1701   0D71 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   0D72 D5                  PUSH    DE              ; Save variable address
1703   0D73 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   0D74 FE 2C               CP      ','             ; Comma?
1705   0D76 CA 96 0D            JP      Z,ANTVLU        ; Yes - Get another value
1706   0D79 3A 12 81            LD      A,(READFG)      ; Is it READ?
1707   0D7C B7                  OR      A
1708   0D7D C2 03 0E            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   0D80 3E 3F               LD      A,'?'           ; More INPUT needed
1710   0D82 CD 86 08            CALL    OUTC            ; Output character
1711   0D85 CD FC 06            CALL    PROMPT          ; Get INPUT with prompt
1712   0D88 D1                  POP     DE              ; Variable address
1713   0D89 C1                  POP     BC              ; Code string address
1714   0D8A DA 54 0A            JP      C,INPBRK        ; Break pressed
1715   0D8D 23                  INC     HL              ; Point to next DATA byte
1716   0D8E 7E                  LD      A,(HL)          ; Get byte
1717   0D8F B7                  OR      A               ; Is it zero (No input) ?
1718   0D90 2B                  DEC     HL              ; Back space INPUT pointer
1719   0D91 C5                  PUSH    BC              ; Save code string address
1720   0D92 CA 9B 0B            JP      Z,NXTDTA        ; Find end of buffer
1721   0D95 D5                  PUSH    DE              ; Save variable address
1722   0D96 3A F2 80    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   0D99 B7                  OR      A               ; Is it numeric?
1724   0D9A CA C0 0D            JP      Z,INPBIN        ; Yes - Convert to binary
1725   0D9D CD 05 0A            CALL    GETCHR          ; Get next character
1726   0DA0 57                  LD      D,A             ; Save input character
1727   0DA1 47                  LD      B,A             ; Again
1728   0DA2 FE 22               CP      '"'             ; Start of literal sting?
1729   0DA4 CA B4 0D            JP      Z,STRENT        ; Yes - Create string entry
1730   0DA7 3A 12 81            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   0DAA B7                  OR      A
1732   0DAB 57                  LD      D,A             ; Save 00 if "INPUT"
1733   0DAC CA B1 0D            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   0DAF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   0DB1 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   0DB3 2B                  DEC     HL              ; Back space for DTSTR
1737   0DB4 CD 0D 13    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   0DB7 EB                  EX      DE,HL           ; String address to DE
1739   0DB8 21 CB 0D            LD      HL,LTSTND       ; Where to go after LETSTR
1740   0DBB E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   0DBC D5                  PUSH    DE              ; Save address of string
1742   0DBD C3 CE 0B            JP      LETSTR          ; Assign string to variable
1743   0DC0             
1744   0DC0 CD 05 0A    INPBIN: CALL    GETCHR          ; Get next character
1745   0DC3 CD 5B 19            CALL    ASCTFP          ; Convert ASCII to FP number
1746   0DC6 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   0DC7 CD AC 18            CALL    FPTHL           ; Move FPREG to variable
1748   0DCA E1                  POP     HL              ; Restore input pointer
1749   0DCB 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   0DCC CD 05 0A            CALL    GETCHR          ; Get next character
1751   0DCF CA D7 0D            JP      Z,MORDT         ; End of line - More needed?
1752   0DD2 FE 2C               CP      ','             ; Another value?
1753   0DD4 C2 1D 0D            JP      NZ,BADINP       ; No - Bad input
1754   0DD7 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   0DD8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   0DD9 CD 05 0A            CALL    GETCHR          ; Get next character
1757   0DDC C2 6A 0D            JP      NZ,NEDMOR       ; More needed - Get it
1758   0DDF D1                  POP     DE              ; Restore DATA pointer
1759   0DE0 3A 12 81            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   0DE3 B7                  OR      A
1761   0DE4 EB                  EX      DE,HL           ; DATA pointer to HL
1762   0DE5 C2 2B 0A            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   0DE8 D5                  PUSH    DE              ; Save code string address
1764   0DE9 B6                  OR      (HL)            ; More input given?
1765   0DEA 21 F2 0D            LD      HL,EXTIG        ; "?Extra ignored" message
1766   0DED C4 4B 13            CALL    NZ,PRS          ; Output string if extra given
1767   0DF0 E1                  POP     HL              ; Restore code string address
1768   0DF1 C9                  RET
1769   0DF2             
1770   0DF2 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   0DF6 72 61 20 69 
1770   0DFA 67 6E 6F 72 
1770   0DFE 65 64 0D 0A 
1770   0E02 00 
1771   0E03             
1772   0E03 CD 9C 0B    FDTLP:  CALL    DATA            ; Get next statement
1773   0E06 B7                  OR      A               ; End of line?
1774   0E07 C2 1C 0E            JP      NZ,FANDT        ; No - See if DATA statement
1775   0E0A 23                  INC     HL
1776   0E0B 7E                  LD      A,(HL)          ; End of program?
1777   0E0C 23                  INC     HL
1778   0E0D B6                  OR      (HL)            ; 00 00 Ends program
1779   0E0E 1E 06               LD      E,OD            ; ?OD Error
1780   0E10 CA C1 05            JP      Z,ERROR         ; Yes - Out of DATA
1781   0E13 23                  INC     HL
1782   0E14 5E                  LD      E,(HL)          ; LSB of line number
1783   0E15 23                  INC     HL
1784   0E16 56                  LD      D,(HL)          ; MSB of line number
1785   0E17 EB                  EX      DE,HL
1786   0E18 22 0E 81            LD      (DATLIN),HL     ; Set line of current DATA item
1787   0E1B EB                  EX      DE,HL
1788   0E1C CD 05 0A    FANDT:  CALL    GETCHR          ; Get next character
1789   0E1F FE 83               CP      ZDATA           ; "DATA" token
1790   0E21 C2 03 0E            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   0E24 C3 96 0D            JP      ANTVLU          ; Found - Convert input
1792   0E27             
1793   0E27 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   0E2A C4 68 10    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   0E2D 22 13 81            LD      (BRKLIN),HL     ; Save code string address
1796   0E30 CD 56 05            CALL    BAKSTK          ; Look for "FOR" block
1797   0E33 C2 B3 05            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   0E36 F9                  LD      SP,HL           ; Clear nested loops
1799   0E37 D5                  PUSH    DE              ; Save index address
1800   0E38 7E                  LD      A,(HL)          ; Get sign of STEP
1801   0E39 23                  INC     HL
1802   0E3A F5                  PUSH    AF              ; Save sign of STEP
1803   0E3B D5                  PUSH    DE              ; Save index address
1804   0E3C CD 92 18            CALL    PHLTFP          ; Move index value to FPREG
1805   0E3F E3                  EX      (SP),HL         ; Save address of TO value
1806   0E40 E5                  PUSH    HL              ; Save address of index
1807   0E41 CD FF 15            CALL    ADDPHL          ; Add STEP to index value
1808   0E44 E1                  POP     HL              ; Restore address of index
1809   0E45 CD AC 18            CALL    FPTHL           ; Move value to index variable
1810   0E48 E1                  POP     HL              ; Restore address of TO value
1811   0E49 CD A3 18            CALL    LOADFP          ; Move TO value to BCDE
1812   0E4C E5                  PUSH    HL              ; Save address of line of FOR
1813   0E4D CD CF 18            CALL    CMPNUM          ; Compare index with TO value
1814   0E50 E1                  POP     HL              ; Restore address of line num
1815   0E51 C1                  POP     BC              ; Address of sign of STEP
1816   0E52 90                  SUB     B               ; Compare with expected sign
1817   0E53 CD A3 18            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   0E56 CA 62 0E            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   0E59 EB                  EX      DE,HL           ; Loop statement line number
1820   0E5A 22 A1 80            LD      (LINEAT),HL     ; Set loop line number
1821   0E5D 69                  LD      L,C             ; Set code string to loop
1822   0E5E 60                  LD      H,B
1823   0E5F C3 C1 09            JP      PUTFID          ; Put back "FOR" and continue
1824   0E62             
1825   0E62 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   0E63 2A 13 81            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   0E66 7E                  LD      A,(HL)          ; Get next byte in code string
1828   0E67 FE 2C               CP      ','             ; More NEXTs ?
1829   0E69 C2 C5 09            JP      NZ,RUNCNT       ; No - Do next statement
1830   0E6C CD 05 0A            CALL    GETCHR          ; Position to index name
1831   0E6F CD 2A 0E            CALL    NEXT1           ; Re-enter NEXT routine
1832   0E72             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   0E72             
1834   0E72 CD 84 0E    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   0E75 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   0E76 37          TSTSTR: SCF                     ; Set carry (string)
1837   0E77 3A F2 80    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   0E7A 8F                  ADC     A,A             ; Expected + actual
1839   0E7B B7                  OR      A               ; Clear carry , set parity
1840   0E7C E8                  RET     PE              ; Even parity - Types match
1841   0E7D C3 BF 05            JP      TMERR           ; Different types - Error
1842   0E80             
1843   0E80 CD 7B 08    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   0E83 28                  .BYTE   "("
1845   0E84 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   0E85 16 00               LD      D,0             ; Precedence value
1847   0E87 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   0E88 0E 01               LD      C,1
1849   0E8A CD 8A 05            CALL    CHKSTK          ; Check for 1 level of stack
1850   0E8D CD FB 0E            CALL    OPRND           ; Get next expression value
1851   0E90 22 15 81    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   0E93 2A 15 81    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   0E96 C1                  POP     BC              ; Precedence value and operator
1854   0E97 78                  LD      A,B             ; Get precedence value
1855   0E98 FE 78               CP      78H             ; "AND" or "OR" ?
1856   0E9A D4 75 0E            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   0E9D 7E                  LD      A,(HL)          ; Get next operator / function
1858   0E9E 16 00               LD      D,0             ; Clear Last relation
1859   0EA0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   0EA2 DA BC 0E            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   0EA5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   0EA7 D2 BC 0E            JP      NC,FOPRND       ; Function - Call it
1863   0EAA FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   0EAC 17                  RLA                     ; <- Test for legal
1865   0EAD AA                  XOR     D               ; <- combinations of < = >
1866   0EAE BA                  CP      D               ; <- by combining last token
1867   0EAF 57                  LD      D,A             ; <- with current one
1868   0EB0 DA AD 05            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   0EB3 22 0A 81            LD      (CUROPR),HL     ; Save address of current token
1870   0EB6 CD 05 0A            CALL    GETCHR          ; Get next character
1871   0EB9 C3 A0 0E            JP      RLTLP           ; Treat the two as one
1872   0EBC             
1873   0EBC 7A          FOPRND: LD      A,D             ; < = > found ?
1874   0EBD B7                  OR      A
1875   0EBE C2 E3 0F            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   0EC1 7E                  LD      A,(HL)          ; Get operator token
1877   0EC2 22 0A 81            LD      (CUROPR),HL     ; Save operator address
1878   0EC5 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   0EC7 D8                  RET     C               ; Neither - Exit
1880   0EC8 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   0ECA D0                  RET     NC              ; No - Exit
1882   0ECB 5F                  LD      E,A             ; Coded operator
1883   0ECC 3A F2 80            LD      A,(TYPE)        ; Get data type
1884   0ECF 3D                  DEC     A               ; FF = numeric , 00 = string
1885   0ED0 B3                  OR      E               ; Combine with coded operator
1886   0ED1 7B                  LD      A,E             ; Get coded operator
1887   0ED2 CA 41 14            JP      Z,CONCAT        ; String concatenation
1888   0ED5 07                  RLCA                    ; Times 2
1889   0ED6 83                  ADD     A,E             ; Times 3
1890   0ED7 5F                  LD      E,A             ; To DE (D is 0)
1891   0ED8 21 9F 04            LD      HL,PRITAB       ; Precedence table
1892   0EDB 19                  ADD     HL,DE           ; To the operator concerned
1893   0EDC 78                  LD      A,B             ; Last operator precedence
1894   0EDD 56                  LD      D,(HL)          ; Get evaluation precedence
1895   0EDE BA                  CP      D               ; Compare with eval precedence
1896   0EDF D0                  RET     NC              ; Exit if higher precedence
1897   0EE0 23                  INC     HL              ; Point to routine address
1898   0EE1 CD 75 0E            CALL    TSTNUM          ; Make sure it's a number
1899   0EE4             
1900   0EE4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   0EE5 01 93 0E            LD      BC,EVAL3        ; Where to go on prec' break
1902   0EE8 C5                  PUSH    BC              ; Save on stack for return
1903   0EE9 43                  LD      B,E             ; Save operator
1904   0EEA 4A                  LD      C,D             ; Save precedence
1905   0EEB CD 85 18            CALL    STAKFP          ; Move value to stack
1906   0EEE 58                  LD      E,B             ; Restore operator
1907   0EEF 51                  LD      D,C             ; Restore precedence
1908   0EF0 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   0EF1 23                  INC     HL
1910   0EF2 46                  LD      B,(HL)          ; Get MSB of routine address
1911   0EF3 23                  INC     HL
1912   0EF4 C5                  PUSH    BC              ; Save routine address
1913   0EF5 2A 0A 81            LD      HL,(CUROPR)     ; Address of current operator
1914   0EF8 C3 87 0E            JP      EVAL1           ; Loop until prec' break
1915   0EFB             
1916   0EFB AF          OPRND:  XOR     A               ; Get operand routine
1917   0EFC 32 F2 80            LD      (TYPE),A        ; Set numeric expected
1918   0EFF CD 05 0A            CALL    GETCHR          ; Get next character
1919   0F02 1E 24               LD      E,MO            ; ?MO Error
1920   0F04 CA C1 05            JP      Z,ERROR         ; No operand - Error
1921   0F07 DA 5B 19            JP      C,ASCTFP        ; Number - Get value
1922   0F0A CD A3 0A            CALL    CHKLTR          ; See if a letter
1923   0F0D D2 62 0F            JP      NC,CONVAR       ; Letter - Find variable
1924   0F10 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1925   0F12 20 12               JR		NZ, NOTAMP
1926   0F14 CD 05 0A            CALL    GETCHR          ; Get next character
1927   0F17 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   0F19 CA 9F 1D            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   0F1C FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   0F1E CA 0F 1E            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   0F21 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   0F23 CA C1 05            JP      Z,ERROR         ;
1933   0F26 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   0F28 CA FB 0E            JP      Z,OPRND         ; Yes - Look for operand
1935   0F2B FE 2E               CP      '.'             ; '.' ?
1936   0F2D CA 5B 19            JP      Z,ASCTFP        ; Yes - Create FP number
1937   0F30 FE AD               CP      ZMINUS          ; '-' Token ?
1938   0F32 CA 51 0F            JP      Z,MINUS         ; Yes - Do minus
1939   0F35 FE 22               CP      '"'             ; Literal string ?
1940   0F37 CA 0A 13            JP      Z,QTSTR         ; Get string terminated by '"'
1941   0F3A FE AA               CP      ZNOT            ; "NOT" Token ?
1942   0F3C CA 43 10            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   0F3F FE A7               CP      ZFN             ; "FN" Token ?
1944   0F41 CA 6E 12            JP      Z,DOFN          ; Yes - Do FN routine
1945   0F44 D6 B6               SUB     ZSGN            ; Is it a function?
1946   0F46 D2 73 0F            JP      NC,FNOFST       ; Yes - Evaluate function
1947   0F49 CD 80 0E    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   0F4C CD 7B 08            CALL    CHKSYN          ; Make sure ")" follows
1949   0F4F 29                  .BYTE   ")"
1950   0F50 C9                  RET
1951   0F51             
1952   0F51 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   0F53 CD 87 0E            CALL    EVAL1           ; Evaluate until prec' break
1954   0F56 2A 15 81            LD      HL,(NXTOPR)     ; Get next operator address
1955   0F59 E5                  PUSH    HL              ; Save next operator address
1956   0F5A CD 7D 18            CALL    INVSGN          ; Negate value
1957   0F5D CD 75 0E    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   0F60 E1                  POP     HL              ; Restore next operator address
1959   0F61 C9                  RET
1960   0F62             
1961   0F62 CD 68 10    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   0F65 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   0F66 EB                  EX      DE,HL           ; Variable address to HL
1964   0F67 22 29 81            LD      (FPREG),HL      ; Save address of variable
1965   0F6A 3A F2 80            LD      A,(TYPE)        ; Get type
1966   0F6D B7                  OR      A               ; Numeric?
1967   0F6E CC 92 18            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   0F71 E1                  POP     HL              ; Restore code string address
1969   0F72 C9                  RET
1970   0F73             
1971   0F73 06 00       FNOFST: LD      B,0             ; Get address of function
1972   0F75 07                  RLCA                    ; Double function offset
1973   0F76 4F                  LD      C,A             ; BC = Offset in function table
1974   0F77 C5                  PUSH    BC              ; Save adjusted token value
1975   0F78 CD 05 0A            CALL    GETCHR          ; Get next character
1976   0F7B 79                  LD      A,C             ; Get adjusted token value
1977   0F7C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   0F7E DA 9A 0F            JP      C,FNVAL         ; No - Do function
1979   0F81 CD 80 0E            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   0F84 CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
1981   0F87 2C                  .BYTE      ','
1982   0F88 CD 76 0E            CALL    TSTSTR          ; Make sure it's a string
1983   0F8B EB                  EX      DE,HL           ; Save code string address
1984   0F8C 2A 29 81            LD      HL,(FPREG)      ; Get address of string
1985   0F8F E3                  EX      (SP),HL         ; Save address of string
1986   0F90 E5                  PUSH    HL              ; Save adjusted token value
1987   0F91 EB                  EX      DE,HL           ; Restore code string address
1988   0F92 CD D3 15            CALL    GETINT          ; Get integer 0-255
1989   0F95 EB                  EX      DE,HL           ; Save code string address
1990   0F96 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   0F97 C3 A2 0F            JP      GOFUNC          ; Jump to string function
1992   0F9A             
1993   0F9A CD 49 0F    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   0F9D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   0F9E 11 5D 0F            LD      DE,RETNUM       ; Return number from function
1996   0FA1 D5                  PUSH    DE              ; Save on stack
1997   0FA2 01 FE 02    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   0FA5 09                  ADD     HL,BC           ; Point to right address
1999   0FA6 4E                  LD      C,(HL)          ; Get LSB of address
2000   0FA7 23                  INC     HL              ;
2001   0FA8 66                  LD      H,(HL)          ; Get MSB of address
2002   0FA9 69                  LD      L,C             ; Address to HL
2003   0FAA E9                  JP      (HL)            ; Jump to function
2004   0FAB             
2005   0FAB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   0FAC FE AD               CP      ZMINUS          ; '-' token ?
2007   0FAE C8                  RET     Z               ; Yes - Return
2008   0FAF FE 2D               CP      '-'             ; '-' ASCII ?
2009   0FB1 C8                  RET     Z               ; Yes - Return
2010   0FB2 14                  INC     D               ; Inc to flag positive exponent
2011   0FB3 FE 2B               CP      '+'             ; '+' ASCII ?
2012   0FB5 C8                  RET     Z               ; Yes - Return
2013   0FB6 FE AC               CP      ZPLUS           ; '+' token ?
2014   0FB8 C8                  RET     Z               ; Yes - Return
2015   0FB9 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   0FBA C9                  RET                     ; Return "NZ"
2017   0FBB             
2018   0FBB F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   0FBC AF          PAND:   XOR     A               ; Flag "AND"
2020   0FBD F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   0FBE CD 75 0E            CALL    TSTNUM          ; Make sure it's a number
2022   0FC1 CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
2023   0FC4 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   0FC5 EB                  EX      DE,HL           ; <- Get last
2025   0FC6 C1                  POP     BC              ; <-  value
2026   0FC7 E3                  EX      (SP),HL         ; <-  from
2027   0FC8 EB                  EX      DE,HL           ; <-  stack
2028   0FC9 CD 95 18            CALL    FPBCDE          ; Move last value to FPREG
2029   0FCC F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   0FCD CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
2031   0FD0 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   0FD1 C1                  POP     BC              ; Get value
2033   0FD2 79                  LD      A,C             ; Get LSB
2034   0FD3 21 2C 12            LD      HL,ACPASS       ; Address of save AC as current
2035   0FD6 C2 DE 0F            JP      NZ,POR1         ; Jump if OR
2036   0FD9 A3                  AND     E               ; "AND" LSBs
2037   0FDA 4F                  LD      C,A             ; Save LSB
2038   0FDB 78                  LD      A,B             ; Get MBS
2039   0FDC A2                  AND     D               ; "AND" MSBs
2040   0FDD E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   0FDE             
2042   0FDE B3          POR1:   OR      E               ; "OR" LSBs
2043   0FDF 4F                  LD      C,A             ; Save LSB
2044   0FE0 78                  LD      A,B             ; Get MSB
2045   0FE1 B2                  OR      D               ; "OR" MSBs
2046   0FE2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   0FE3             
2048   0FE3 21 F5 0F    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   0FE6 3A F2 80            LD      A,(TYPE)        ; Get data type
2050   0FE9 1F                  RRA                     ; Carry set = string
2051   0FEA 7A                  LD      A,D             ; Get last precedence value
2052   0FEB 17                  RLA                     ; Times 2 plus carry
2053   0FEC 5F                  LD      E,A             ; To E
2054   0FED 16 64               LD      D,64H           ; Relational precedence
2055   0FEF 78                  LD      A,B             ; Get current precedence
2056   0FF0 BA                  CP      D               ; Compare with last
2057   0FF1 D0                  RET     NC              ; Eval if last was rel' or log'
2058   0FF2 C3 E4 0E            JP      STKTHS          ; Stack this one and get next
2059   0FF5             
2060   0FF5 F7 0F       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   0FF7 79          CMPLG1: LD      A,C             ; Get data type
2062   0FF8 B7                  OR      A
2063   0FF9 1F                  RRA
2064   0FFA C1                  POP     BC              ; Get last expression to BCDE
2065   0FFB D1                  POP     DE
2066   0FFC F5                  PUSH    AF              ; Save status
2067   0FFD CD 77 0E            CALL    CHKTYP          ; Check that types match
2068   1000 21 39 10            LD      HL,CMPRES       ; Result to comparison
2069   1003 E5                  PUSH    HL              ; Save for RETurn
2070   1004 CA CF 18            JP      Z,CMPNUM        ; Compare values if numeric
2071   1007 AF                  XOR     A               ; Compare two strings
2072   1008 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2073   100B D5                  PUSH    DE              ; Save string name
2074   100C CD 8E 14            CALL    GSTRCU          ; Get current string
2075   100F 7E                  LD      A,(HL)          ; Get length of string
2076   1010 23                  INC     HL
2077   1011 23                  INC     HL
2078   1012 4E                  LD      C,(HL)          ; Get LSB of address
2079   1013 23                  INC     HL
2080   1014 46                  LD      B,(HL)          ; Get MSB of address
2081   1015 D1                  POP     DE              ; Restore string name
2082   1016 C5                  PUSH    BC              ; Save address of string
2083   1017 F5                  PUSH    AF              ; Save length of string
2084   1018 CD 92 14            CALL    GSTRDE          ; Get second string
2085   101B CD A3 18            CALL    LOADFP          ; Get address of second string
2086   101E F1                  POP     AF              ; Restore length of string 1
2087   101F 57                  LD      D,A             ; Length to D
2088   1020 E1                  POP     HL              ; Restore address of string 1
2089   1021 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   1022 B2                  OR      D               ; Bytes of string 1 to do
2091   1023 C8                  RET     Z               ; Exit if all bytes compared
2092   1024 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   1025 D6 01               SUB     1
2094   1027 D8                  RET     C               ; Exit if end of string 1
2095   1028 AF                  XOR     A
2096   1029 BB                  CP      E               ; Bytes of string 2 to do
2097   102A 3C                  INC     A
2098   102B D0                  RET     NC              ; Exit if end of string 2
2099   102C 15                  DEC     D               ; Count bytes in string 1
2100   102D 1D                  DEC     E               ; Count bytes in string 2
2101   102E 0A                  LD      A,(BC)          ; Byte in string 2
2102   102F BE                  CP      (HL)            ; Compare to byte in string 1
2103   1030 23                  INC     HL              ; Move up string 1
2104   1031 03                  INC     BC              ; Move up string 2
2105   1032 CA 21 10            JP      Z,CMPSTR        ; Same - Try next bytes
2106   1035 3F                  CCF                     ; Flag difference (">" or "<")
2107   1036 C3 5F 18            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   1039             
2109   1039 3C          CMPRES: INC     A               ; Increment current value
2110   103A 8F                  ADC     A,A             ; Double plus carry
2111   103B C1                  POP     BC              ; Get other value
2112   103C A0                  AND     B               ; Combine them
2113   103D C6 FF               ADD     A,-1            ; Carry set if different
2114   103F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   1040 C3 66 18            JP      FLGREL          ; Set current value & continue
2116   1043             
2117   1043 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   1045 CD 87 0E            CALL    EVAL1           ; Eval until precedence break
2119   1048 CD 75 0E            CALL    TSTNUM          ; Make sure it's a number
2120   104B CD B7 0A            CALL    DEINT           ; Get integer -32768 - 32767
2121   104E 7B                  LD      A,E             ; Get LSB
2122   104F 2F                  CPL                     ; Invert LSB
2123   1050 4F                  LD      C,A             ; Save "NOT" of LSB
2124   1051 7A                  LD      A,D             ; Get MSB
2125   1052 2F                  CPL                     ; Invert MSB
2126   1053 CD 2C 12            CALL    ACPASS          ; Save AC as current
2127   1056 C1                  POP     BC              ; Clean up stack
2128   1057 C3 93 0E            JP      EVAL3           ; Continue evaluation
2129   105A             
2130   105A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   105B CD 05 0A            CALL    GETCHR          ; Get next character
2132   105E C8                  RET     Z               ; End of DIM statement
2133   105F CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
2134   1062 2C                  .BYTE      ','
2135   1063 01 5A 10    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   1066 C5                  PUSH    BC              ; Save on stack
2137   1067 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   1068 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   1069 32 F1 80            LD      (LCRFLG),A      ; Set locate / create flag
2140   106C 46                  LD      B,(HL)          ; Get First byte of name
2141   106D CD A3 0A    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   1070 DA AD 05            JP      C,SNERR         ; ?SN Error if not a letter
2143   1073 AF                  XOR     A
2144   1074 4F                  LD      C,A             ; Clear second byte of name
2145   1075 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2146   1078 CD 05 0A            CALL    GETCHR          ; Get next character
2147   107B DA 84 10            JP      C,SVNAM2        ; Numeric - Save in name
2148   107E CD A3 0A            CALL    CHKLTR          ; See if a letter
2149   1081 DA 91 10            JP      C,CHARTY        ; Not a letter - Check type
2150   1084 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   1085 CD 05 0A    ENDNAM: CALL    GETCHR          ; Get next character
2152   1088 DA 85 10            JP      C,ENDNAM        ; Numeric - Get another
2153   108B CD A3 0A            CALL    CHKLTR          ; See if a letter
2154   108E D2 85 10            JP      NC,ENDNAM       ; Letter - Get another
2155   1091 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   1093 C2 A0 10            JP      NZ,NOTSTR       ; No - Numeric variable
2157   1096 3C                  INC     A               ; A = 1 (string type)
2158   1097 32 F2 80            LD      (TYPE),A        ; Set type to string
2159   109A 0F                  RRCA                    ; A = 80H , Flag for string
2160   109B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   109C 4F                  LD      C,A             ; Resave second byte on name
2162   109D CD 05 0A            CALL    GETCHR          ; Get next character
2163   10A0 3A 10 81    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   10A3 3D                  DEC     A
2165   10A4 CA 4D 11            JP      Z,ARLDSV        ; Yes - Get array name
2166   10A7 F2 B0 10            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   10AA 7E                  LD      A,(HL)          ; Get byte again
2168   10AB D6 28               SUB     '('             ; Subscripted variable?
2169   10AD CA 25 11            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   10B0             
2171   10B0 AF          NSCFOR: XOR     A               ; Simple variable
2172   10B1 32 10 81            LD      (FORFLG),A      ; Clear "FOR" flag
2173   10B4 E5                  PUSH    HL              ; Save code string address
2174   10B5 50                  LD      D,B             ; DE = Variable name to find
2175   10B6 59                  LD      E,C
2176   10B7 2A 23 81            LD      HL,(FNRGNM)     ; FN argument name
2177   10BA CD 75 08            CALL    CPDEHL          ; Is it the FN argument?
2178   10BD 11 25 81            LD      DE,FNARG        ; Point to argument value
2179   10C0 CA 95 17            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   10C3 2A 1D 81            LD      HL,(VAREND)     ; End of variables
2181   10C6 EB                  EX      DE,HL           ; Address of end of search
2182   10C7 2A 1B 81            LD      HL,(PROGND)     ; Start of variables address
2183   10CA CD 75 08    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   10CD CA E3 10            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   10D0 79                  LD      A,C             ; Get second byte of name
2186   10D1 96                  SUB     (HL)            ; Compare with name in list
2187   10D2 23                  INC     HL              ; Move on to first byte
2188   10D3 C2 D8 10            JP      NZ,FNTHR        ; Different - Find another
2189   10D6 78                  LD      A,B             ; Get first byte of name
2190   10D7 96                  SUB     (HL)            ; Compare with name in list
2191   10D8 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   10D9 CA 17 11            JP      Z,RETADR        ; Found - Return address
2193   10DC 23                  INC     HL              ; <- Skip
2194   10DD 23                  INC     HL              ; <- over
2195   10DE 23                  INC     HL              ; <- F.P.
2196   10DF 23                  INC     HL              ; <- value
2197   10E0 C3 CA 10            JP      FNDVAR          ; Keep looking
2198   10E3             
2199   10E3 E1          CFEVAL: POP     HL              ; Restore code string address
2200   10E4 E3                  EX      (SP),HL         ; Get return address
2201   10E5 D5                  PUSH    DE              ; Save address of variable
2202   10E6 11 65 0F            LD      DE,FRMEVL       ; Return address in EVAL
2203   10E9 CD 75 08            CALL    CPDEHL          ; Called from EVAL ?
2204   10EC D1                  POP     DE              ; Restore address of variable
2205   10ED CA 1A 11            JP      Z,RETNUL        ; Yes - Return null variable
2206   10F0 E3                  EX      (SP),HL         ; Put back return
2207   10F1 E5                  PUSH    HL              ; Save code string address
2208   10F2 C5                  PUSH    BC              ; Save variable name
2209   10F3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   10F6 2A 1F 81            LD      HL,(ARREND)     ; End of arrays
2211   10F9 E5                  PUSH    HL              ; Save end of arrays
2212   10FA 09                  ADD     HL,BC           ; Move up 6 bytes
2213   10FB C1                  POP     BC              ; Source address in BC
2214   10FC E5                  PUSH    HL              ; Save new end address
2215   10FD CD 79 05            CALL    MOVUP           ; Move arrays up
2216   1100 E1                  POP     HL              ; Restore new end address
2217   1101 22 1F 81            LD      (ARREND),HL     ; Set new end address
2218   1104 60                  LD      H,B             ; End of variables to HL
2219   1105 69                  LD      L,C
2220   1106 22 1D 81            LD      (VAREND),HL     ; Set new end address
2221   1109             
2222   1109 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   110A 36 00               LD      (HL),0          ; Zero byte in variable
2224   110C CD 75 08            CALL    CPDEHL          ; Done them all?
2225   110F C2 09 11            JP      NZ,ZEROLP       ; No - Keep on going
2226   1112 D1                  POP     DE              ; Get variable name
2227   1113 73                  LD      (HL),E          ; Store second character
2228   1114 23                  INC     HL
2229   1115 72                  LD      (HL),D          ; Store first character
2230   1116 23                  INC     HL
2231   1117 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   1118 E1                  POP     HL              ; Restore code string address
2233   1119 C9                  RET
2234   111A             
2235   111A 32 2C 81    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   111D 21 49 05            LD      HL,ZERBYT       ; Also set a null string
2237   1120 22 29 81            LD      (FPREG),HL      ; Save for EVAL
2238   1123 E1                  POP     HL              ; Restore code string address
2239   1124 C9                  RET
2240   1125             
2241   1125 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   1126 2A F1 80            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   1129 E3                  EX      (SP),HL         ; Save and get code string
2244   112A 57                  LD      D,A             ; Zero number of dimensions
2245   112B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   112C C5                  PUSH    BC              ; Save array name
2247   112D CD AB 0A            CALL    FPSINT          ; Get subscript (0-32767)
2248   1130 C1                  POP     BC              ; Restore array name
2249   1131 F1                  POP     AF              ; Get number of dimensions
2250   1132 EB                  EX      DE,HL
2251   1133 E3                  EX      (SP),HL         ; Save subscript value
2252   1134 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   1135 EB                  EX      DE,HL
2254   1136 3C                  INC     A               ; Count dimensions
2255   1137 57                  LD      D,A             ; Save in D
2256   1138 7E                  LD      A,(HL)          ; Get next byte in code string
2257   1139 FE 2C               CP      ','             ; Comma (more to come)?
2258   113B CA 2B 11            JP      Z,SCPTLP        ; Yes - More subscripts
2259   113E CD 7B 08            CALL    CHKSYN          ; Make sure ")" follows
2260   1141 29                  .BYTE      ")"
2261   1142 22 15 81            LD      (NXTOPR),HL     ; Save code string address
2262   1145 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   1146 22 F1 80            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   1149 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   114B D5                  PUSH    DE              ; Save number of dimensions (D)
2266   114C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   114D             
2268   114D E5          ARLDSV: PUSH    HL              ; Save code string address
2269   114E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   114F 2A 1D 81            LD      HL,(VAREND)     ; Start of arrays
2271   1152 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   1153 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   1154 EB                  EX      DE,HL
2274   1155 2A 1F 81            LD      HL,(ARREND)     ; End of arrays
2275   1158 EB                  EX      DE,HL           ; Current array pointer
2276   1159 CD 75 08            CALL    CPDEHL          ; End of arrays found?
2277   115C CA 85 11            JP      Z,CREARY        ; Yes - Create array
2278   115F 7E                  LD      A,(HL)          ; Get second byte of name
2279   1160 B9                  CP      C               ; Compare with name given
2280   1161 23                  INC     HL              ; Move on
2281   1162 C2 67 11            JP      NZ,NXTARY       ; Different - Find next array
2282   1165 7E                  LD      A,(HL)          ; Get first byte of name
2283   1166 B8                  CP      B               ; Compare with name given
2284   1167 23          NXTARY: INC     HL              ; Move on
2285   1168 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   1169 23                  INC     HL
2287   116A 56                  LD      D,(HL)          ; Get MSB of next array address
2288   116B 23                  INC     HL
2289   116C C2 53 11            JP      NZ,FNDARY       ; Not found - Keep looking
2290   116F 3A F1 80            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   1172 B7                  OR      A
2292   1173 C2 B6 05            JP      NZ,DDERR        ; Create - ?DD Error
2293   1176 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   1177 44                  LD      B,H             ; BC Points to array dim'ns
2295   1178 4D                  LD      C,L
2296   1179 CA 95 17            JP      Z,POPHRT        ; Jump if array load/save
2297   117C 96                  SUB     (HL)            ; Same number of dimensions?
2298   117D CA E3 11            JP      Z,FINDEL        ; Yes - Find element
2299   1180 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   1182 C3 C1 05            JP      ERROR           ; Output error
2301   1185             
2302   1185 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   1188 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   1189 CA CC 0A            JP      Z,FCERR         ; Yes - ?FC Error
2305   118C 71                  LD      (HL),C          ; Save second byte of name
2306   118D 23                  INC     HL
2307   118E 70                  LD      (HL),B          ; Save first byte of name
2308   118F 23                  INC     HL
2309   1190 4F                  LD      C,A             ; Number of dimensions to C
2310   1191 CD 8A 05            CALL    CHKSTK          ; Check if enough memory
2311   1194 23                  INC     HL              ; Point to number of dimensions
2312   1195 23                  INC     HL
2313   1196 22 0A 81            LD      (CUROPR),HL     ; Save address of pointer
2314   1199 71                  LD      (HL),C          ; Set number of dimensions
2315   119A 23                  INC     HL
2316   119B 3A F1 80            LD      A,(LCRFLG)      ; Locate of Create?
2317   119E 17                  RLA                     ; Carry set = Create
2318   119F 79                  LD      A,C             ; Get number of dimensions
2319   11A0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   11A3 D2 A8 11            JP      NC,DEFSIZ       ; Locate - Set default size
2321   11A6 C1                  POP     BC              ; Get specified dimension size
2322   11A7 03                  INC     BC              ; Include zero element
2323   11A8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   11A9 23                  INC     HL
2325   11AA 70                  LD      (HL),B          ; Save MSB of dimension size
2326   11AB 23                  INC     HL
2327   11AC F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   11AD E5                  PUSH    HL              ; Save address of dim'n size
2329   11AE CD 40 19            CALL    MLDEBC          ; Multiply DE by BC to find
2330   11B1 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   11B2 E1                  POP     HL              ; Restore address of dimension
2332   11B3 F1                  POP     AF              ; Restore number of dimensions
2333   11B4 3D                  DEC     A               ; Count them
2334   11B5 C2 A0 11            JP      NZ,CRARLP       ; Do next dimension if more
2335   11B8 F5                  PUSH    AF              ; Save locate/create flag
2336   11B9 42                  LD      B,D             ; MSB of memory needed
2337   11BA 4B                  LD      C,E             ; LSB of memory needed
2338   11BB EB                  EX      DE,HL
2339   11BC 19                  ADD     HL,DE           ; Add bytes to array start
2340   11BD DA A2 05            JP      C,OMERR         ; Too big - Error
2341   11C0 CD 93 05            CALL    ENFMEM          ; See if enough memory
2342   11C3 22 1F 81            LD      (ARREND),HL     ; Save new end of array
2343   11C6             
2344   11C6 2B          ZERARY: DEC     HL              ; Back through array data
2345   11C7 36 00               LD      (HL),0          ; Set array element to zero
2346   11C9 CD 75 08            CALL    CPDEHL          ; All elements zeroed?
2347   11CC C2 C6 11            JP      NZ,ZERARY       ; No - Keep on going
2348   11CF 03                  INC     BC              ; Number of bytes + 1
2349   11D0 57                  LD      D,A             ; A=0
2350   11D1 2A 0A 81            LD      HL,(CUROPR)     ; Get address of array
2351   11D4 5E                  LD      E,(HL)          ; Number of dimensions
2352   11D5 EB                  EX      DE,HL           ; To HL
2353   11D6 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   11D7 09                  ADD     HL,BC           ; Add number of bytes
2355   11D8 EB                  EX      DE,HL           ; Bytes needed to DE
2356   11D9 2B                  DEC     HL
2357   11DA 2B                  DEC     HL
2358   11DB 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   11DC 23                  INC     HL
2360   11DD 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   11DE 23                  INC     HL
2362   11DF F1                  POP     AF              ; Locate / Create?
2363   11E0 DA 07 12            JP      C,ENDDIM        ; A is 0 , End if create
2364   11E3 47          FINDEL: LD      B,A             ; Find array element
2365   11E4 4F                  LD      C,A
2366   11E5 7E                  LD      A,(HL)          ; Number of dimensions
2367   11E6 23                  INC     HL
2368   11E7 16                  .BYTE      16H             ; Skip "POP HL"
2369   11E8 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   11E9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   11EA 23                  INC     HL
2372   11EB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   11EC 23                  INC     HL
2374   11ED E3                  EX      (SP),HL         ; Save address - Get index
2375   11EE F5                  PUSH    AF              ; Save number of dim'ns
2376   11EF CD 75 08            CALL    CPDEHL          ; Dimension too large?
2377   11F2 D2 80 11            JP      NC,BSERR        ; Yes - ?BS Error
2378   11F5 E5                  PUSH    HL              ; Save index
2379   11F6 CD 40 19            CALL    MLDEBC          ; Multiply previous by size
2380   11F9 D1                  POP     DE              ; Index supplied to DE
2381   11FA 19                  ADD     HL,DE           ; Add index to pointer
2382   11FB F1                  POP     AF              ; Number of dimensions
2383   11FC 3D                  DEC     A               ; Count them
2384   11FD 44                  LD      B,H             ; MSB of pointer
2385   11FE 4D                  LD      C,L             ; LSB of pointer
2386   11FF C2 E8 11            JP      NZ,FNDELP       ; More - Keep going
2387   1202 29                  ADD     HL,HL           ; 4 Bytes per element
2388   1203 29                  ADD     HL,HL
2389   1204 C1                  POP     BC              ; Start of array
2390   1205 09                  ADD     HL,BC           ; Point to element
2391   1206 EB                  EX      DE,HL           ; Address of element to DE
2392   1207 2A 15 81    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   120A C9                  RET
2394   120B             
2395   120B 2A 1F 81    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   120E EB                  EX      DE,HL           ; To DE
2397   120F 21 00 00            LD      HL,0            ; End of free memory
2398   1212 39                  ADD     HL,SP           ; Current stack value
2399   1213 3A F2 80            LD      A,(TYPE)        ; Dummy argument type
2400   1216 B7                  OR      A
2401   1217 CA 27 12            JP      Z,FRENUM        ; Numeric - Free variable space
2402   121A CD 8E 14            CALL    GSTRCU          ; Current string to pool
2403   121D CD 8E 13            CALL    GARBGE          ; Garbage collection
2404   1220 2A 9F 80            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   1223 EB                  EX      DE,HL           ; To DE
2406   1224 2A 08 81            LD      HL,(STRBOT)     ; Bottom of string space
2407   1227 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   1228 93                  SUB     E               ; Subtract LSB of beginning
2409   1229 4F                  LD      C,A             ; Save difference if C
2410   122A 7C                  LD      A,H             ; Get MSB of end
2411   122B 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   122C 41          ACPASS: LD      B,C             ; Return integer AC
2413   122D 50          ABPASS: LD      D,B             ; Return integer AB
2414   122E 1E 00               LD      E,0
2415   1230 21 F2 80            LD      HL,TYPE         ; Point to type
2416   1233 73                  LD      (HL),E          ; Set type to numeric
2417   1234 06 90               LD      B,80H+16        ; 16 bit integer
2418   1236 C3 6B 18            JP      RETINT          ; Return the integr
2419   1239             
2420   1239 3A F0 80    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   123C 47          PASSA:  LD      B,A             ; Put A into AB
2422   123D AF                  XOR     A               ; Zero A
2423   123E C3 2D 12            JP      ABPASS          ; Return integer AB
2424   1241             
2425   1241 CD C4 12    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   1244 CD B6 12            CALL    IDTEST          ; Test for illegal direct
2427   1247 01 9C 0B            LD      BC,DATA         ; To get next statement
2428   124A C5                  PUSH    BC              ; Save address for RETurn
2429   124B D5                  PUSH    DE              ; Save address of function ptr
2430   124C CD 7B 08            CALL    CHKSYN          ; Make sure "(" follows
2431   124F 28                  .BYTE      "("
2432   1250 CD 68 10            CALL    GETVAR          ; Get argument variable name
2433   1253 E5                  PUSH    HL              ; Save code string address
2434   1254 EB                  EX      DE,HL           ; Argument address to HL
2435   1255 2B                  DEC     HL
2436   1256 56                  LD      D,(HL)          ; Get first byte of arg name
2437   1257 2B                  DEC     HL
2438   1258 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   1259 E1                  POP     HL              ; Restore code string address
2440   125A CD 75 0E            CALL    TSTNUM          ; Make sure numeric argument
2441   125D CD 7B 08            CALL    CHKSYN          ; Make sure ")" follows
2442   1260 29                  .BYTE      ")"
2443   1261 CD 7B 08            CALL    CHKSYN          ; Make sure "=" follows
2444   1264 B4                  .BYTE      ZEQUAL          ; "=" token
2445   1265 44                  LD      B,H             ; Code string address to BC
2446   1266 4D                  LD      C,L
2447   1267 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   1268 71                  LD      (HL),C          ; Save LSB of FN code string
2449   1269 23                  INC     HL
2450   126A 70                  LD      (HL),B          ; Save MSB of FN code string
2451   126B C3 03 13            JP      SVSTAD          ; Save address and do function
2452   126E             
2453   126E CD C4 12    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   1271 D5                  PUSH    DE              ; Save function pointer address
2455   1272 CD 49 0F            CALL    EVLPAR          ; Evaluate expression in "()"
2456   1275 CD 75 0E            CALL    TSTNUM          ; Make sure numeric result
2457   1278 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   1279 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   127A 23                  INC     HL
2460   127B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   127C 23                  INC     HL
2462   127D 7A                  LD      A,D             ; And function DEFined?
2463   127E B3                  OR      E
2464   127F CA B9 05            JP      Z,UFERR         ; No - ?UF Error
2465   1282 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   1283 23                  INC     HL
2467   1284 66                  LD      H,(HL)          ; Get MSB of argument address
2468   1285 6F                  LD      L,A             ; HL = Arg variable address
2469   1286 E5                  PUSH    HL              ; Save it
2470   1287 2A 23 81            LD      HL,(FNRGNM)     ; Get old argument name
2471   128A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   128B 22 23 81            LD      (FNRGNM),HL     ; Set new argument name
2473   128E 2A 27 81            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   1291 E5                  PUSH    HL              ; Save it
2475   1292 2A 25 81            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   1295 E5                  PUSH    HL              ; Save it
2477   1296 21 25 81            LD      HL,FNARG        ; HL = Value of argument
2478   1299 D5                  PUSH    DE              ; Save FN code string address
2479   129A CD AC 18            CALL    FPTHL           ; Move FPREG to argument
2480   129D E1                  POP     HL              ; Get FN code string address
2481   129E CD 72 0E            CALL    GETNUM          ; Get value from function
2482   12A1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   12A2 CD 05 0A            CALL    GETCHR          ; Get next character
2484   12A5 C2 AD 05            JP      NZ,SNERR        ; Bad character in FN - Error
2485   12A8 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   12A9 22 25 81            LD      (FNARG),HL      ; Restore it
2487   12AC E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   12AD 22 27 81            LD      (FNARG+2),HL    ; Restore it
2489   12B0 E1                  POP     HL              ; Get name of old arg
2490   12B1 22 23 81            LD      (FNRGNM),HL     ; Restore it
2491   12B4 E1                  POP     HL              ; Restore code string address
2492   12B5 C9                  RET
2493   12B6             
2494   12B6 E5          IDTEST: PUSH    HL              ; Save code string address
2495   12B7 2A A1 80            LD      HL,(LINEAT)     ; Get current line number
2496   12BA 23                  INC     HL              ; -1 means direct statement
2497   12BB 7C                  LD      A,H
2498   12BC B5                  OR      L
2499   12BD E1                  POP     HL              ; Restore code string address
2500   12BE C0                  RET     NZ              ; Return if in program
2501   12BF 1E 16               LD      E,ID            ; ?ID Error
2502   12C1 C3 C1 05            JP      ERROR
2503   12C4             
2504   12C4 CD 7B 08    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   12C7 A7                  .BYTE      ZFN             ; "FN" token
2506   12C8 3E 80               LD      A,80H
2507   12CA 32 10 81            LD      (FORFLG),A      ; Flag FN name to find
2508   12CD B6                  OR      (HL)            ; FN name has bit 7 set
2509   12CE 47                  LD      B,A             ; in first byte of name
2510   12CF CD 6D 10            CALL    GTFNAM          ; Get FN name
2511   12D2 C3 75 0E            JP      TSTNUM          ; Make sure numeric function
2512   12D5             
2513   12D5 CD 75 0E    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   12D8 CD F9 19            CALL    NUMASC          ; Turn number into text
2515   12DB CD 09 13    STR1:   CALL    CRTST           ; Create string entry for it
2516   12DE CD 8E 14            CALL    GSTRCU          ; Current string to pool
2517   12E1 01 E9 14            LD      BC,TOPOOL       ; Save in string pool
2518   12E4 C5                  PUSH    BC              ; Save address on stack
2519   12E5             
2520   12E5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   12E6 23                  INC     HL
2522   12E7 23                  INC     HL
2523   12E8 E5                  PUSH    HL              ; Save pointer to string
2524   12E9 CD 64 13            CALL    TESTR           ; See if enough string space
2525   12EC E1                  POP     HL              ; Restore pointer to string
2526   12ED 4E                  LD      C,(HL)          ; Get LSB of address
2527   12EE 23                  INC     HL
2528   12EF 46                  LD      B,(HL)          ; Get MSB of address
2529   12F0 CD FD 12            CALL    CRTMST          ; Create string entry
2530   12F3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   12F4 6F                  LD      L,A             ; Length of string
2532   12F5 CD 81 14            CALL    TOSTRA          ; Move to string area
2533   12F8 D1                  POP     DE              ; Restore pointer to MSB
2534   12F9 C9                  RET
2535   12FA             
2536   12FA CD 64 13    MKTMST: CALL    TESTR           ; See if enough string space
2537   12FD 21 04 81    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   1300 E5                  PUSH    HL              ; Save it
2539   1301 77                  LD      (HL),A          ; Save length of string
2540   1302 23                  INC     HL
2541   1303 23          SVSTAD: INC     HL
2542   1304 73                  LD      (HL),E          ; Save LSB of address
2543   1305 23                  INC     HL
2544   1306 72                  LD      (HL),D          ; Save MSB of address
2545   1307 E1                  POP     HL              ; Restore pointer
2546   1308 C9                  RET
2547   1309             
2548   1309 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   130A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   130C 50                  LD      D,B             ; Quote to D
2551   130D E5          DTSTR:  PUSH    HL              ; Save start
2552   130E 0E FF               LD      C,-1            ; Set counter to -1
2553   1310 23          QTSTLP: INC     HL              ; Move on
2554   1311 7E                  LD      A,(HL)          ; Get byte
2555   1312 0C                  INC     C               ; Count bytes
2556   1313 B7                  OR      A               ; End of line?
2557   1314 CA 1F 13            JP      Z,CRTSTE        ; Yes - Create string entry
2558   1317 BA                  CP      D               ; Terminator D found?
2559   1318 CA 1F 13            JP      Z,CRTSTE        ; Yes - Create string entry
2560   131B B8                  CP      B               ; Terminator B found?
2561   131C C2 10 13            JP      NZ,QTSTLP       ; No - Keep looking
2562   131F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   1321 CC 05 0A            CALL    Z,GETCHR        ; Yes - Get next character
2564   1324 E3                  EX      (SP),HL         ; Starting quote
2565   1325 23                  INC     HL              ; First byte of string
2566   1326 EB                  EX      DE,HL           ; To DE
2567   1327 79                  LD      A,C             ; Get length
2568   1328 CD FD 12            CALL    CRTMST          ; Create string entry
2569   132B 11 04 81    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   132E 2A F6 80            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   1331 22 29 81            LD      (FPREG),HL      ; Save address of string ptr
2572   1334 3E 01               LD      A,1
2573   1336 32 F2 80            LD      (TYPE),A        ; Set type to string
2574   1339 CD AF 18            CALL    DETHL4          ; Move string to pool
2575   133C CD 75 08            CALL    CPDEHL          ; Out of string pool?
2576   133F 22 F6 80            LD      (TMSTPT),HL     ; Save new pointer
2577   1342 E1                  POP     HL              ; Restore code string address
2578   1343 7E                  LD      A,(HL)          ; Get next code byte
2579   1344 C0                  RET     NZ              ; Return if pool OK
2580   1345 1E 1E               LD      E,ST            ; ?ST Error
2581   1347 C3 C1 05            JP      ERROR           ; String pool overflow
2582   134A             
2583   134A 23          PRNUMS: INC     HL              ; Skip leading space
2584   134B CD 09 13    PRS:    CALL    CRTST           ; Create string entry for it
2585   134E CD 8E 14    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   1351 CD A3 18            CALL    LOADFP          ; Move string block to BCDE
2587   1354 1C                  INC     E               ; Length + 1
2588   1355 1D          PRSLP:  DEC     E               ; Count characters
2589   1356 C8                  RET     Z               ; End of string
2590   1357 0A                  LD      A,(BC)          ; Get byte to output
2591   1358 CD 86 08            CALL    OUTC            ; Output character in A
2592   135B FE 0D               CP      CR              ; Return?
2593   135D CC B7 0C            CALL    Z,DONULL        ; Yes - Do nulls
2594   1360 03                  INC     BC              ; Next byte in string
2595   1361 C3 55 13            JP      PRSLP           ; More characters to output
2596   1364             
2597   1364 B7          TESTR:  OR      A               ; Test if enough room
2598   1365 0E                  .BYTE      0EH             ; No garbage collection done
2599   1366 F1          GRBDON: POP     AF              ; Garbage collection done
2600   1367 F5                  PUSH    AF              ; Save status
2601   1368 2A 9F 80            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   136B EB                  EX      DE,HL           ; To DE
2603   136C 2A 08 81            LD      HL,(STRBOT)     ; Bottom of string area
2604   136F 2F                  CPL                     ; Negate length (Top down)
2605   1370 4F                  LD      C,A             ; -Length to BC
2606   1371 06 FF               LD      B,-1            ; BC = -ve length of string
2607   1373 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   1374 23                  INC     HL              ; Plus one for 2's complement
2609   1375 CD 75 08            CALL    CPDEHL          ; Below string RAM area?
2610   1378 DA 82 13            JP      C,TESTOS        ; Tidy up if not done else err
2611   137B 22 08 81            LD      (STRBOT),HL     ; Save new bottom of area
2612   137E 23                  INC     HL              ; Point to first byte of string
2613   137F EB                  EX      DE,HL           ; Address to DE
2614   1380 F1          POPAF:  POP     AF              ; Throw away status push
2615   1381 C9                  RET
2616   1382             
2617   1382 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   1383 1E 1A               LD      E,OS            ; ?OS Error
2619   1385 CA C1 05            JP      Z,ERROR         ; Yes - Not enough string apace
2620   1388 BF                  CP      A               ; Flag garbage collect done
2621   1389 F5                  PUSH    AF              ; Save status
2622   138A 01 66 13            LD      BC,GRBDON       ; Garbage collection done
2623   138D C5                  PUSH    BC              ; Save for RETurn
2624   138E 2A F4 80    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   1391 22 08 81    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   1394 21 00 00            LD      HL,0
2627   1397 E5                  PUSH    HL              ; Flag no string found
2628   1398 2A 9F 80            LD      HL,(STRSPC)     ; Get bottom of string space
2629   139B E5                  PUSH    HL              ; Save bottom of string space
2630   139C 21 F8 80            LD      HL,TMSTPL       ; Temporary string pool
2631   139F EB          GRBLP:  EX      DE,HL
2632   13A0 2A F6 80            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   13A3 EB                  EX      DE,HL
2634   13A4 CD 75 08            CALL    CPDEHL          ; Temporary string pool done?
2635   13A7 01 9F 13            LD      BC,GRBLP        ; Loop until string pool done
2636   13AA C2 F3 13            JP      NZ,STPOOL       ; No - See if in string area
2637   13AD 2A 1B 81            LD      HL,(PROGND)     ; Start of simple variables
2638   13B0 EB          SMPVAR: EX      DE,HL
2639   13B1 2A 1D 81            LD      HL,(VAREND)     ; End of simple variables
2640   13B4 EB                  EX      DE,HL
2641   13B5 CD 75 08            CALL    CPDEHL          ; All simple strings done?
2642   13B8 CA C6 13            JP      Z,ARRLP         ; Yes - Do string arrays
2643   13BB 7E                  LD      A,(HL)          ; Get type of variable
2644   13BC 23                  INC     HL
2645   13BD 23                  INC     HL
2646   13BE B7                  OR      A               ; "S" flag set if string
2647   13BF CD F6 13            CALL    STRADD          ; See if string in string area
2648   13C2 C3 B0 13            JP      SMPVAR          ; Loop until simple ones done
2649   13C5             
2650   13C5 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   13C6 EB          ARRLP:  EX      DE,HL
2652   13C7 2A 1F 81            LD      HL,(ARREND)     ; End of string arrays
2653   13CA EB                  EX      DE,HL
2654   13CB CD 75 08            CALL    CPDEHL          ; All string arrays done?
2655   13CE CA 1C 14            JP      Z,SCNEND        ; Yes - Move string if found
2656   13D1 CD A3 18            CALL    LOADFP          ; Get array name to BCDE
2657   13D4 7B                  LD      A,E             ; Get type of array
2658   13D5 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   13D6 09                  ADD     HL,BC           ; Start of next array
2660   13D7 B7                  OR      A               ; Test type of array
2661   13D8 F2 C5 13            JP      P,GNXARY        ; Numeric array - Ignore it
2662   13DB 22 0A 81            LD      (CUROPR),HL     ; Save address of next array
2663   13DE E1                  POP     HL              ; Get address of num of dim'ns
2664   13DF 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   13E0 06 00               LD      B,0
2666   13E2 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   13E3 09                  ADD     HL,BC
2668   13E4 23                  INC     HL              ; Plus one for number of dim'ns
2669   13E5 EB          GRBARY: EX      DE,HL
2670   13E6 2A 0A 81            LD      HL,(CUROPR)     ; Get address of next array
2671   13E9 EB                  EX      DE,HL
2672   13EA CD 75 08            CALL    CPDEHL          ; Is this array finished?
2673   13ED CA C6 13            JP      Z,ARRLP         ; Yes - Get next one
2674   13F0 01 E5 13            LD      BC,GRBARY       ; Loop until array all done
2675   13F3 C5          STPOOL: PUSH    BC              ; Save return address
2676   13F4 F6 80               OR      80H             ; Flag string type
2677   13F6 7E          STRADD: LD      A,(HL)          ; Get string length
2678   13F7 23                  INC     HL
2679   13F8 23                  INC     HL
2680   13F9 5E                  LD      E,(HL)          ; Get LSB of string address
2681   13FA 23                  INC     HL
2682   13FB 56                  LD      D,(HL)          ; Get MSB of string address
2683   13FC 23                  INC     HL
2684   13FD F0                  RET     P               ; Not a string - Return
2685   13FE B7                  OR      A               ; Set flags on string length
2686   13FF C8                  RET     Z               ; Null string - Return
2687   1400 44                  LD      B,H             ; Save variable pointer
2688   1401 4D                  LD      C,L
2689   1402 2A 08 81            LD      HL,(STRBOT)     ; Bottom of new area
2690   1405 CD 75 08            CALL    CPDEHL          ; String been done?
2691   1408 60                  LD      H,B             ; Restore variable pointer
2692   1409 69                  LD      L,C
2693   140A D8                  RET     C               ; String done - Ignore
2694   140B E1                  POP     HL              ; Return address
2695   140C E3                  EX      (SP),HL         ; Lowest available string area
2696   140D CD 75 08            CALL    CPDEHL          ; String within string area?
2697   1410 E3                  EX      (SP),HL         ; Lowest available string area
2698   1411 E5                  PUSH    HL              ; Re-save return address
2699   1412 60                  LD      H,B             ; Restore variable pointer
2700   1413 69                  LD      L,C
2701   1414 D0                  RET     NC              ; Outside string area - Ignore
2702   1415 C1                  POP     BC              ; Get return , Throw 2 away
2703   1416 F1                  POP     AF              ;
2704   1417 F1                  POP     AF              ;
2705   1418 E5                  PUSH    HL              ; Save variable pointer
2706   1419 D5                  PUSH    DE              ; Save address of current
2707   141A C5                  PUSH    BC              ; Put back return address
2708   141B C9                  RET                     ; Go to it
2709   141C             
2710   141C D1          SCNEND: POP     DE              ; Addresses of strings
2711   141D E1                  POP     HL              ;
2712   141E 7D                  LD      A,L             ; HL = 0 if no more to do
2713   141F B4                  OR      H
2714   1420 C8                  RET     Z               ; No more to do - Return
2715   1421 2B                  DEC     HL
2716   1422 46                  LD      B,(HL)          ; MSB of address of string
2717   1423 2B                  DEC     HL
2718   1424 4E                  LD      C,(HL)          ; LSB of address of string
2719   1425 E5                  PUSH    HL              ; Save variable address
2720   1426 2B                  DEC     HL
2721   1427 2B                  DEC     HL
2722   1428 6E                  LD      L,(HL)          ; HL = Length of string
2723   1429 26 00               LD      H,0
2724   142B 09                  ADD     HL,BC           ; Address of end of string+1
2725   142C 50                  LD      D,B             ; String address to DE
2726   142D 59                  LD      E,C
2727   142E 2B                  DEC     HL              ; Last byte in string
2728   142F 44                  LD      B,H             ; Address to BC
2729   1430 4D                  LD      C,L
2730   1431 2A 08 81            LD      HL,(STRBOT)     ; Current bottom of string area
2731   1434 CD 7C 05            CALL    MOVSTR          ; Move string to new address
2732   1437 E1                  POP     HL              ; Restore variable address
2733   1438 71                  LD      (HL),C          ; Save new LSB of address
2734   1439 23                  INC     HL
2735   143A 70                  LD      (HL),B          ; Save new MSB of address
2736   143B 69                  LD      L,C             ; Next string area+1 to HL
2737   143C 60                  LD      H,B
2738   143D 2B                  DEC     HL              ; Next string area address
2739   143E C3 91 13            JP      GARBLP          ; Look for more strings
2740   1441             
2741   1441 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   1442 E5                  PUSH    HL              ;
2743   1443 2A 29 81            LD      HL,(FPREG)      ; Get first string
2744   1446 E3                  EX      (SP),HL         ; Save first string
2745   1447 CD FB 0E            CALL    OPRND           ; Get second string
2746   144A E3                  EX      (SP),HL         ; Restore first string
2747   144B CD 76 0E            CALL    TSTSTR          ; Make sure it's a string
2748   144E 7E                  LD      A,(HL)          ; Get length of second string
2749   144F E5                  PUSH    HL              ; Save first string
2750   1450 2A 29 81            LD      HL,(FPREG)      ; Get second string
2751   1453 E5                  PUSH    HL              ; Save second string
2752   1454 86                  ADD     A,(HL)          ; Add length of second string
2753   1455 1E 1C               LD      E,LS            ; ?LS Error
2754   1457 DA C1 05            JP      C,ERROR         ; String too long - Error
2755   145A CD FA 12            CALL    MKTMST          ; Make temporary string
2756   145D D1                  POP     DE              ; Get second string to DE
2757   145E CD 92 14            CALL    GSTRDE          ; Move to string pool if needed
2758   1461 E3                  EX      (SP),HL         ; Get first string
2759   1462 CD 91 14            CALL    GSTRHL          ; Move to string pool if needed
2760   1465 E5                  PUSH    HL              ; Save first string
2761   1466 2A 06 81            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   1469 EB                  EX      DE,HL           ; To DE
2763   146A CD 78 14            CALL    SSTSA           ; First string to string area
2764   146D CD 78 14            CALL    SSTSA           ; Second string to string area
2765   1470 21 90 0E            LD      HL,EVAL2        ; Return to evaluation loop
2766   1473 E3                  EX      (SP),HL         ; Save return,get code string
2767   1474 E5                  PUSH    HL              ; Save code string address
2768   1475 C3 2B 13            JP      TSTOPL          ; To temporary string to pool
2769   1478             
2770   1478 E1          SSTSA:  POP     HL              ; Return address
2771   1479 E3                  EX      (SP),HL         ; Get string block,save return
2772   147A 7E                  LD      A,(HL)          ; Get length of string
2773   147B 23                  INC     HL
2774   147C 23                  INC     HL
2775   147D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   147E 23                  INC     HL
2777   147F 46                  LD      B,(HL)          ; Get MSB of string address
2778   1480 6F                  LD      L,A             ; Length to L
2779   1481 2C          TOSTRA: INC     L               ; INC - DECed after
2780   1482 2D          TSALP:  DEC     L               ; Count bytes moved
2781   1483 C8                  RET     Z               ; End of string - Return
2782   1484 0A                  LD      A,(BC)          ; Get source
2783   1485 12                  LD      (DE),A          ; Save destination
2784   1486 03                  INC     BC              ; Next source
2785   1487 13                  INC     DE              ; Next destination
2786   1488 C3 82 14            JP      TSALP           ; Loop until string moved
2787   148B             
2788   148B CD 76 0E    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   148E 2A 29 81    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   1491 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   1492 CD AC 14    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   1495 EB                  EX      DE,HL           ; Restore DE
2793   1496 C0                  RET     NZ              ; No - Return
2794   1497 D5                  PUSH    DE              ; Save string
2795   1498 50                  LD      D,B             ; String block address to DE
2796   1499 59                  LD      E,C
2797   149A 1B                  DEC     DE              ; Point to length
2798   149B 4E                  LD      C,(HL)          ; Get string length
2799   149C 2A 08 81            LD      HL,(STRBOT)     ; Current bottom of string area
2800   149F CD 75 08            CALL    CPDEHL          ; Last one in string area?
2801   14A2 C2 AA 14            JP      NZ,POPHL        ; No - Return
2802   14A5 47                  LD      B,A             ; Clear B (A=0)
2803   14A6 09                  ADD     HL,BC           ; Remove string from str' area
2804   14A7 22 08 81            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   14AA E1          POPHL:  POP     HL              ; Restore string
2806   14AB C9                  RET
2807   14AC             
2808   14AC 2A F6 80    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   14AF 2B                  DEC     HL              ; Back
2810   14B0 46                  LD      B,(HL)          ; Get MSB of address
2811   14B1 2B                  DEC     HL              ; Back
2812   14B2 4E                  LD      C,(HL)          ; Get LSB of address
2813   14B3 2B                  DEC     HL              ; Back
2814   14B4 2B                  DEC     HL              ; Back
2815   14B5 CD 75 08            CALL    CPDEHL          ; String last in string pool?
2816   14B8 C0                  RET     NZ              ; Yes - Leave it
2817   14B9 22 F6 80            LD      (TMSTPT),HL     ; Save new string pool top
2818   14BC C9                  RET
2819   14BD             
2820   14BD 01 3C 12    LEN:    LD      BC,PASSA        ; To return integer A
2821   14C0 C5                  PUSH    BC              ; Save address
2822   14C1 CD 8B 14    GETLEN: CALL    GETSTR          ; Get string and its length
2823   14C4 AF                  XOR     A
2824   14C5 57                  LD      D,A             ; Clear D
2825   14C6 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2826   14C9 7E                  LD      A,(HL)          ; Get length of string
2827   14CA B7                  OR      A               ; Set status flags
2828   14CB C9                  RET
2829   14CC             
2830   14CC 01 3C 12    ASC:    LD      BC,PASSA        ; To return integer A
2831   14CF C5                  PUSH    BC              ; Save address
2832   14D0 CD C1 14    GTFLNM: CALL    GETLEN          ; Get length of string
2833   14D3 CA CC 0A            JP      Z,FCERR         ; Null string - Error
2834   14D6 23                  INC     HL
2835   14D7 23                  INC     HL
2836   14D8 5E                  LD      E,(HL)          ; Get LSB of address
2837   14D9 23                  INC     HL
2838   14DA 56                  LD      D,(HL)          ; Get MSB of address
2839   14DB 1A                  LD      A,(DE)          ; Get first byte of string
2840   14DC C9                  RET
2841   14DD             
2842   14DD 3E 01       CHR:    LD      A,1             ; One character string
2843   14DF CD FA 12            CALL    MKTMST          ; Make a temporary string
2844   14E2 CD D6 15            CALL    MAKINT          ; Make it integer A
2845   14E5 2A 06 81            LD      HL,(TMPSTR+2)   ; Get address of string
2846   14E8 73                  LD      (HL),E          ; Save character
2847   14E9 C1          TOPOOL: POP     BC              ; Clean up stack
2848   14EA C3 2B 13            JP      TSTOPL          ; Temporary string to pool
2849   14ED             
2850   14ED CD 86 15    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   14F0 AF                  XOR     A               ; Start at first byte in string
2852   14F1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   14F2 4F                  LD      C,A             ; Starting position in string
2854   14F3 E5          MID1:   PUSH    HL              ; Save string block address
2855   14F4 7E                  LD      A,(HL)          ; Get length of string
2856   14F5 B8                  CP      B               ; Compare with number given
2857   14F6 DA FB 14            JP      C,ALLFOL        ; All following bytes required
2858   14F9 78                  LD      A,B             ; Get new length
2859   14FA 11                  .BYTE      11H             ; Skip "LD C,0"
2860   14FB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   14FD C5                  PUSH    BC              ; Save position in string
2862   14FE CD 64 13            CALL    TESTR           ; See if enough string space
2863   1501 C1                  POP     BC              ; Get position in string
2864   1502 E1                  POP     HL              ; Restore string block address
2865   1503 E5                  PUSH    HL              ; And re-save it
2866   1504 23                  INC     HL
2867   1505 23                  INC     HL
2868   1506 46                  LD      B,(HL)          ; Get LSB of address
2869   1507 23                  INC     HL
2870   1508 66                  LD      H,(HL)          ; Get MSB of address
2871   1509 68                  LD      L,B             ; HL = address of string
2872   150A 06 00               LD      B,0             ; BC = starting address
2873   150C 09                  ADD     HL,BC           ; Point to that byte
2874   150D 44                  LD      B,H             ; BC = source string
2875   150E 4D                  LD      C,L
2876   150F CD FD 12            CALL    CRTMST          ; Create a string entry
2877   1512 6F                  LD      L,A             ; Length of new string
2878   1513 CD 81 14            CALL    TOSTRA          ; Move string to string area
2879   1516 D1                  POP     DE              ; Clear stack
2880   1517 CD 92 14            CALL    GSTRDE          ; Move to string pool if needed
2881   151A C3 2B 13            JP      TSTOPL          ; Temporary string to pool
2882   151D             
2883   151D CD 86 15    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   1520 D1                  POP     DE              ; Get string length
2885   1521 D5                  PUSH    DE              ; And re-save
2886   1522 1A                  LD      A,(DE)          ; Get length
2887   1523 90                  SUB     B               ; Move back N bytes
2888   1524 C3 F1 14            JP      RIGHT1          ; Go and get sub-string
2889   1527             
2890   1527 EB          MID:    EX      DE,HL           ; Get code string address
2891   1528 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   1529 CD 8B 15            CALL    MIDNUM          ; Get number supplied
2893   152C 04                  INC     B               ; Is it character zero?
2894   152D 05                  DEC     B
2895   152E CA CC 0A            JP      Z,FCERR         ; Yes - Error
2896   1531 C5                  PUSH    BC              ; Save starting position
2897   1532 1E FF               LD      E,255           ; All of string
2898   1534 FE 29               CP      ')'             ; Any length given?
2899   1536 CA 40 15            JP      Z,RSTSTR        ; No - Rest of string
2900   1539 CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
2901   153C 2C                  .BYTE      ','
2902   153D CD D3 15            CALL    GETINT          ; Get integer 0-255
2903   1540 CD 7B 08    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   1543 29                  .BYTE      ")"
2905   1544 F1                  POP     AF              ; Restore starting position
2906   1545 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   1546 01 F3 14            LD      BC,MID1         ; Continuation of MID$ routine
2908   1549 C5                  PUSH    BC              ; Save for return
2909   154A 3D                  DEC     A               ; Starting position-1
2910   154B BE                  CP      (HL)            ; Compare with length
2911   154C 06 00               LD      B,0             ; Zero bytes length
2912   154E D0                  RET     NC              ; Null string if start past end
2913   154F 4F                  LD      C,A             ; Save starting position-1
2914   1550 7E                  LD      A,(HL)          ; Get length of string
2915   1551 91                  SUB     C               ; Subtract start
2916   1552 BB                  CP      E               ; Enough string for it?
2917   1553 47                  LD      B,A             ; Save maximum length available
2918   1554 D8                  RET     C               ; Truncate string if needed
2919   1555 43                  LD      B,E             ; Set specified length
2920   1556 C9                  RET                     ; Go and create string
2921   1557             
2922   1557 CD C1 14    VAL:    CALL    GETLEN          ; Get length of string
2923   155A CA 74 16            JP      Z,RESZER        ; Result zero
2924   155D 5F                  LD      E,A             ; Save length
2925   155E 23                  INC     HL
2926   155F 23                  INC     HL
2927   1560 7E                  LD      A,(HL)          ; Get LSB of address
2928   1561 23                  INC     HL
2929   1562 66                  LD      H,(HL)          ; Get MSB of address
2930   1563 6F                  LD      L,A             ; HL = String address
2931   1564 E5                  PUSH    HL              ; Save string address
2932   1565 19                  ADD     HL,DE
2933   1566 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   1567 72                  LD      (HL),D          ; Zero it to terminate
2935   1568 E3                  EX      (SP),HL         ; Save string end,get start
2936   1569 C5                  PUSH    BC              ; Save end+1 byte
2937   156A 7E                  LD      A,(HL)          ; Get starting byte
2938   156B FE 24           CP	'$'		; Hex number indicated? [function added]
2939   156D C2 75 15        JP	NZ,VAL1
2940   1570 CD 9F 1D        CALL	HEXTFP		; Convert Hex to FPREG
2941   1573 18 0D           JR	VAL3
2942   1575 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   1577 C2 7F 15        JP	NZ,VAL2
2944   157A CD 0F 1E        CALL	BINTFP		; Convert Bin to FPREG
2945   157D 18 03           JR	VAL3
2946   157F CD 5B 19    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   1582 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   1583 E1                  POP     HL              ; Restore end+1 address
2949   1584 70                  LD      (HL),B          ; Put back original byte
2950   1585 C9                  RET
2951   1586             
2952   1586 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   1587 CD 7B 08            CALL    CHKSYN          ; Make sure ")" follows
2954   158A 29                  .BYTE      ")"
2955   158B C1          MIDNUM: POP     BC              ; Get return address
2956   158C D1                  POP     DE              ; Get number supplied
2957   158D C5                  PUSH    BC              ; Re-save return address
2958   158E 43                  LD      B,E             ; Number to B
2959   158F C9                  RET
2960   1590             
2961   1590 CD D6 15    INP:    CALL    MAKINT          ; Make it integer A
2962   1593 32 84 80            LD      (INPORT),A      ; Set input port
2963   1596 CD 83 80            CALL    INPSUB          ; Get input from port
2964   1599 C3 3C 12            JP      PASSA           ; Return integer A
2965   159C             
2966   159C CD C0 15    POUT:   CALL    SETIO           ; Set up port number
2967   159F C3 4B 80            JP      OUTSUB          ; Output data and return
2968   15A2             
2969   15A2 CD C0 15    WAIT:   CALL    SETIO           ; Set up port number
2970   15A5 F5                  PUSH    AF              ; Save AND mask
2971   15A6 1E 00               LD      E,0             ; Assume zero if none given
2972   15A8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   15A9 CD 05 0A            CALL    GETCHR          ; Get next character
2974   15AC CA B6 15            JP      Z,NOXOR         ; No XOR byte given
2975   15AF CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
2976   15B2 2C                  .BYTE      ','
2977   15B3 CD D3 15            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   15B6 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   15B7 CD 83 80    WAITLP: CALL    INPSUB          ; Get input
2980   15BA AB                  XOR     E               ; Flip selected bits
2981   15BB A0                  AND     B               ; Result non-zero?
2982   15BC CA B7 15            JP      Z,WAITLP        ; No = keep waiting
2983   15BF C9                  RET
2984   15C0             
2985   15C0 CD D3 15    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   15C3 32 84 80            LD      (INPORT),A      ; Set input port
2987   15C6 32 4C 80            LD      (OTPORT),A      ; Set output port
2988   15C9 CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
2989   15CC 2C                  .BYTE      ','
2990   15CD C3 D3 15            JP      GETINT          ; Get integer 0-255 and return
2991   15D0             
2992   15D0 CD 05 0A    FNDNUM: CALL    GETCHR          ; Get next character
2993   15D3 CD 72 0E    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   15D6 CD B1 0A    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   15D9 7A                  LD      A,D             ; Get MSB of number
2996   15DA B7                  OR      A               ; Zero?
2997   15DB C2 CC 0A            JP      NZ,FCERR        ; No - Error
2998   15DE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   15DF CD 05 0A            CALL    GETCHR          ; Get next character
3000   15E2 7B                  LD      A,E             ; Get number to A
3001   15E3 C9                  RET
3002   15E4             
3003   15E4 CD B7 0A    PEEK:   CALL    DEINT           ; Get memory address
3004   15E7 1A                  LD      A,(DE)          ; Get byte in memory
3005   15E8 C3 3C 12            JP      PASSA           ; Return integer A
3006   15EB             
3007   15EB CD 72 0E    POKE:   CALL    GETNUM          ; Get memory address
3008   15EE CD B7 0A            CALL    DEINT           ; Get integer -32768 to 3276
3009   15F1 D5                  PUSH    DE              ; Save memory address
3010   15F2 CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
3011   15F5 2C                  .BYTE      ','
3012   15F6 CD D3 15            CALL    GETINT          ; Get integer 0-255
3013   15F9 D1                  POP     DE              ; Restore memory address
3014   15FA 12                  LD      (DE),A          ; Load it into memory
3015   15FB C9                  RET
3016   15FC             
3017   15FC 21 D2 1A    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   15FF CD A3 18    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   1602 C3 0E 16            JP      FPADD           ; Add BCDE to FPREG
3020   1605             
3021   1605 CD A3 18    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   1608 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   1609 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   160A D1                  POP     DE
3025   160B CD 7D 18    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   160E 78          FPADD:  LD      A,B             ; Get FP exponent
3027   160F B7                  OR      A               ; Is number zero?
3028   1610 C8                  RET     Z               ; Yes - Nothing to add
3029   1611 3A 2C 81            LD      A,(FPEXP)       ; Get FPREG exponent
3030   1614 B7                  OR      A               ; Is this number zero?
3031   1615 CA 95 18            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   1618 90                  SUB     B               ; BCDE number larger?
3033   1619 D2 28 16            JP      NC,NOSWAP       ; No - Don't swap them
3034   161C 2F                  CPL                     ; Two's complement
3035   161D 3C                  INC     A               ;  FP exponent
3036   161E EB                  EX      DE,HL
3037   161F CD 85 18            CALL    STAKFP          ; Put FPREG on stack
3038   1622 EB                  EX      DE,HL
3039   1623 CD 95 18            CALL    FPBCDE          ; Move BCDE to FPREG
3040   1626 C1                  POP     BC              ; Restore number from stack
3041   1627 D1                  POP     DE
3042   1628 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   162A D0                  RET     NC              ; Yes - First number is result
3044   162B F5                  PUSH    AF              ; Save number of bits to scale
3045   162C CD BA 18            CALL    SIGNS           ; Set MSBs & sign of result
3046   162F 67                  LD      H,A             ; Save sign of result
3047   1630 F1                  POP     AF              ; Restore scaling factor
3048   1631 CD D3 16            CALL    SCALE           ; Scale BCDE to same exponent
3049   1634 B4                  OR      H               ; Result to be positive?
3050   1635 21 29 81            LD      HL,FPREG        ; Point to FPREG
3051   1638 F2 4E 16            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   163B CD B3 16            CALL    PLUCDE          ; Add FPREG to CDE
3053   163E D2 94 16            JP      NC,RONDUP       ; No overflow - Round it up
3054   1641 23                  INC     HL              ; Point to exponent
3055   1642 34                  INC     (HL)            ; Increment it
3056   1643 CA BC 05            JP      Z,OVERR         ; Number overflowed - Error
3057   1646 2E 01               LD      L,1             ; 1 bit to shift right
3058   1648 CD E9 16            CALL    SHRT1           ; Shift result right
3059   164B C3 94 16            JP      RONDUP          ; Round it up
3060   164E             
3061   164E AF          MINCDE: XOR     A               ; Clear A and carry
3062   164F 90                  SUB     B               ; Negate exponent
3063   1650 47                  LD      B,A             ; Re-save exponent
3064   1651 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   1652 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   1653 5F                  LD      E,A             ; Save LSB of BCDE
3067   1654 23                  INC     HL
3068   1655 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   1656 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   1657 57                  LD      D,A             ; Save NMSB of BCDE
3071   1658 23                  INC     HL
3072   1659 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   165A 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   165B 4F                  LD      C,A             ; Save MSB of BCDE
3075   165C DC BF 16    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   165F             
3077   165F 68          BNORM:  LD      L,B             ; L = Exponent
3078   1660 63                  LD      H,E             ; H = LSB
3079   1661 AF                  XOR     A
3080   1662 47          BNRMLP: LD      B,A             ; Save bit count
3081   1663 79                  LD      A,C             ; Get MSB
3082   1664 B7                  OR      A               ; Is it zero?
3083   1665 C2 81 16            JP      NZ,PNORM        ; No - Do it bit at a time
3084   1668 4A                  LD      C,D             ; MSB = NMSB
3085   1669 54                  LD      D,H             ; NMSB= LSB
3086   166A 65                  LD      H,L             ; LSB = VLSB
3087   166B 6F                  LD      L,A             ; VLSB= 0
3088   166C 78                  LD      A,B             ; Get exponent
3089   166D D6 08               SUB     8               ; Count 8 bits
3090   166F FE E0               CP      -24-8           ; Was number zero?
3091   1671 C2 62 16            JP      NZ,BNRMLP       ; No - Keep normalising
3092   1674 AF          RESZER: XOR     A               ; Result is zero
3093   1675 32 2C 81    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   1678 C9                  RET
3095   1679             
3096   1679 05          NORMAL: DEC     B               ; Count bits
3097   167A 29                  ADD     HL,HL           ; Shift HL left
3098   167B 7A                  LD      A,D             ; Get NMSB
3099   167C 17                  RLA                     ; Shift left with last bit
3100   167D 57                  LD      D,A             ; Save NMSB
3101   167E 79                  LD      A,C             ; Get MSB
3102   167F 8F                  ADC     A,A             ; Shift left with last bit
3103   1680 4F                  LD      C,A             ; Save MSB
3104   1681 F2 79 16    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   1684 78                  LD      A,B             ; Number of bits shifted
3106   1685 5C                  LD      E,H             ; Save HL in EB
3107   1686 45                  LD      B,L
3108   1687 B7                  OR      A               ; Any shifting done?
3109   1688 CA 94 16            JP      Z,RONDUP        ; No - Round it up
3110   168B 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3111   168E 86                  ADD     A,(HL)          ; Add shifted bits
3112   168F 77                  LD      (HL),A          ; Re-save exponent
3113   1690 D2 74 16            JP      NC,RESZER       ; Underflow - Result is zero
3114   1693 C8                  RET     Z               ; Result is zero
3115   1694 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   1695 21 2C 81    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   1698 B7                  OR      A               ; Any rounding?
3118   1699 FC A6 16            CALL    M,FPROND        ; Yes - Round number up
3119   169C 46                  LD      B,(HL)          ; B = Exponent
3120   169D 23                  INC     HL
3121   169E 7E                  LD      A,(HL)          ; Get sign of result
3122   169F E6 80               AND     10000000B       ; Only bit 7 needed
3123   16A1 A9                  XOR     C               ; Set correct sign
3124   16A2 4F                  LD      C,A             ; Save correct sign in number
3125   16A3 C3 95 18            JP      FPBCDE          ; Move BCDE to FPREG
3126   16A6             
3127   16A6 1C          FPROND: INC     E               ; Round LSB
3128   16A7 C0                  RET     NZ              ; Return if ok
3129   16A8 14                  INC     D               ; Round NMSB
3130   16A9 C0                  RET     NZ              ; Return if ok
3131   16AA 0C                  INC     C               ; Round MSB
3132   16AB C0                  RET     NZ              ; Return if ok
3133   16AC 0E 80               LD      C,80H           ; Set normal value
3134   16AE 34                  INC     (HL)            ; Increment exponent
3135   16AF C0                  RET     NZ              ; Return if ok
3136   16B0 C3 BC 05            JP      OVERR           ; Overflow error
3137   16B3             
3138   16B3 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   16B4 83                  ADD     A,E             ; Add LSB of BCDE
3140   16B5 5F                  LD      E,A             ; Save LSB of BCDE
3141   16B6 23                  INC     HL
3142   16B7 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   16B8 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   16B9 57                  LD      D,A             ; Save NMSB of BCDE
3145   16BA 23                  INC     HL
3146   16BB 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   16BC 89                  ADC     A,C             ; Add MSB of BCDE
3148   16BD 4F                  LD      C,A             ; Save MSB of BCDE
3149   16BE C9                  RET
3150   16BF             
3151   16BF 21 2D 81    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   16C2 7E                  LD      A,(HL)          ; Get sign of result
3153   16C3 2F                  CPL                     ; Negate it
3154   16C4 77                  LD      (HL),A          ; Put it back
3155   16C5 AF                  XOR     A
3156   16C6 6F                  LD      L,A             ; Set L to zero
3157   16C7 90                  SUB     B               ; Negate exponent,set carry
3158   16C8 47                  LD      B,A             ; Re-save exponent
3159   16C9 7D                  LD      A,L             ; Load zero
3160   16CA 9B                  SBC     A,E             ; Negate LSB
3161   16CB 5F                  LD      E,A             ; Re-save LSB
3162   16CC 7D                  LD      A,L             ; Load zero
3163   16CD 9A                  SBC     A,D             ; Negate NMSB
3164   16CE 57                  LD      D,A             ; Re-save NMSB
3165   16CF 7D                  LD      A,L             ; Load zero
3166   16D0 99                  SBC     A,C             ; Negate MSB
3167   16D1 4F                  LD      C,A             ; Re-save MSB
3168   16D2 C9                  RET
3169   16D3             
3170   16D3 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   16D5 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   16D7 DA E2 16            JP      C,SHRITE        ; No - Shift right A bits
3173   16DA 43                  LD      B,E             ; <- Shift
3174   16DB 5A                  LD      E,D             ; <- right
3175   16DC 51                  LD      D,C             ; <- eight
3176   16DD 0E 00               LD      C,0             ; <- bits
3177   16DF C3 D5 16            JP      SCALLP          ; More bits to shift
3178   16E2             
3179   16E2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   16E4 6F                  LD      L,A             ; Save bits to shift
3181   16E5 AF          SHRLP:  XOR     A               ; Flag for all done
3182   16E6 2D                  DEC     L               ; All shifting done?
3183   16E7 C8                  RET     Z               ; Yes - Return
3184   16E8 79                  LD      A,C             ; Get MSB
3185   16E9 1F          SHRT1:  RRA                     ; Shift it right
3186   16EA 4F                  LD      C,A             ; Re-save
3187   16EB 7A                  LD      A,D             ; Get NMSB
3188   16EC 1F                  RRA                     ; Shift right with last bit
3189   16ED 57                  LD      D,A             ; Re-save it
3190   16EE 7B                  LD      A,E             ; Get LSB
3191   16EF 1F                  RRA                     ; Shift right with last bit
3192   16F0 5F                  LD      E,A             ; Re-save it
3193   16F1 78                  LD      A,B             ; Get underflow
3194   16F2 1F                  RRA                     ; Shift right with last bit
3195   16F3 47                  LD      B,A             ; Re-save underflow
3196   16F4 C3 E5 16            JP      SHRLP           ; More bits to do
3197   16F7             
3198   16F7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   16FB             
3200   16FB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   16FC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   1700 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   1704 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   1708             
3205   1708 CD 54 18    LOG:    CALL    TSTSGN          ; Test sign of value
3206   170B B7                  OR      A
3207   170C EA CC 0A            JP      PE,FCERR        ; ?FC Error if <= zero
3208   170F 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3209   1712 7E                  LD      A,(HL)          ; Get exponent
3210   1713 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   1716 11 F3 04            LD      DE,04F3H
3212   1719 90                  SUB     B               ; Scale value to be < 1
3213   171A F5                  PUSH    AF              ; Save scale factor
3214   171B 70                  LD      (HL),B          ; Save new exponent
3215   171C D5                  PUSH    DE              ; Save SQR(1/2)
3216   171D C5                  PUSH    BC
3217   171E CD 0E 16            CALL    FPADD           ; Add SQR(1/2) to value
3218   1721 C1                  POP     BC              ; Restore SQR(1/2)
3219   1722 D1                  POP     DE
3220   1723 04                  INC     B               ; Make it SQR(2)
3221   1724 CD AA 17            CALL    DVBCDE          ; Divide by SQR(2)
3222   1727 21 F7 16            LD      HL,UNITY        ; Point to 1.
3223   172A CD 05 16            CALL    SUBPHL          ; Subtract FPREG from 1
3224   172D 21 FB 16            LD      HL,LOGTAB       ; Coefficient table
3225   1730 CD 9C 1B            CALL    SUMSER          ; Evaluate sum of series
3226   1733 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   1736 11 00 00            LD      DE,0000H
3228   1739 CD 0E 16            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   173C F1                  POP     AF              ; Restore scale factor
3230   173D CD CF 19            CALL    RSCALE          ; Re-scale number
3231   1740 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   1743 11 18 72            LD      DE,7218H
3233   1746 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   1747             
3235   1747 C1          MULT:   POP     BC              ; Get number from stack
3236   1748 D1                  POP     DE
3237   1749 CD 54 18    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   174C C8                  RET     Z               ; Return zero if zero
3239   174D 2E 00               LD      L,0             ; Flag add exponents
3240   174F CD 12 18            CALL    ADDEXP          ; Add exponents
3241   1752 79                  LD      A,C             ; Get MSB of multiplier
3242   1753 32 3B 81            LD      (MULVAL),A      ; Save MSB of multiplier
3243   1756 EB                  EX      DE,HL
3244   1757 22 3C 81            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   175A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   175D 50                  LD      D,B
3247   175E 58                  LD      E,B
3248   175F 21 5F 16            LD      HL,BNORM        ; Address of normalise
3249   1762 E5                  PUSH    HL              ; Save for return
3250   1763 21 6B 17            LD      HL,MULT8        ; Address of 8 bit multiply
3251   1766 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   1767 E5                  PUSH    HL              ;
3253   1768 21 29 81            LD      HL,FPREG        ; Point to number
3254   176B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   176C 23                  INC     HL              ; Point to NMSB
3256   176D B7                  OR      A               ; Test LSB
3257   176E CA 97 17            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   1771 E5                  PUSH    HL              ; Save address of number
3259   1772 2E 08               LD      L,8             ; 8 bits to multiply by
3260   1774 1F          MUL8LP: RRA                     ; Shift LSB right
3261   1775 67                  LD      H,A             ; Save LSB
3262   1776 79                  LD      A,C             ; Get MSB
3263   1777 D2 85 17            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   177A E5                  PUSH    HL              ; Save LSB and count
3265   177B 2A 3C 81            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   177E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   177F EB                  EX      DE,HL           ; Leave sum in DE
3268   1780 E1                  POP     HL              ; Restore MSB and count
3269   1781 3A 3B 81            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   1784 89                  ADC     A,C             ; Add MSB
3271   1785 1F          NOMADD: RRA                     ; Shift MSB right
3272   1786 4F                  LD      C,A             ; Re-save MSB
3273   1787 7A                  LD      A,D             ; Get NMSB
3274   1788 1F                  RRA                     ; Shift NMSB right
3275   1789 57                  LD      D,A             ; Re-save NMSB
3276   178A 7B                  LD      A,E             ; Get LSB
3277   178B 1F                  RRA                     ; Shift LSB right
3278   178C 5F                  LD      E,A             ; Re-save LSB
3279   178D 78                  LD      A,B             ; Get VLSB
3280   178E 1F                  RRA                     ; Shift VLSB right
3281   178F 47                  LD      B,A             ; Re-save VLSB
3282   1790 2D                  DEC     L               ; Count bits multiplied
3283   1791 7C                  LD      A,H             ; Get LSB of multiplier
3284   1792 C2 74 17            JP      NZ,MUL8LP       ; More - Do it
3285   1795 E1          POPHRT: POP     HL              ; Restore address of number
3286   1796 C9                  RET
3287   1797             
3288   1797 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   1798 5A                  LD      E,D
3290   1799 51                  LD      D,C
3291   179A 4F                  LD      C,A
3292   179B C9                  RET
3293   179C             
3294   179C CD 85 18    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   179F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   17A2 11 00 00            LD      DE,0000H
3297   17A5 CD 95 18            CALL    FPBCDE          ; Move 10 to FPREG
3298   17A8             
3299   17A8 C1          DIV:    POP     BC              ; Get number from stack
3300   17A9 D1                  POP     DE
3301   17AA CD 54 18    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   17AD CA B0 05            JP      Z,DZERR         ; Error if division by zero
3303   17B0 2E FF               LD      L,-1            ; Flag subtract exponents
3304   17B2 CD 12 18            CALL    ADDEXP          ; Subtract exponents
3305   17B5 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   17B6 34                  INC     (HL)
3307   17B7 2B                  DEC     HL              ; Point to MSB
3308   17B8 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   17B9 32 57 80            LD      (DIV3),A        ; Save for subtraction
3310   17BC 2B                  DEC     HL
3311   17BD 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   17BE 32 53 80            LD      (DIV2),A        ; Save for subtraction
3313   17C1 2B                  DEC     HL
3314   17C2 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   17C3 32 4F 80            LD      (DIV1),A        ; Save for subtraction
3316   17C6 41                  LD      B,C             ; Get MSB
3317   17C7 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   17C8 AF                  XOR     A
3319   17C9 4F                  LD      C,A             ; Clear MSB of quotient
3320   17CA 57                  LD      D,A             ; Clear NMSB of quotient
3321   17CB 5F                  LD      E,A             ; Clear LSB of quotient
3322   17CC 32 5A 80            LD      (DIV4),A        ; Clear overflow count
3323   17CF E5          DIVLP:  PUSH    HL              ; Save divisor
3324   17D0 C5                  PUSH    BC
3325   17D1 7D                  LD      A,L             ; Get LSB of number
3326   17D2 CD 4E 80            CALL    DIVSUP          ; Subt' divisor from dividend
3327   17D5 DE 00               SBC     A,0             ; Count for overflows
3328   17D7 3F                  CCF
3329   17D8 D2 E2 17            JP      NC,RESDIV       ; Restore divisor if borrow
3330   17DB 32 5A 80            LD      (DIV4),A        ; Re-save overflow count
3331   17DE F1                  POP     AF              ; Scrap divisor
3332   17DF F1                  POP     AF
3333   17E0 37                  SCF                     ; Set carry to
3334   17E1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   17E2             
3336   17E2 C1          RESDIV: POP     BC              ; Restore divisor
3337   17E3 E1                  POP     HL
3338   17E4 79                  LD      A,C             ; Get MSB of quotient
3339   17E5 3C                  INC     A
3340   17E6 3D                  DEC     A
3341   17E7 1F                  RRA                     ; Bit 0 to bit 7
3342   17E8 FA 95 16            JP      M,RONDB         ; Done - Normalise result
3343   17EB 17                  RLA                     ; Restore carry
3344   17EC 7B                  LD      A,E             ; Get LSB of quotient
3345   17ED 17                  RLA                     ; Double it
3346   17EE 5F                  LD      E,A             ; Put it back
3347   17EF 7A                  LD      A,D             ; Get NMSB of quotient
3348   17F0 17                  RLA                     ; Double it
3349   17F1 57                  LD      D,A             ; Put it back
3350   17F2 79                  LD      A,C             ; Get MSB of quotient
3351   17F3 17                  RLA                     ; Double it
3352   17F4 4F                  LD      C,A             ; Put it back
3353   17F5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   17F6 78                  LD      A,B             ; Get MSB of divisor
3355   17F7 17                  RLA                     ; Double it
3356   17F8 47                  LD      B,A             ; Put it back
3357   17F9 3A 5A 80            LD      A,(DIV4)        ; Get VLSB of quotient
3358   17FC 17                  RLA                     ; Double it
3359   17FD 32 5A 80            LD      (DIV4),A        ; Put it back
3360   1800 79                  LD      A,C             ; Get MSB of quotient
3361   1801 B2                  OR      D               ; Merge NMSB
3362   1802 B3                  OR      E               ; Merge LSB
3363   1803 C2 CF 17            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   1806 E5                  PUSH    HL              ; Save divisor
3365   1807 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3366   180A 35                  DEC     (HL)            ; Divide by 2
3367   180B E1                  POP     HL              ; Restore divisor
3368   180C C2 CF 17            JP      NZ,DIVLP        ; Ok - Keep going
3369   180F C3 BC 05            JP      OVERR           ; Overflow error
3370   1812             
3371   1812 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   1813 B7                  OR      A               ; Test it
3373   1814 CA 36 18            JP      Z,OVTST3        ; Zero - Result zero
3374   1817 7D                  LD      A,L             ; Get add/subtract flag
3375   1818 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3376   181B AE                  XOR     (HL)            ; Add or subtract it
3377   181C 80                  ADD     A,B             ; Add the other exponent
3378   181D 47                  LD      B,A             ; Save new exponent
3379   181E 1F                  RRA                     ; Test exponent for overflow
3380   181F A8                  XOR     B
3381   1820 78                  LD      A,B             ; Get exponent
3382   1821 F2 35 18            JP      P,OVTST2        ; Positive - Test for overflow
3383   1824 C6 80               ADD     A,80H           ; Add excess 128
3384   1826 77                  LD      (HL),A          ; Save new exponent
3385   1827 CA 95 17            JP      Z,POPHRT        ; Zero - Result zero
3386   182A CD BA 18            CALL    SIGNS           ; Set MSBs and sign of result
3387   182D 77                  LD      (HL),A          ; Save new exponent
3388   182E 2B                  DEC     HL              ; Point to MSB
3389   182F C9                  RET
3390   1830             
3391   1830 CD 54 18    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   1833 2F                  CPL                     ; Invert sign
3393   1834 E1                  POP     HL              ; Clean up stack
3394   1835 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   1836 E1          OVTST3: POP     HL              ; Clear off return address
3396   1837 F2 74 16            JP      P,RESZER        ; Result zero
3397   183A C3 BC 05            JP      OVERR           ; Overflow error
3398   183D             
3399   183D CD A0 18    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   1840 78                  LD      A,B             ; Get exponent
3401   1841 B7                  OR      A               ; Is it zero?
3402   1842 C8                  RET     Z               ; Yes - Result is zero
3403   1843 C6 02               ADD     A,2             ; Multiply by 4
3404   1845 DA BC 05            JP      C,OVERR         ; Overflow - ?OV Error
3405   1848 47                  LD      B,A             ; Re-save exponent
3406   1849 CD 0E 16            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   184C 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3408   184F 34                  INC     (HL)            ; Double number (Times 10)
3409   1850 C0                  RET     NZ              ; Ok - Return
3410   1851 C3 BC 05            JP      OVERR           ; Overflow error
3411   1854             
3412   1854 3A 2C 81    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   1857 B7                  OR      A
3414   1858 C8                  RET     Z               ; RETurn if number is zero
3415   1859 3A 2B 81            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   185C FE                  .BYTE      0FEH            ; Test sign
3417   185D 2F          RETREL: CPL                     ; Invert sign
3418   185E 17                  RLA                     ; Sign bit to carry
3419   185F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   1860 C0                  RET     NZ              ; Return -1 if negative
3421   1861 3C                  INC     A               ; Bump to +1
3422   1862 C9                  RET                     ; Positive - Return +1
3423   1863             
3424   1863 CD 54 18    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   1866 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   1868 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   186B 21 2C 81    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   186E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   186F 70                  LD      (HL),B          ; Save exponent
3430   1870 06 00               LD      B,0             ; CDE = integer to normalise
3431   1872 23                  INC     HL              ; Point to sign of result
3432   1873 36 80               LD      (HL),80H        ; Set sign of result
3433   1875 17                  RLA                     ; Carry = sign of integer
3434   1876 C3 5C 16            JP      CONPOS          ; Set sign of result
3435   1879             
3436   1879 CD 54 18    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   187C F0                  RET     P               ; Return if positive
3438   187D 21 2B 81    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   1880 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   1881 EE 80               XOR     80H             ; Invert sign of mantissa
3441   1883 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   1884 C9                  RET
3443   1885             
3444   1885 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   1886 2A 29 81            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   1889 E3                  EX      (SP),HL         ; Stack them,get return
3447   188A E5                  PUSH    HL              ; Re-save return
3448   188B 2A 2B 81            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   188E E3                  EX      (SP),HL         ; Stack them,get return
3450   188F E5                  PUSH    HL              ; Re-save return
3451   1890 EB                  EX      DE,HL           ; Restore code string address
3452   1891 C9                  RET
3453   1892             
3454   1892 CD A3 18    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   1895 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   1896 22 29 81            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   1899 60                  LD      H,B             ; Exponent of number
3458   189A 69                  LD      L,C             ; MSB of number
3459   189B 22 2B 81            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   189E EB                  EX      DE,HL           ; Restore code string address
3461   189F C9                  RET
3462   18A0             
3463   18A0 21 29 81    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   18A3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   18A4 23                  INC     HL
3466   18A5 56                  LD      D,(HL)          ; Get NMSB of number
3467   18A6 23                  INC     HL
3468   18A7 4E                  LD      C,(HL)          ; Get MSB of number
3469   18A8 23                  INC     HL
3470   18A9 46                  LD      B,(HL)          ; Get exponent of number
3471   18AA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   18AB C9                  RET
3473   18AC             
3474   18AC 11 29 81    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   18AF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   18B1 1A          DETHLB: LD      A,(DE)          ; Get source
3477   18B2 77                  LD      (HL),A          ; Save destination
3478   18B3 13                  INC     DE              ; Next source
3479   18B4 23                  INC     HL              ; Next destination
3480   18B5 05                  DEC     B               ; Count bytes
3481   18B6 C2 B1 18            JP      NZ,DETHLB       ; Loop if more
3482   18B9 C9                  RET
3483   18BA             
3484   18BA 21 2B 81    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   18BD 7E                  LD      A,(HL)          ; Get MSB
3486   18BE 07                  RLCA                    ; Old sign to carry
3487   18BF 37                  SCF                     ; Set MSBit
3488   18C0 1F                  RRA                     ; Set MSBit of MSB
3489   18C1 77                  LD      (HL),A          ; Save new MSB
3490   18C2 3F                  CCF                     ; Complement sign
3491   18C3 1F                  RRA                     ; Old sign to carry
3492   18C4 23                  INC     HL
3493   18C5 23                  INC     HL
3494   18C6 77                  LD      (HL),A          ; Set sign of result
3495   18C7 79                  LD      A,C             ; Get MSB
3496   18C8 07                  RLCA                    ; Old sign to carry
3497   18C9 37                  SCF                     ; Set MSBit
3498   18CA 1F                  RRA                     ; Set MSBit of MSB
3499   18CB 4F                  LD      C,A             ; Save MSB
3500   18CC 1F                  RRA
3501   18CD AE                  XOR     (HL)            ; New sign of result
3502   18CE C9                  RET
3503   18CF             
3504   18CF 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   18D0 B7                  OR      A
3506   18D1 CA 54 18            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   18D4 21 5D 18            LD      HL,RETREL       ; Return relation routine
3508   18D7 E5                  PUSH    HL              ; Save for return
3509   18D8 CD 54 18            CALL    TSTSGN          ; Test sign of FPREG
3510   18DB 79                  LD      A,C             ; Get MSB of number
3511   18DC C8                  RET     Z               ; FPREG zero - Number's MSB
3512   18DD 21 2B 81            LD      HL,FPREG+2      ; MSB of FPREG
3513   18E0 AE                  XOR     (HL)            ; Combine signs
3514   18E1 79                  LD      A,C             ; Get MSB of number
3515   18E2 F8                  RET     M               ; Exit if signs different
3516   18E3 CD E9 18            CALL    CMPFP           ; Compare FP numbers
3517   18E6 1F                  RRA                     ; Get carry to sign
3518   18E7 A9                  XOR     C               ; Combine with MSB of number
3519   18E8 C9                  RET
3520   18E9             
3521   18E9 23          CMPFP:  INC     HL              ; Point to exponent
3522   18EA 78                  LD      A,B             ; Get exponent
3523   18EB BE                  CP      (HL)            ; Compare exponents
3524   18EC C0                  RET     NZ              ; Different
3525   18ED 2B                  DEC     HL              ; Point to MBS
3526   18EE 79                  LD      A,C             ; Get MSB
3527   18EF BE                  CP      (HL)            ; Compare MSBs
3528   18F0 C0                  RET     NZ              ; Different
3529   18F1 2B                  DEC     HL              ; Point to NMSB
3530   18F2 7A                  LD      A,D             ; Get NMSB
3531   18F3 BE                  CP      (HL)            ; Compare NMSBs
3532   18F4 C0                  RET     NZ              ; Different
3533   18F5 2B                  DEC     HL              ; Point to LSB
3534   18F6 7B                  LD      A,E             ; Get LSB
3535   18F7 96                  SUB     (HL)            ; Compare LSBs
3536   18F8 C0                  RET     NZ              ; Different
3537   18F9 E1                  POP     HL              ; Drop RETurn
3538   18FA E1                  POP     HL              ; Drop another RETurn
3539   18FB C9                  RET
3540   18FC             
3541   18FC 47          FPINT:  LD      B,A             ; <- Move
3542   18FD 4F                  LD      C,A             ; <- exponent
3543   18FE 57                  LD      D,A             ; <- to all
3544   18FF 5F                  LD      E,A             ; <- bits
3545   1900 B7                  OR      A               ; Test exponent
3546   1901 C8                  RET     Z               ; Zero - Return zero
3547   1902 E5                  PUSH    HL              ; Save pointer to number
3548   1903 CD A0 18            CALL    BCDEFP          ; Move FPREG to BCDE
3549   1906 CD BA 18            CALL    SIGNS           ; Set MSBs & sign of result
3550   1909 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   190A 67                  LD      H,A             ; Save combined signs
3552   190B FC 20 19            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   190E 3E 98               LD      A,80H+24        ; 24 bits
3554   1910 90                  SUB     B               ; Bits to shift
3555   1911 CD D3 16            CALL    SCALE           ; Shift BCDE
3556   1914 7C                  LD      A,H             ; Get combined sign
3557   1915 17                  RLA                     ; Sign to carry
3558   1916 DC A6 16            CALL    C,FPROND        ; Negative - Round number up
3559   1919 06 00               LD      B,0             ; Zero exponent
3560   191B DC BF 16            CALL    C,COMPL         ; If negative make positive
3561   191E E1                  POP     HL              ; Restore pointer to number
3562   191F C9                  RET
3563   1920             
3564   1920 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   1921 7A                  LD      A,D             ; Test LSBs
3566   1922 A3                  AND     E
3567   1923 3C                  INC     A
3568   1924 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   1925 0B                  DEC     BC              ; Decrement MSBs
3570   1926 C9                  RET
3571   1927             
3572   1927 21 2C 81    INT:    LD      HL,FPEXP        ; Point to exponent
3573   192A 7E                  LD      A,(HL)          ; Get exponent
3574   192B FE 98               CP      80H+24          ; Integer accuracy only?
3575   192D 3A 29 81            LD      A,(FPREG)       ; Get LSB
3576   1930 D0                  RET     NC              ; Yes - Already integer
3577   1931 7E                  LD      A,(HL)          ; Get exponent
3578   1932 CD FC 18            CALL    FPINT           ; F.P to integer
3579   1935 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   1937 7B                  LD      A,E             ; Get LSB of number
3581   1938 F5                  PUSH    AF              ; Save LSB
3582   1939 79                  LD      A,C             ; Get MSB of number
3583   193A 17                  RLA                     ; Sign to carry
3584   193B CD 5C 16            CALL    CONPOS          ; Set sign of result
3585   193E F1                  POP     AF              ; Restore LSB of number
3586   193F C9                  RET
3587   1940             
3588   1940 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   1943 78                  LD      A,B             ; Test multiplier
3590   1944 B1                  OR      C
3591   1945 C8                  RET     Z               ; Return zero if zero
3592   1946 3E 10               LD      A,16            ; 16 bits
3593   1948 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   1949 DA 80 11            JP      C,BSERR         ; ?BS Error if overflow
3595   194C EB                  EX      DE,HL
3596   194D 29                  ADD     HL,HL           ; Shift multiplier left
3597   194E EB                  EX      DE,HL
3598   194F D2 56 19            JP      NC,NOMLAD       ; Bit was zero - No add
3599   1952 09                  ADD     HL,BC           ; Add multiplicand
3600   1953 DA 80 11            JP      C,BSERR         ; ?BS Error if overflow
3601   1956 3D          NOMLAD: DEC     A               ; Count bits
3602   1957 C2 48 19            JP      NZ,MLDBLP       ; More
3603   195A C9                  RET
3604   195B             
3605   195B FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   195D F5                  PUSH    AF              ; Save it and flags
3607   195E CA 67 19            JP      Z,CNVNUM        ; Yes - Convert number
3608   1961 FE 2B               CP      '+'             ; Positive?
3609   1963 CA 67 19            JP      Z,CNVNUM        ; Yes - Convert number
3610   1966 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   1967 CD 74 16    CNVNUM: CALL    RESZER          ; Set result to zero
3612   196A 47                  LD      B,A             ; Digits after point counter
3613   196B 57                  LD      D,A             ; Sign of exponent
3614   196C 5F                  LD      E,A             ; Exponent of ten
3615   196D 2F                  CPL
3616   196E 4F                  LD      C,A             ; Before or after point flag
3617   196F CD 05 0A    MANLP:  CALL    GETCHR          ; Get next character
3618   1972 DA B8 19            JP      C,ADDIG         ; Digit - Add to number
3619   1975 FE 2E               CP      '.'
3620   1977 CA 93 19            JP      Z,DPOINT        ; '.' - Flag point
3621   197A FE 45               CP      'E'
3622   197C C2 97 19            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   197F CD 05 0A            CALL    GETCHR          ; Get next character
3624   1982 CD AB 0F            CALL    SGNEXP          ; Get sign of exponent
3625   1985 CD 05 0A    EXPLP:  CALL    GETCHR          ; Get next character
3626   1988 DA DA 19            JP      C,EDIGIT        ; Digit - Add to exponent
3627   198B 14                  INC     D               ; Is sign negative?
3628   198C C2 97 19            JP      NZ,CONEXP       ; No - Scale number
3629   198F AF                  XOR     A
3630   1990 93                  SUB     E               ; Negate exponent
3631   1991 5F                  LD      E,A             ; And re-save it
3632   1992 0C                  INC     C               ; Flag end of number
3633   1993 0C          DPOINT: INC     C               ; Flag point passed
3634   1994 CA 6F 19            JP      Z,MANLP         ; Zero - Get another digit
3635   1997 E5          CONEXP: PUSH    HL              ; Save code string address
3636   1998 7B                  LD      A,E             ; Get exponent
3637   1999 90                  SUB     B               ; Subtract digits after point
3638   199A F4 B0 19    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   199D F2 A6 19            JP      P,ENDCON        ; Positive - All done
3640   19A0 F5                  PUSH    AF              ; Save number of times to /10
3641   19A1 CD 9C 17            CALL    DIV10           ; Divide by 10
3642   19A4 F1                  POP     AF              ; Restore count
3643   19A5 3C                  INC     A               ; Count divides
3644   19A6             
3645   19A6 C2 9A 19    ENDCON: JP      NZ,SCALMI       ; More to do
3646   19A9 D1                  POP     DE              ; Restore code string address
3647   19AA F1                  POP     AF              ; Restore sign of number
3648   19AB CC 7D 18            CALL    Z,INVSGN        ; Negative - Negate number
3649   19AE EB                  EX      DE,HL           ; Code string address to HL
3650   19AF C9                  RET
3651   19B0             
3652   19B0 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   19B1 F5          MULTEN: PUSH    AF              ; Save count
3654   19B2 CD 3D 18            CALL    MLSP10          ; Multiply number by 10
3655   19B5 F1                  POP     AF              ; Restore count
3656   19B6 3D                  DEC     A               ; Count multiplies
3657   19B7 C9                  RET
3658   19B8             
3659   19B8 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   19B9 57                  LD      D,A             ; Save digit
3661   19BA 78                  LD      A,B             ; Get digits after point
3662   19BB 89                  ADC     A,C             ; Add one if after point
3663   19BC 47                  LD      B,A             ; Re-save counter
3664   19BD C5                  PUSH    BC              ; Save point flags
3665   19BE E5                  PUSH    HL              ; Save code string address
3666   19BF D5                  PUSH    DE              ; Save digit
3667   19C0 CD 3D 18            CALL    MLSP10          ; Multiply number by 10
3668   19C3 F1                  POP     AF              ; Restore digit
3669   19C4 D6 30               SUB     '0'             ; Make it absolute
3670   19C6 CD CF 19            CALL    RSCALE          ; Re-scale number
3671   19C9 E1                  POP     HL              ; Restore code string address
3672   19CA C1                  POP     BC              ; Restore point flags
3673   19CB D1                  POP     DE              ; Restore sign of exponent
3674   19CC C3 6F 19            JP      MANLP           ; Get another digit
3675   19CF             
3676   19CF CD 85 18    RSCALE: CALL    STAKFP          ; Put number on stack
3677   19D2 CD 66 18            CALL    FLGREL          ; Digit to add to FPREG
3678   19D5 C1          PADD:   POP     BC              ; Restore number
3679   19D6 D1                  POP     DE
3680   19D7 C3 0E 16            JP      FPADD           ; Add BCDE to FPREG and return
3681   19DA             
3682   19DA 7B          EDIGIT: LD      A,E             ; Get digit
3683   19DB 07                  RLCA                    ; Times 2
3684   19DC 07                  RLCA                    ; Times 4
3685   19DD 83                  ADD     A,E             ; Times 5
3686   19DE 07                  RLCA                    ; Times 10
3687   19DF 86                  ADD     A,(HL)          ; Add next digit
3688   19E0 D6 30               SUB     '0'             ; Make it absolute
3689   19E2 5F                  LD      E,A             ; Save new digit
3690   19E3 C3 85 19            JP      EXPLP           ; Look for another digit
3691   19E6             
3692   19E6 E5          LINEIN: PUSH    HL              ; Save code string address
3693   19E7 21 45 05            LD      HL,INMSG        ; Output " in "
3694   19EA CD 4B 13            CALL    PRS             ; Output string at HL
3695   19ED E1                  POP     HL              ; Restore code string address
3696   19EE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   19EF AF                  XOR     A
3698   19F0 06 98               LD      B,80H+24        ; 24 bits
3699   19F2 CD 6B 18            CALL    RETINT          ; Return the integer
3700   19F5 21 4A 13            LD      HL,PRNUMS       ; Print number string
3701   19F8 E5                  PUSH    HL              ; Save for return
3702   19F9 21 2E 81    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   19FC E5                  PUSH    HL              ; Save for return
3704   19FD CD 54 18            CALL    TSTSGN          ; Test sign of FPREG
3705   1A00 36 20               LD      (HL),' '        ; Space at start
3706   1A02 F2 07 1A            JP      P,SPCFST        ; Positive - Space to start
3707   1A05 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   1A07 23          SPCFST: INC     HL              ; First byte of number
3709   1A08 36 30               LD      (HL),'0'        ; '0' if zero
3710   1A0A CA BD 1A            JP      Z,JSTZER        ; Return '0' if zero
3711   1A0D E5                  PUSH    HL              ; Save buffer address
3712   1A0E FC 7D 18            CALL    M,INVSGN        ; Negate FPREG if negative
3713   1A11 AF                  XOR     A               ; Zero A
3714   1A12 F5                  PUSH    AF              ; Save it
3715   1A13 CD C3 1A            CALL    RNGTST          ; Test number is in range
3716   1A16 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   1A19 11 F8 4F            LD      DE,4FF8H
3718   1A1C CD CF 18            CALL    CMPNUM          ; Compare numbers
3719   1A1F B7                  OR      A
3720   1A20 E2 34 1A            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   1A23 F1                  POP     AF              ; Restore count
3722   1A24 CD B1 19            CALL    MULTEN          ; Multiply by ten
3723   1A27 F5                  PUSH    AF              ; Re-save count
3724   1A28 C3 16 1A            JP      SIXDIG          ; Test it again
3725   1A2B             
3726   1A2B CD 9C 17    GTSIXD: CALL    DIV10           ; Divide by 10
3727   1A2E F1                  POP     AF              ; Get count
3728   1A2F 3C                  INC     A               ; Count divides
3729   1A30 F5                  PUSH    AF              ; Re-save count
3730   1A31 CD C3 1A            CALL    RNGTST          ; Test number is in range
3731   1A34 CD FC 15    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   1A37 3C                  INC     A
3733   1A38 CD FC 18            CALL    FPINT           ; F.P to integer
3734   1A3B CD 95 18            CALL    FPBCDE          ; Move BCDE to FPREG
3735   1A3E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   1A41 F1                  POP     AF              ; Restore count
3737   1A42 81                  ADD     A,C             ; 6 digits before point
3738   1A43 3C                  INC     A               ; Add one
3739   1A44 FA 50 1A            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   1A47 FE 08               CP      6+1+1           ; More than 999999 ?
3741   1A49 D2 50 1A            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   1A4C 3C                  INC     A               ; Adjust for exponent
3743   1A4D 47                  LD      B,A             ; Exponent of number
3744   1A4E 3E 02               LD      A,2             ; Make it zero after
3745   1A50             
3746   1A50 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   1A51 3D                  DEC     A
3748   1A52 E1                  POP     HL              ; Restore buffer address
3749   1A53 F5                  PUSH    AF              ; Save count
3750   1A54 11 D6 1A            LD      DE,POWERS       ; Powers of ten
3751   1A57 05                  DEC     B               ; Count digits before point
3752   1A58 C2 61 1A            JP      NZ,DIGTXT       ; Not zero - Do number
3753   1A5B 36 2E               LD      (HL),'.'        ; Save point
3754   1A5D 23                  INC     HL              ; Move on
3755   1A5E 36 30               LD      (HL),'0'        ; Save zero
3756   1A60 23                  INC     HL              ; Move on
3757   1A61 05          DIGTXT: DEC     B               ; Count digits before point
3758   1A62 36 2E               LD      (HL),'.'        ; Save point in case
3759   1A64 CC AA 18            CALL    Z,INCHL         ; Last digit - move on
3760   1A67 C5                  PUSH    BC              ; Save digits before point
3761   1A68 E5                  PUSH    HL              ; Save buffer address
3762   1A69 D5                  PUSH    DE              ; Save powers of ten
3763   1A6A CD A0 18            CALL    BCDEFP          ; Move FPREG to BCDE
3764   1A6D E1                  POP     HL              ; Powers of ten table
3765   1A6E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   1A70 04          TRYAGN: INC     B               ; Count subtractions
3767   1A71 7B                  LD      A,E             ; Get LSB
3768   1A72 96                  SUB     (HL)            ; Subtract LSB
3769   1A73 5F                  LD      E,A             ; Save LSB
3770   1A74 23                  INC     HL
3771   1A75 7A                  LD      A,D             ; Get NMSB
3772   1A76 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   1A77 57                  LD      D,A             ; Save NMSB
3774   1A78 23                  INC     HL
3775   1A79 79                  LD      A,C             ; Get MSB
3776   1A7A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   1A7B 4F                  LD      C,A             ; Save MSB
3778   1A7C 2B                  DEC     HL              ; Point back to start
3779   1A7D 2B                  DEC     HL
3780   1A7E D2 70 1A            JP      NC,TRYAGN       ; No overflow - Try again
3781   1A81 CD B3 16            CALL    PLUCDE          ; Restore number
3782   1A84 23                  INC     HL              ; Start of next number
3783   1A85 CD 95 18            CALL    FPBCDE          ; Move BCDE to FPREG
3784   1A88 EB                  EX      DE,HL           ; Save point in table
3785   1A89 E1                  POP     HL              ; Restore buffer address
3786   1A8A 70                  LD      (HL),B          ; Save digit in buffer
3787   1A8B 23                  INC     HL              ; And move on
3788   1A8C C1                  POP     BC              ; Restore digit count
3789   1A8D 0D                  DEC     C               ; Count digits
3790   1A8E C2 61 1A            JP      NZ,DIGTXT       ; More - Do them
3791   1A91 05                  DEC     B               ; Any decimal part?
3792   1A92 CA A1 1A            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   1A95 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   1A96 7E                  LD      A,(HL)          ; Get character
3795   1A97 FE 30               CP      '0'             ; '0' character?
3796   1A99 CA 95 1A            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   1A9C FE 2E               CP      '.'             ; A decimal point?
3798   1A9E C4 AA 18            CALL    NZ,INCHL        ; Move back over digit
3799   1AA1             
3800   1AA1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   1AA2 CA C0 1A            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   1AA5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   1AA7 23                  INC     HL              ; And move on
3804   1AA8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   1AAA F2 B1 1A            JP      P,OUTEXP        ; Positive - Output exponent
3806   1AAD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   1AAF 2F                  CPL                     ; Negate exponent
3808   1AB0 3C                  INC     A
3809   1AB1 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   1AB3 04          EXPTEN: INC     B               ; Count subtractions
3811   1AB4 D6 0A               SUB     10              ; Tens digit
3812   1AB6 D2 B3 1A            JP      NC,EXPTEN       ; More to do
3813   1AB9 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   1ABB 23                  INC     HL              ; Move on
3815   1ABC 70                  LD      (HL),B          ; Save MSB of exponent
3816   1ABD 23          JSTZER: INC     HL              ;
3817   1ABE 77                  LD      (HL),A          ; Save LSB of exponent
3818   1ABF 23                  INC     HL
3819   1AC0 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   1AC1 E1                  POP     HL              ; Restore code string address
3821   1AC2 C9                  RET
3822   1AC3             
3823   1AC3 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   1AC6 11 F7 23            LD      DE,23F7H
3825   1AC9 CD CF 18            CALL    CMPNUM          ; Compare numbers
3826   1ACC B7                  OR      A
3827   1ACD E1                  POP     HL              ; Return address to HL
3828   1ACE E2 2B 1A            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   1AD1 E9                  JP      (HL)            ; Otherwise return to caller
3830   1AD2             
3831   1AD2 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   1AD6             
3833   1AD6 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   1AD9 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   1ADC E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   1ADF 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   1AE2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   1AE5 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   1AE8             
3840   1AE8 21 7D 18    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   1AEB E3                  EX      (SP),HL         ; To be done after caller
3842   1AEC E9                  JP      (HL)            ; Return to caller
3843   1AED             
3844   1AED CD 85 18    SQR:    CALL    STAKFP          ; Put value on stack
3845   1AF0 21 D2 1A            LD      HL,HALF         ; Set power to 1/2
3846   1AF3 CD 92 18            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   1AF6             
3848   1AF6 C1          POWER:  POP     BC              ; Get base
3849   1AF7 D1                  POP     DE
3850   1AF8 CD 54 18            CALL    TSTSGN          ; Test sign of power
3851   1AFB 78                  LD      A,B             ; Get exponent of base
3852   1AFC CA 3B 1B            JP      Z,EXP           ; Make result 1 if zero
3853   1AFF F2 06 1B            JP      P,POWER1        ; Positive base - Ok
3854   1B02 B7                  OR      A               ; Zero to negative power?
3855   1B03 CA B0 05            JP      Z,DZERR         ; Yes - ?/0 Error
3856   1B06 B7          POWER1: OR      A               ; Base zero?
3857   1B07 CA 75 16            JP      Z,SAVEXP        ; Yes - Return zero
3858   1B0A D5                  PUSH    DE              ; Save base
3859   1B0B C5                  PUSH    BC
3860   1B0C 79                  LD      A,C             ; Get MSB of base
3861   1B0D F6 7F               OR      01111111B       ; Get sign status
3862   1B0F CD A0 18            CALL    BCDEFP          ; Move power to BCDE
3863   1B12 F2 23 1B            JP      P,POWER2        ; Positive base - Ok
3864   1B15 D5                  PUSH    DE              ; Save power
3865   1B16 C5                  PUSH    BC
3866   1B17 CD 27 19            CALL    INT             ; Get integer of power
3867   1B1A C1                  POP     BC              ; Restore power
3868   1B1B D1                  POP     DE
3869   1B1C F5                  PUSH    AF              ; MSB of base
3870   1B1D CD CF 18            CALL    CMPNUM          ; Power an integer?
3871   1B20 E1                  POP     HL              ; Restore MSB of base
3872   1B21 7C                  LD      A,H             ; but don't affect flags
3873   1B22 1F                  RRA                     ; Exponent odd or even?
3874   1B23 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   1B24 22 2B 81            LD      (FPREG+2),HL    ; Save base in FPREG
3876   1B27 E1                  POP     HL              ; LSBs of base
3877   1B28 22 29 81            LD      (FPREG),HL      ; Save in FPREG
3878   1B2B DC E8 1A            CALL    C,NEGAFT        ; Odd power - Negate result
3879   1B2E CC 7D 18            CALL    Z,INVSGN        ; Negative base - Negate it
3880   1B31 D5                  PUSH    DE              ; Save power
3881   1B32 C5                  PUSH    BC
3882   1B33 CD 08 17            CALL    LOG             ; Get LOG of base
3883   1B36 C1                  POP     BC              ; Restore power
3884   1B37 D1                  POP     DE
3885   1B38 CD 49 17            CALL    FPMULT          ; Multiply LOG by power
3886   1B3B             
3887   1B3B CD 85 18    EXP:    CALL    STAKFP          ; Put value on stack
3888   1B3E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   1B41 11 3B AA            LD      DE,0AA3BH
3890   1B44 CD 49 17            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   1B47 3A 2C 81            LD      A,(FPEXP)       ; Get exponent
3892   1B4A FE 88               CP      80H+8           ; Is it in range?
3893   1B4C D2 30 18            JP      NC,OVTST1       ; No - Test for overflow
3894   1B4F CD 27 19            CALL    INT             ; Get INT of FPREG
3895   1B52 C6 80               ADD     A,80H           ; For excess 128
3896   1B54 C6 02               ADD     A,2             ; Exponent > 126?
3897   1B56 DA 30 18            JP      C,OVTST1        ; Yes - Test for overflow
3898   1B59 F5                  PUSH    AF              ; Save scaling factor
3899   1B5A 21 F7 16            LD      HL,UNITY        ; Point to 1.
3900   1B5D CD FF 15            CALL    ADDPHL          ; Add 1 to FPREG
3901   1B60 CD 40 17            CALL    MULLN2          ; Multiply by LN(2)
3902   1B63 F1                  POP     AF              ; Restore scaling factor
3903   1B64 C1                  POP     BC              ; Restore exponent
3904   1B65 D1                  POP     DE
3905   1B66 F5                  PUSH    AF              ; Save scaling factor
3906   1B67 CD 0B 16            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   1B6A CD 7D 18            CALL    INVSGN          ; Negate result
3908   1B6D 21 7B 1B            LD      HL,EXPTAB       ; Coefficient table
3909   1B70 CD AB 1B            CALL    SMSER1          ; Sum the series
3910   1B73 11 00 00            LD      DE,0            ; Zero LSBs
3911   1B76 C1                  POP     BC              ; Scaling factor
3912   1B77 4A                  LD      C,D             ; Zero MSB
3913   1B78 C3 49 17            JP      FPMULT          ; Scale result to correct value
3914   1B7B             
3915   1B7B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   1B7C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   1B80 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   1B84 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   1B88 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   1B8C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   1B90 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   1B94 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   1B98 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   1B9C             
3925   1B9C CD 85 18    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   1B9F 11 47 17            LD      DE,MULT         ; Multiply by "X"
3927   1BA2 D5                  PUSH    DE              ; To be done after
3928   1BA3 E5                  PUSH    HL              ; Save address of table
3929   1BA4 CD A0 18            CALL    BCDEFP          ; Move FPREG to BCDE
3930   1BA7 CD 49 17            CALL    FPMULT          ; Square the value
3931   1BAA E1                  POP     HL              ; Restore address of table
3932   1BAB CD 85 18    SMSER1: CALL    STAKFP          ; Put value on stack
3933   1BAE 7E                  LD      A,(HL)          ; Get number of coefficients
3934   1BAF 23                  INC     HL              ; Point to start of table
3935   1BB0 CD 92 18            CALL    PHLTFP          ; Move coefficient to FPREG
3936   1BB3 06                  .BYTE      06H             ; Skip "POP AF"
3937   1BB4 F1          SUMLP:  POP     AF              ; Restore count
3938   1BB5 C1                  POP     BC              ; Restore number
3939   1BB6 D1                  POP     DE
3940   1BB7 3D                  DEC     A               ; Cont coefficients
3941   1BB8 C8                  RET     Z               ; All done
3942   1BB9 D5                  PUSH    DE              ; Save number
3943   1BBA C5                  PUSH    BC
3944   1BBB F5                  PUSH    AF              ; Save count
3945   1BBC E5                  PUSH    HL              ; Save address in table
3946   1BBD CD 49 17            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   1BC0 E1                  POP     HL              ; Restore address in table
3948   1BC1 CD A3 18            CALL    LOADFP          ; Number at HL to BCDE
3949   1BC4 E5                  PUSH    HL              ; Save address in table
3950   1BC5 CD 0E 16            CALL    FPADD           ; Add coefficient to FPREG
3951   1BC8 E1                  POP     HL              ; Restore address in table
3952   1BC9 C3 B4 1B            JP      SUMLP           ; More coefficients
3953   1BCC             
3954   1BCC CD 54 18    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   1BCF 21 5E 80            LD      HL,SEED+2       ; Random number seed
3956   1BD2 FA 2D 1C            JP      M,RESEED        ; Negative - Re-seed
3957   1BD5 21 7F 80            LD      HL,LSTRND       ; Last random number
3958   1BD8 CD 92 18            CALL    PHLTFP          ; Move last RND to FPREG
3959   1BDB 21 5E 80            LD      HL,SEED+2       ; Random number seed
3960   1BDE C8                  RET     Z               ; Return if RND(0)
3961   1BDF 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   1BE0 E6 07               AND     00000111B       ; 0 to 7
3963   1BE2 06 00               LD      B,0
3964   1BE4 77                  LD      (HL),A          ; Re-save seed
3965   1BE5 23                  INC     HL              ; Move to coefficient table
3966   1BE6 87                  ADD     A,A             ; 4 bytes
3967   1BE7 87                  ADD     A,A             ; per entry
3968   1BE8 4F                  LD      C,A             ; BC = Offset into table
3969   1BE9 09                  ADD     HL,BC           ; Point to coefficient
3970   1BEA CD A3 18            CALL    LOADFP          ; Coefficient to BCDE
3971   1BED CD 49 17            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   1BF0 3A 5D 80            LD      A,(SEED+1)      ; Get (SEED+1)
3973   1BF3 3C                  INC     A               ; Add 1
3974   1BF4 E6 03               AND     00000011B       ; 0 to 3
3975   1BF6 06 00               LD      B,0
3976   1BF8 FE 01               CP      1               ; Is it zero?
3977   1BFA 88                  ADC     A,B             ; Yes - Make it 1
3978   1BFB 32 5D 80            LD      (SEED+1),A      ; Re-save seed
3979   1BFE 21 31 1C            LD      HL,RNDTAB-4     ; Addition table
3980   1C01 87                  ADD     A,A             ; 4 bytes
3981   1C02 87                  ADD     A,A             ; per entry
3982   1C03 4F                  LD      C,A             ; BC = Offset into table
3983   1C04 09                  ADD     HL,BC           ; Point to value
3984   1C05 CD FF 15            CALL    ADDPHL          ; Add value to FPREG
3985   1C08 CD A0 18    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   1C0B 7B                  LD      A,E             ; Get LSB
3987   1C0C 59                  LD      E,C             ; LSB = MSB
3988   1C0D EE 4F               XOR     01001111B       ; Fiddle around
3989   1C0F 4F                  LD      C,A             ; New MSB
3990   1C10 36 80               LD      (HL),80H        ; Set exponent
3991   1C12 2B                  DEC     HL              ; Point to MSB
3992   1C13 46                  LD      B,(HL)          ; Get MSB
3993   1C14 36 80               LD      (HL),80H        ; Make value -0.5
3994   1C16 21 5C 80            LD      HL,SEED         ; Random number seed
3995   1C19 34                  INC     (HL)            ; Count seed
3996   1C1A 7E                  LD      A,(HL)          ; Get seed
3997   1C1B D6 AB               SUB     171             ; Do it modulo 171
3998   1C1D C2 24 1C            JP      NZ,RND2         ; Non-zero - Ok
3999   1C20 77                  LD      (HL),A          ; Zero seed
4000   1C21 0C                  INC     C               ; Fillde about
4001   1C22 15                  DEC     D               ; with the
4002   1C23 1C                  INC     E               ; number
4003   1C24 CD 5F 16    RND2:   CALL    BNORM           ; Normalise number
4004   1C27 21 7F 80            LD      HL,LSTRND       ; Save random number
4005   1C2A C3 AC 18            JP      FPTHL           ; Move FPREG to last and return
4006   1C2D             
4007   1C2D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   1C2E 2B                  DEC     HL
4009   1C2F 77                  LD      (HL),A
4010   1C30 2B                  DEC     HL
4011   1C31 77                  LD      (HL),A
4012   1C32 C3 08 1C            JP      RND1            ; Return RND seed
4013   1C35             
4014   1C35 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   1C39 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   1C3D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   1C41             
4018   1C41 21 8B 1C    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   1C44 CD FF 15            CALL    ADDPHL          ; Add it to PPREG
4020   1C47 CD 85 18    SIN:    CALL    STAKFP          ; Put angle on stack
4021   1C4A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   1C4D 11 DB 0F            LD      DE,0FDBH
4023   1C50 CD 95 18            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   1C53 C1                  POP     BC              ; Restore angle
4025   1C54 D1                  POP     DE
4026   1C55 CD AA 17            CALL    DVBCDE          ; Divide angle by 2 PI
4027   1C58 CD 85 18            CALL    STAKFP          ; Put it on stack
4028   1C5B CD 27 19            CALL    INT             ; Get INT of result
4029   1C5E C1                  POP     BC              ; Restore number
4030   1C5F D1                  POP     DE
4031   1C60 CD 0B 16            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   1C63 21 8F 1C            LD      HL,QUARTR       ; Point to 0.25
4033   1C66 CD 05 16            CALL    SUBPHL          ; Subtract value from 0.25
4034   1C69 CD 54 18            CALL    TSTSGN          ; Test sign of value
4035   1C6C 37                  SCF                     ; Flag positive
4036   1C6D F2 77 1C            JP      P,SIN1          ; Positive - Ok
4037   1C70 CD FC 15            CALL    ROUND           ; Add 0.5 to value
4038   1C73 CD 54 18            CALL    TSTSGN          ; Test sign of value
4039   1C76 B7                  OR      A               ; Flag negative
4040   1C77 F5          SIN1:   PUSH    AF              ; Save sign
4041   1C78 F4 7D 18            CALL    P,INVSGN        ; Negate value if positive
4042   1C7B 21 8F 1C            LD      HL,QUARTR       ; Point to 0.25
4043   1C7E CD FF 15            CALL    ADDPHL          ; Add 0.25 to value
4044   1C81 F1                  POP     AF              ; Restore sign
4045   1C82 D4 7D 18            CALL    NC,INVSGN       ; Negative - Make positive
4046   1C85 21 93 1C            LD      HL,SINTAB       ; Coefficient table
4047   1C88 C3 9C 1B            JP      SUMSER          ; Evaluate sum of series
4048   1C8B             
4049   1C8B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   1C8F             
4051   1C8F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   1C93             
4053   1C93 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   1C94 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   1C98 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   1C9C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   1CA0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   1CA4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   1CA8             
4060   1CA8 CD 85 18    TAN:    CALL    STAKFP          ; Put angle on stack
4061   1CAB CD 47 1C            CALL    SIN             ; Get SIN of angle
4062   1CAE C1                  POP     BC              ; Restore angle
4063   1CAF E1                  POP     HL
4064   1CB0 CD 85 18            CALL    STAKFP          ; Save SIN of angle
4065   1CB3 EB                  EX      DE,HL           ; BCDE = Angle
4066   1CB4 CD 95 18            CALL    FPBCDE          ; Angle to FPREG
4067   1CB7 CD 41 1C            CALL    COS             ; Get COS of angle
4068   1CBA C3 A8 17            JP      DIV             ; TAN = SIN / COS
4069   1CBD             
4070   1CBD CD 54 18    ATN:    CALL    TSTSGN          ; Test sign of value
4071   1CC0 FC E8 1A            CALL    M,NEGAFT        ; Negate result after if -ve
4072   1CC3 FC 7D 18            CALL    M,INVSGN        ; Negate value if -ve
4073   1CC6 3A 2C 81            LD      A,(FPEXP)       ; Get exponent
4074   1CC9 FE 81               CP      81H             ; Number less than 1?
4075   1CCB DA DA 1C            JP      C,ATN1          ; Yes - Get arc tangnt
4076   1CCE 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   1CD1 51                  LD      D,C
4078   1CD2 59                  LD      E,C
4079   1CD3 CD AA 17            CALL    DVBCDE          ; Get reciprocal of number
4080   1CD6 21 05 16            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   1CD9 E5                  PUSH    HL              ; Save for angle > 1
4082   1CDA 21 E4 1C    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   1CDD CD 9C 1B            CALL    SUMSER          ; Evaluate sum of series
4084   1CE0 21 8B 1C            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   1CE3 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   1CE4             
4087   1CE4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   1CE5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   1CE9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   1CED FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   1CF1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   1CF5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   1CF9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   1CFD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   1D01 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   1D05 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   1D09             
4098   1D09             
4099   1D09 C9          ARET:   RET                     ; A RETurn instruction
4100   1D0A             
4101   1D0A D7          GETINP: RST	    10H             ;input a character
4102   1D0B C9                  RET
4103   1D0C             
4104   1D0C             CLS:
4105   1D0C 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   1D0E C3 46 1E            JP      MONOUT          ; Output character
4107   1D11             
4108   1D11 CD D3 15    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   1D14 7B                  LD      A,E             ; Width to A
4110   1D15 32 87 80            LD      (LWIDTH),A      ; Set width
4111   1D18 C9                  RET
4112   1D19             
4113   1D19 CD 72 0E    LINES:  CALL    GETNUM          ; Get a number
4114   1D1C CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
4115   1D1F ED 53 8B 80         LD      (LINESC),DE     ; Set lines counter
4116   1D23 ED 53 8D 80         LD      (LINESN),DE     ; Set lines number
4117   1D27 C9                  RET
4118   1D28             
4119   1D28 CD B7 0A    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   1D2B D5                  PUSH    DE              ; Save number
4121   1D2C E1                  POP     HL              ; Number to HL
4122   1D2D 46                  LD      B,(HL)          ; Get LSB of contents
4123   1D2E 23                  INC     HL
4124   1D2F 7E                  LD      A,(HL)          ; Get MSB of contents
4125   1D30 C3 2D 12            JP      ABPASS          ; Return integer AB
4126   1D33             
4127   1D33 CD 72 0E    DOKE:   CALL    GETNUM          ; Get a number
4128   1D36 CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
4129   1D39 D5                  PUSH    DE              ; Save address
4130   1D3A CD 7B 08            CALL    CHKSYN          ; Make sure ',' follows
4131   1D3D 2C                  .BYTE      ','
4132   1D3E CD 72 0E            CALL    GETNUM          ; Get a number
4133   1D41 CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
4134   1D44 E3                  EX      (SP),HL         ; Save value,get address
4135   1D45 73                  LD      (HL),E          ; Save LSB of value
4136   1D46 23                  INC     HL
4137   1D47 72                  LD      (HL),D          ; Save MSB of value
4138   1D48 E1                  POP     HL              ; Restore code string address
4139   1D49 C9                  RET
4140   1D4A             
4141   1D4A             
4142   1D4A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   1D4A             
4144   1D4A CD 75 0E    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   1D4D CD B7 0A            CALL	DEINT           ; Get integer -32768 to 32767
4146   1D50 C5                  PUSH	BC              ; Save contents of BC
4147   1D51 21 2E 81            LD	    HL,PBUFF
4148   1D54 7A                  LD	    A,D             ; Get high order into A
4149   1D55 FE 00               CP      $0
4150   1D57 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   1D59 CD 82 1D            CALL    BYT2ASC         ; Convert D to ASCII
4152   1D5C 78          		LD      A,B
4153   1D5D FE 30       		CP      '0'
4154   1D5F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   1D61 70                  LD	    (HL),B          ; Store it to PBUFF
4156   1D62 23                  INC	    HL              ; Next location
4157   1D63 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   1D64 23                  INC     HL              ; Next location
4159   1D65 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   1D66 CD 82 1D            CALL    BYT2ASC         ; Convert E to ASCII
4161   1D69 7A          		LD      A,D
4162   1D6A FE 00               CP      $0
4163   1D6C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   1D6E 78          		LD      A,B
4165   1D6F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   1D71 28 02       		JR      Z,HEX4
4167   1D73 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   1D74 23                  INC     HL              ; Next location
4169   1D75 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   1D76 23                  INC     HL              ; PBUFF+4 to zero
4171   1D77 AF                  XOR     A               ; Terminating character
4172   1D78 77                  LD      (HL),A          ; Store zero to terminate
4173   1D79 23                  INC     HL              ; Make sure PBUFF is terminated
4174   1D7A 77                  LD      (HL),A          ; Store the double zero there
4175   1D7B C1                  POP     BC              ; Get BC back
4176   1D7C 21 2E 81            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   1D7F C3 DB 12            JP      STR1            ; Convert the PBUFF to a string and return it
4178   1D82             
4179   1D82 47          BYT2ASC	LD      B,A             ; Save original value
4180   1D83 E6 0F               AND     $0F             ; Strip off upper nybble
4181   1D85 FE 0A               CP      $0A             ; 0-9?
4182   1D87 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   1D89 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   1D8B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   1D8D 4F                  LD      C,A             ; Save converted char to C
4186   1D8E 78                  LD      A,B             ; Retrieve original value
4187   1D8F 0F                  RRCA                    ; and Rotate it right
4188   1D90 0F                  RRCA
4189   1D91 0F                  RRCA
4190   1D92 0F                  RRCA
4191   1D93 E6 0F               AND     $0F             ; Mask off upper nybble
4192   1D95 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   1D97 38 02               JR      C,ADD301        ; Skip Add 7
4194   1D99 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   1D9B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   1D9D 47                  LD      B,A             ; Store high order byte
4197   1D9E C9                  RET
4198   1D9F             
4199   1D9F             ; Convert "&Hnnnn" to FPREG
4200   1D9F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   1D9F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   1D9F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   1DA0 21 00 00            LD      HL,$0000        ; Zero out the value
4204   1DA3 CD B8 1D            CALL    GETHEX          ; Check the number for valid hex
4205   1DA6 DA D8 1D            JP      C,HXERR         ; First value wasn't hex, HX error
4206   1DA9 18 05               JR      HEXLP1          ; Convert first character
4207   1DAB CD B8 1D    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   1DAE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   1DB0 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   1DB1 29                  ADD     HL,HL
4211   1DB2 29                  ADD     HL,HL
4212   1DB3 29                  ADD     HL,HL
4213   1DB4 B5                  OR      L               ; Add in D0-D3 into L
4214   1DB5 6F                  LD      L,A             ; Save new value
4215   1DB6 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   1DB8             
4217   1DB8 13          GETHEX  INC     DE              ; Next location
4218   1DB9 1A                  LD      A,(DE)          ; Load character at pointer
4219   1DBA FE 20               CP      ' '
4220   1DBC CA B8 1D            JP      Z,GETHEX        ; Skip spaces
4221   1DBF D6 30               SUB     $30             ; Get absolute value
4222   1DC1 D8                  RET     C               ; < "0", error
4223   1DC2 FE 0A               CP      $0A
4224   1DC4 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   1DC6 D6 07               SUB     $07             ; Reduce to A-F
4226   1DC8 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   1DCA D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   1DCB FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   1DCD 3F                  CCF
4230   1DCE C9                  RET                     ; CY set if it wasn't valid hex
4231   1DCF             
4232   1DCF EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   1DD0 7A                  LD      A,D             ; Load DE into AC
4234   1DD1 4B                  LD      C,E             ; For prep to
4235   1DD2 E5                  PUSH    HL
4236   1DD3 CD 2C 12            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   1DD6 E1                  POP     HL
4238   1DD7 C9                  RET
4239   1DD8             
4240   1DD8 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   1DDA C3 C1 05            JP      ERROR
4242   1DDD             
4243   1DDD             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   1DDD CD 75 0E    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   1DE0 CD B7 0A            CALL    DEINT           ; Get integer -32768 to 32767
4246   1DE3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   1DE4 21 2E 81            LD      HL,PBUFF
4248   1DE7 06 11               LD      B,17            ; One higher than max char count
4249   1DE9             ZEROSUP:                        ; Suppress leading zeros
4250   1DE9 05                  DEC     B               ; Max 16 chars
4251   1DEA 78                  LD      A,B
4252   1DEB FE 01               CP      $01
4253   1DED 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   1DEF CB 13               RL      E
4255   1DF1 CB 12               RL      D
4256   1DF3 30 F4               JR      NC,ZEROSUP
4257   1DF5 18 04               JR      BITOUT2
4258   1DF7             BITOUT:
4259   1DF7 CB 13               RL      E
4260   1DF9 CB 12               RL      D               ; Top bit now in carry
4261   1DFB             BITOUT2:
4262   1DFB 3E 30               LD      A,'0'           ; Char for '0'
4263   1DFD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   1DFF 77                  LD      (HL),A
4265   1E00 23                  INC     HL
4266   1E01 05                  DEC     B
4267   1E02 20 F3               JR      NZ,BITOUT
4268   1E04 AF                  XOR     A               ; Terminating character
4269   1E05 77                  LD      (HL),A          ; Store zero to terminate
4270   1E06 23                  INC     HL              ; Make sure PBUFF is terminated
4271   1E07 77                  LD      (HL),A          ; Store the double zero there
4272   1E08 C1                  POP     BC
4273   1E09 21 2E 81            LD      HL,PBUFF
4274   1E0C C3 DB 12            JP      STR1
4275   1E0F             
4276   1E0F             ; Convert "&Bnnnn" to FPREG
4277   1E0F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   1E0F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   1E10 21 00 00            LD      HL,$0000        ; Zero out the value
4280   1E13 CD 2C 1E            CALL    CHKBIN          ; Check the number for valid bin
4281   1E16 DA 3A 1E            JP      C,BINERR        ; First value wasn't bin, HX error
4282   1E19 D6 30       BINIT:  SUB     '0'
4283   1E1B 29                  ADD     HL,HL           ; Rotate HL left
4284   1E1C B5                  OR      L
4285   1E1D 6F                  LD      L,A
4286   1E1E CD 2C 1E            CALL    CHKBIN          ; Get second and addtional characters
4287   1E21 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   1E23 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   1E24 7A                  LD      A,D             ; Load DE into AC
4290   1E25 4B                  LD      C,E             ; For prep to
4291   1E26 E5                  PUSH    HL
4292   1E27 CD 2C 12            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   1E2A E1                  POP     HL
4294   1E2B C9                  RET
4295   1E2C             
4296   1E2C             ; Char is in A, NC if char is 0 or 1
4297   1E2C 13          CHKBIN: INC     DE
4298   1E2D 1A                  LD      A,(DE)
4299   1E2E FE 20               CP      ' '
4300   1E30 CA 2C 1E            JP      Z,CHKBIN        ; Skip spaces
4301   1E33 FE 30               CP      '0'             ; Set C if < '0'
4302   1E35 D8                  RET     C
4303   1E36 FE 32               CP      '2'
4304   1E38 3F                  CCF                     ; Set C if > '1'
4305   1E39 C9                  RET
4306   1E3A             
4307   1E3A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   1E3C C3 C1 05            JP      ERROR
4309   1E3F             
4310   1E3F             
4311   1E3F             JJUMP1:
4312   1E3F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   1E43 C3 11 02            JP      CSTART          ; Go and initialise
4314   1E46             
4315   1E46             MONOUT:
4316   1E46 C3 08 00            JP      $0008           ; output a char
4317   1E49             
4318   1E49             
4319   1E49             MONITR:
4320   1E49 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   1E4C             
4322   1E4C             
4323   1E4C 3E 00       INITST: LD      A,0             ; Clear break flag
4324   1E4E 32 92 80            LD      (BRKFLG),A
4325   1E51 C3 18 02            JP      INIT
4326   1E54             
4327   1E54 ED 45       ARETN:  RETN                    ; Return from NMI
4328   1E56             
4329   1E56             
4330   1E56 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   1E57 A0                  AND     B               ; Get common bits
4332   1E58 C1                  POP     BC              ; Restore bit mask
4333   1E59 B8                  CP      B               ; Same bit set?
4334   1E5A 3E 00               LD      A,0             ; Return 0 in A
4335   1E5C C9                  RET
4336   1E5D             
4337   1E5D CD 86 08    OUTNCR: CALL    OUTC            ; Output character in A
4338   1E60 C3 AD 0C            JP      PRNTCRLF        ; Output CRLF
4339   1E63             
4340   1E63             .end
tasm: Number of errors = 0
