0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    8045H             ; BASIC Work space
0041   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   01A0                     .ORG    001A0H
0130   01A0             
0131   01A0 C3 A6 01    COLD:   JP      STARTB          ; Jump for cold start
0132   01A3 C3 44 02    WARM:   JP      WARMST          ; Jump for warm start
0133   01A6             STARTB:
0134   01A6 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   01AA C3 B1 01            JP      CSTART          ; Jump to initialise
0136   01AD             
0137   01AD 57 0A               .WORD   DEINT           ; Get integer -32768 to 32767
0138   01AF CD 11               .WORD   ABPASS          ; Return integer in AB
0139   01B1             
0140   01B1             
0141   01B1 21 45 80    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   01B4 F9                  LD      SP,HL           ; Set up a temporary stack
0143   01B5 C3 EC 1D            JP      INITST          ; Go to initialise
0144   01B8             
0145   01B8 11 7E 04    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   01BB 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   01BD 21 45 80            LD      HL,WRKSPC       ; Into workspace RAM
0148   01C0 1A          COPY:   LD      A,(DE)          ; Get source
0149   01C1 77                  LD      (HL),A          ; To destination
0150   01C2 23                  INC     HL              ; Next destination
0151   01C3 13                  INC     DE              ; Next source
0152   01C4 05                  DEC     B               ; Count bytes
0153   01C5 C2 C0 01            JP      NZ,COPY         ; More to move
0154   01C8 F9                  LD      SP,HL           ; Temporary stack
0155   01C9 CD 7F 06            CALL    CLREG           ; Clear registers and stack
0156   01CC CD 4D 0C            CALL    PRNTCRLF        ; Output CRLF
0157   01CF 32 EF 80            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   01D2 32 3E 81            LD      (PROGST),A      ; Initialise program area
0159   01D5 21 93 02    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   01D8 CD EB 12            CALL    PRS             ; Output "Memory size"
0161   01DB CD 9C 06            CALL    PROMPT          ; Get input with '?'
0162   01DE CD A5 09            CALL    GETCHR          ; Get next character
0163   01E1 B7                  OR      A               ; Set flags
0164   01E2 C2 FA 01            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   01E5 21 A2 81            LD      HL,STLOOK       ; Point to start of RAM
0166   01E8 23          MLOOP:  INC     HL              ; Next byte
0167   01E9 7C                  LD      A,H             ; Above address FFFF ?
0168   01EA B5                  OR      L
0169   01EB CA 0C 02            JP      Z,SETTOP        ; Yes - 64K RAM
0170   01EE 7E                  LD      A,(HL)          ; Get contents
0171   01EF 47                  LD      B,A             ; Save it
0172   01F0 2F                  CPL                     ; Flip all bits
0173   01F1 77                  LD      (HL),A          ; Put it back
0174   01F2 BE                  CP      (HL)            ; RAM there if same
0175   01F3 70                  LD      (HL),B          ; Restore old contents
0176   01F4 CA E8 01            JP      Z,MLOOP         ; If RAM - test next byte
0177   01F7 C3 0C 02            JP      SETTOP          ; Top of RAM found
0178   01FA             
0179   01FA CD 71 0A    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   01FD B7                  OR      A               ; Set flags on last byte
0181   01FE C2 4D 05            JP      NZ,SNERR        ; ?SN Error if bad character
0182   0201 EB                  EX      DE,HL           ; Address into HL
0183   0202 2B                  DEC     HL              ; Back one byte
0184   0203 3E D9               LD      A,11011001B     ; Test byte
0185   0205 46                  LD      B,(HL)          ; Get old contents
0186   0206 77                  LD      (HL),A          ; Load test byte
0187   0207 BE                  CP      (HL)            ; RAM there if same
0188   0208 70                  LD      (HL),B          ; Restore old contents
0189   0209 C2 D5 01            JP      NZ,MSIZE        ; Ask again if no RAM
0190   020C             
0191   020C 2B          SETTOP: DEC     HL              ; Back one byte
0192   020D 11 A1 81            LD      DE,STLOOK-1     ; See if enough RAM
0193   0210 CD 15 08            CALL    CPDEHL          ; Compare DE with HL
0194   0213 DA D5 01            JP      C,MSIZE         ; Ask again if not enough RAM
0195   0216 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   0219 22 F4 80            LD      (LSTRAM),HL     ; Save last available RAM
0197   021C 19                  ADD     HL,DE           ; Allocate string space
0198   021D 22 9F 80            LD      (STRSPC),HL     ; Save string space
0199   0220 CD 5A 06            CALL    CLRPTR          ; Clear program area
0200   0223 2A 9F 80            LD      HL,(STRSPC)     ; Get end of memory
0201   0226 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   0229 19                  ADD     HL,DE           ; Adjust HL
0203   022A 11 3E 81            LD      DE,PROGST       ; Start of program text
0204   022D 7D                  LD      A,L             ; Get LSB
0205   022E 93                  SUB     E               ; Adjust it
0206   022F 6F                  LD      L,A             ; Re-save
0207   0230 7C                  LD      A,H             ; Get MSB
0208   0231 9A                  SBC     A,D             ; Adjust it
0209   0232 67                  LD      H,A             ; Re-save
0210   0233 E5                  PUSH    HL              ; Save bytes free
0211   0234 21 5C 02            LD      HL,SIGNON       ; Sign-on message
0212   0237 CD EB 12            CALL    PRS             ; Output string
0213   023A E1                  POP     HL              ; Get bytes free back
0214   023B CD 8E 19            CALL    PRNTHL          ; Output amount of free memory
0215   023E 21 4D 02            LD      HL,BFREE        ; " Bytes free" message
0216   0241 CD EB 12            CALL    PRS             ; Output string
0217   0244             
0218   0244 31 AB 80    WARMST: LD      SP,STACK        ; Temporary stack
0219   0247 CD 7F 06    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   024A C3 98 05            JP      PRNTOK          ; Go to get command line
0221   024D             
0222   024D 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   0253 20667265650D0A0000
0223   025C             
0224   025C 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   0262 5349432056657220342E37620D0A
0225   0270 436F70797269        .BYTE   "Copyright ",40,"C",41
0225   0276 67687420284329
0226   027D 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   0283 6279204D6963726F736F66740D0A0000
0227   0293             
0228   0293 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0228   0299 20746F7000
0229   029E             
0230   029E             ; FUNCTION ADDRESS TABLE
0231   029E             
0232   029E 03 18       FNCTAB: .WORD   SGN
0233   02A0 C7 18               .WORD   INT
0234   02A2 19 18               .WORD   ABS
0235   02A4 48 80               .WORD   USR
0236   02A6 AB 11               .WORD   FRE
0237   02A8 30 15               .WORD   INP
0238   02AA D9 11               .WORD   POS
0239   02AC 8D 1A               .WORD   SQR
0240   02AE 6C 1B               .WORD   RND
0241   02B0 A8 16               .WORD   LOG
0242   02B2 DB 1A               .WORD   EXP
0243   02B4 E1 1B               .WORD   COS
0244   02B6 E7 1B               .WORD   SIN
0245   02B8 48 1C               .WORD   TAN
0246   02BA 5D 1C               .WORD   ATN
0247   02BC 84 15               .WORD   PEEK
0248   02BE C8 1C               .WORD   DEEK
0249   02C0 96 80               .WORD   POINT
0250   02C2 5D 14               .WORD   LEN
0251   02C4 75 12               .WORD   STR
0252   02C6 F7 14               .WORD   VAL
0253   02C8 6C 14               .WORD   ASC
0254   02CA 7D 14               .WORD   CHR
0255   02CC EA 1C               .WORD   HEX
0256   02CE 7D 1D               .WORD   BIN
0257   02D0 8D 14               .WORD   LEFT
0258   02D2 BD 14               .WORD   RIGHT
0259   02D4 C7 14               .WORD   MID
0260   02D6             
0261   02D6             ; RESERVED WORD LIST
0262   02D6             
0263   02D6 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   02D9 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   02DC CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   02E0 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   02E4 C94E505554          .BYTE   'I'+80H,"NPUT"
0268   02E9 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   02EC D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   02F0 CC 45 54            .BYTE   'L'+80H,"ET"
0271   02F3 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   02F7 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   02FA C9 46               .BYTE   'I'+80H,"F"
0274   02FC D24553544F52        .BYTE   'R'+80H,"ESTORE"
0274   0302 45
0275   0303 C74F535542          .BYTE   'G'+80H,"OSUB"
0276   0308 D2455455524E        .BYTE   'R'+80H,"ETURN"
0277   030E D2 45 4D            .BYTE   'R'+80H,"EM"
0278   0311 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   0315 CF 55 54            .BYTE   'O'+80H,"UT"
0280   0318 CF 4E               .BYTE   'O'+80H,"N"
0281   031A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   031E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   0322 C4 45 46            .BYTE   'D'+80H,"EF"
0284   0325 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   0329 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   032D D3435245454E        .BYTE   'S'+80H,"CREEN"
0287   0333 CC494E4553          .BYTE   'L'+80H,"INES"
0288   0338 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   033B D749445448          .BYTE   'W'+80H,"IDTH"
0290   0340 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0290   0346 52
0291   0347 D3 45 54            .BYTE   'S'+80H,"ET"
0292   034A D245534554          .BYTE   'R'+80H,"ESET"
0293   034F D052494E54          .BYTE   'P'+80H,"RINT"
0294   0354 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   0358 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   035C C34C454152          .BYTE   'C'+80H,"LEAR"
0297   0361 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0298   0366 C353415645          .BYTE   'C'+80H,"SAVE"
0299   036B CE 45 57            .BYTE   'N'+80H,"EW"
0300   036E             
0301   036E D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   0372 D4 4F               .BYTE   'T'+80H,"O"
0303   0374 C6 4E               .BYTE   'F'+80H,"N"
0304   0376 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   037A D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   037E CE 4F 54            .BYTE   'N'+80H,"OT"
0307   0381 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   0385             
0309   0385 AB                  .BYTE   '+'+80H
0310   0386 AD                  .BYTE   '-'+80H
0311   0387 AA                  .BYTE   '*'+80H
0312   0388 AF                  .BYTE   '/'+80H
0313   0389 DE                  .BYTE   '^'+80H
0314   038A C1 4E 44            .BYTE   'A'+80H,"ND"
0315   038D CF 52               .BYTE   'O'+80H,"R"
0316   038F BE                  .BYTE   '>'+80H
0317   0390 BD                  .BYTE   '='+80H
0318   0391 BC                  .BYTE   '<'+80H
0319   0392             
0320   0392 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   0395 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   0398 C1 42 53            .BYTE   'A'+80H,"BS"
0323   039B D5 53 52            .BYTE   'U'+80H,"SR"
0324   039E C6 52 45            .BYTE   'F'+80H,"RE"
0325   03A1 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   03A4 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   03A7 D3 51 52            .BYTE   'S'+80H,"QR"
0328   03AA D2 4E 44            .BYTE   'R'+80H,"ND"
0329   03AD CC 4F 47            .BYTE   'L'+80H,"OG"
0330   03B0 C5 58 50            .BYTE   'E'+80H,"XP"
0331   03B3 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   03B6 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   03B9 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   03BC C1 54 4E            .BYTE   'A'+80H,"TN"
0335   03BF D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   03C3 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   03C7 D04F494E54          .BYTE   'P'+80H,"OINT"
0338   03CC CC 45 4E            .BYTE   'L'+80H,"EN"
0339   03CF D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   03D3 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   03D6 C1 53 43            .BYTE   'A'+80H,"SC"
0342   03D9 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   03DD C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   03E1 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   03E5 CC45465424          .BYTE   'L'+80H,"EFT$"
0346   03EA D24947485424        .BYTE   'R'+80H,"IGHT$"
0347   03F0 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   03F4 80                  .BYTE   80H             ; End of list marker
0349   03F5             
0350   03F5             ; KEYWORD ADDRESS TABLE
0351   03F5             
0352   03F5 EF 09       WORDTB: .WORD   PEND
0353   03F7 EC 08               .WORD   FOR
0354   03F9 C7 0D               .WORD   NEXT
0355   03FB 3C 0B               .WORD   DATA
0356   03FD CE 0C               .WORD   INPUT
0357   03FF 03 10               .WORD   DIM
0358   0401 FD 0C               .WORD   READ
0359   0403 53 0B               .WORD   LET
0360   0405 F9 0A               .WORD   GOTO
0361   0407 DC 0A               .WORD   RUN
0362   0409 CB 0B               .WORD   IF
0363   040B B5 09               .WORD   RESTOR
0364   040D E8 0A               .WORD   GOSUB
0365   040F 17 0B               .WORD   RETURN
0366   0411 3E 0B               .WORD   REM
0367   0413 ED 09               .WORD   STOP
0368   0415 3C 15               .WORD   POUT
0369   0417 AD 0B               .WORD   ON
0370   0419 2E 0A               .WORD   NULL
0371   041B 42 15               .WORD   WAIT
0372   041D E1 11               .WORD   DEF
0373   041F 8B 15               .WORD   POKE
0374   0421 D3 1C               .WORD   DOKE
0375   0423 3E 0B               .WORD   REM
0376   0425 B9 1C               .WORD   LINES
0377   0427 AC 1C               .WORD   CLS
0378   0429 B1 1C               .WORD   WIDTH
0379   042B E9 1D               .WORD   MONITR
0380   042D 99 80               .WORD   PSET
0381   042F 9C 80               .WORD   RESET
0382   0431 EF 0B               .WORD   PRINT
0383   0433 1B 0A               .WORD   CONT
0384   0435 61 08               .WORD   LIST
0385   0437 96 0A               .WORD   CLEAR
0386   0439 3E 0B               .WORD   REM
0387   043B 3E 0B               .WORD   REM
0388   043D 59 06               .WORD   NEW
0389   043F             
0390   043F             ; RESERVED WORD TOKEN VALUES
0391   043F             
0392   043F             ZEND    .EQU    080H            ; END
0393   043F             ZFOR    .EQU    081H            ; FOR
0394   043F             ZDATA   .EQU    083H            ; DATA
0395   043F             ZGOTO   .EQU    088H            ; GOTO
0396   043F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   043F             ZREM    .EQU    08EH            ; REM
0398   043F             ZPRINT  .EQU    09EH            ; PRINT
0399   043F             ZNEW    .EQU    0A4H            ; NEW
0400   043F             
0401   043F             ZTAB    .EQU    0A5H            ; TAB
0402   043F             ZTO     .EQU    0A6H            ; TO
0403   043F             ZFN     .EQU    0A7H            ; FN
0404   043F             ZSPC    .EQU    0A8H            ; SPC
0405   043F             ZTHEN   .EQU    0A9H            ; THEN
0406   043F             ZNOT    .EQU    0AAH            ; NOT
0407   043F             ZSTEP   .EQU    0ABH            ; STEP
0408   043F             
0409   043F             ZPLUS   .EQU    0ACH            ; +
0410   043F             ZMINUS  .EQU    0ADH            ; -
0411   043F             ZTIMES  .EQU    0AEH            ; *
0412   043F             ZDIV    .EQU    0AFH            ; /
0413   043F             ZOR     .EQU    0B2H            ; OR
0414   043F             ZGTR    .EQU    0B3H            ; >
0415   043F             ZEQUAL  .EQU    0B4H            ; M
0416   043F             ZLTH    .EQU    0B5H            ; <
0417   043F             ZSGN    .EQU    0B6H            ; SGN
0418   043F             ZPOINT  .EQU    0C7H            ; POINT
0419   043F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   043F             
0421   043F             ; ARITHMETIC PRECEDENCE TABLE
0422   043F             
0423   043F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   0440 75 19               .WORD   PADD            ; FPREG = <last> + FPREG
0425   0442             
0426   0442 79                  .BYTE   79H             ; Precedence value
0427   0443 A9 15               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   0445             
0429   0445 7C                  .BYTE   7CH             ; Precedence value
0430   0446 E7 16               .WORD   MULT            ; PPREG = <last> * FPREG
0431   0448             
0432   0448 7C                  .BYTE   7CH             ; Precedence value
0433   0449 48 17               .WORD   DIV             ; FPREG = <last> / FPREG
0434   044B             
0435   044B 7F                  .BYTE   7FH             ; Precedence value
0436   044C 96 1A               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   044E             
0438   044E 50                  .BYTE   50H             ; Precedence value
0439   044F 5C 0F               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   0451             
0441   0451 46                  .BYTE   46H             ; Precedence value
0442   0452 5B 0F               .WORD   POR             ; FPREG = <last> OR FPREG
0443   0454             
0444   0454             ; BASIC ERROR CODE LIST
0445   0454             
0446   0454 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   0456 53 4E               .BYTE   "SN"            ; Syntax error
0448   0458 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   045A 4F 44               .BYTE   "OD"            ; Out of DATA
0450   045C 46 43               .BYTE   "FC"            ; Illegal function call
0451   045E 4F 56               .BYTE   "OV"            ; Overflow error
0452   0460 4F 4D               .BYTE   "OM"            ; Out of memory
0453   0462 55 4C               .BYTE   "UL"            ; Undefined line
0454   0464 42 53               .BYTE   "BS"            ; Bad subscript
0455   0466 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   0468 2F 30               .BYTE   "/0"            ; Division by zero
0457   046A 49 44               .BYTE   "ID"            ; Illegal direct
0458   046C 54 4D               .BYTE   "TM"            ; Type mis-match
0459   046E 4F 53               .BYTE   "OS"            ; Out of string space
0460   0470 4C 53               .BYTE   "LS"            ; String too long
0461   0472 53 54               .BYTE   "ST"            ; String formula too complex
0462   0474 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   0476 55 46               .BYTE   "UF"            ; Undefined FN function
0464   0478 4D 4F               .BYTE   "MO"            ; Missing operand
0465   047A 48 58               .BYTE   "HX"            ; HEX error
0466   047C 42 4E               .BYTE   "BN"            ; BIN error
0467   047E             
0468   047E             ; INITIALISATION TABLE -------------------------------------------------------
0469   047E             
0470   047E C3 44 02    INITAB: JP      WARMST          ; Warm start jump
0471   0481 C3 6C 0A            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   0484 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   0486 C9                  RET
0474   0487 D6 00               SUB     0               ; Division support routine
0475   0489 6F                  LD      L,A
0476   048A 7C                  LD      A,H
0477   048B DE 00               SBC     A,0
0478   048D 67                  LD      H,A
0479   048E 78                  LD      A,B
0480   048F DE 00               SBC     A,0
0481   0491 47                  LD      B,A
0482   0492 3E 00               LD      A,0
0483   0494 C9                  RET
0484   0495 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   0498 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   049C 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   04A0 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   04A4 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   04A8 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   04AC 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   04B0 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   04B4 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   04B8 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   04BC DB 00               IN      A,(0)           ; INP (x) skeleton
0495   04BE C9                  RET
0496   04BF 01                  .BYTE   1               ; POS (x) number (1)
0497   04C0 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   04C1 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   04C2 00                  .BYTE   0               ; No nulls after input bytes
0500   04C3 00                  .BYTE   0               ; Output enabled (^O off)
0501   04C4 14 00               .WORD   20              ; Initial lines counter
0502   04C6 14 00               .WORD   20              ; Initial lines number
0503   04C8 00 00               .WORD   0               ; Array load/save check sum
0504   04CA 00                  .BYTE   0               ; Break not by NMI
0505   04CB 00                  .BYTE   0               ; Break flag
0506   04CC C3 92 07            JP      TTYLIN          ; Input reflection (set to TTY)
0507   04CF C3 00 00            JP      $0000           ; POINT reflection unused
0508   04D2 C3 00 00            JP      $0000           ; SET reflection
0509   04D5 C3 00 00            JP      $0000          	; RESET reflection
0510   04D8 A2 81               .WORD   STLOOK          ; Temp string space
0511   04DA FE FF               .WORD   -2              ; Current line number (cold)
0512   04DC 3F 81               .WORD   PROGST+1        ; Start of program text
0513   04DE             INITBE:
0514   04DE             
0515   04DE             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   04DE             
0517   04DE 204572726F72ERRMSG: .BYTE   " Error",0
0517   04E4 00
0518   04E5 20696E2000  INMSG:  .BYTE   " in ",0
0519   04EA             ZERBYT  .EQU    $-1             ; A zero byte
0520   04EA 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0521   04F0 427265616B00BRKMSG: .BYTE   "Break",0
0522   04F6             
0523   04F6 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   04F9 39                  ADD     HL,SP           ; same index as specified
0525   04FA 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   04FB 23                  INC     HL              ; Point to index address
0527   04FC FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   04FE C0                  RET     NZ              ; No - exit
0529   04FF 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   0500 23                  INC     HL
0531   0501 46                  LD      B,(HL)
0532   0502 23                  INC     HL              ; Point to sign of STEP
0533   0503 E5                  PUSH    HL              ; Save pointer to sign
0534   0504 69                  LD      L,C             ; HL = address of "FOR" index
0535   0505 60                  LD      H,B
0536   0506 7A                  LD      A,D             ; See if an index was specified
0537   0507 B3                  OR      E               ; DE = 0 if no index specified
0538   0508 EB                  EX      DE,HL           ; Specified index into HL
0539   0509 CA 10 05            JP      Z,INDFND        ; Skip if no index given
0540   050C EB                  EX      DE,HL           ; Index back into DE
0541   050D CD 15 08            CALL    CPDEHL          ; Compare index with one given
0542   0510 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   0513 E1                  POP     HL              ; Restore pointer to sign
0544   0514 C8                  RET     Z               ; Return if block found
0545   0515 09                  ADD     HL,BC           ; Point to next block
0546   0516 C3 FA 04            JP      LOKFOR          ; Keep on looking
0547   0519             
0548   0519 CD 33 05    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   051C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   051D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   051E C1                  POP     BC              ; Get end of destination
0552   051F CD 15 08    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   0522 7E                  LD      A,(HL)          ; Get byte
0554   0523 02                  LD      (BC),A          ; Move it
0555   0524 C8                  RET     Z               ; Exit if all done
0556   0525 0B                  DEC     BC              ; Next byte to move to
0557   0526 2B                  DEC     HL              ; Next byte to move
0558   0527 C3 1F 05            JP      MOVLP           ; Loop until all bytes moved
0559   052A             
0560   052A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   052B 2A 1F 81            LD      HL,(ARREND)     ; Lowest free memory
0562   052E 06 00               LD      B,0             ; BC = Number of levels to test
0563   0530 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   0531 09                  ADD     HL,BC
0565   0532 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   0533 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   0534 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   0536 95                  SUB     L
0569   0537 6F                  LD      L,A
0570   0538 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   053A 9C                  SBC     A,H
0572   053B DA 42 05            JP      C,OMERR         ; Not enough - ?OM Error
0573   053E 67                  LD      H,A
0574   053F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   0540 E1                  POP     HL              ; Restore code string address
0576   0541 D8                  RET     C               ; Return if enough mmory
0577   0542 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   0544 C3 61 05            JP      ERROR
0579   0547             
0580   0547 2A 0E 81    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   054A 22 A1 80            LD      (LINEAT),HL     ; Save as current line
0582   054D 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   054F 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   0550 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   0552 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   0553 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   0555 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   0556 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   0558 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   0559 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   055B 01                  .BYTE   01H             ; Skip "LD E,OV
0592   055C 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   055E 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   055F 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   0561             
0596   0561 CD 7F 06    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   0564 32 8A 80            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   0567 CD 40 0C            CALL    STTLIN          ; Start new line
0599   056A 21 54 04            LD      HL,ERRORS       ; Point to error codes
0600   056D 57                  LD      D,A             ; D = 0 (A is 0)
0601   056E 3E 3F               LD      A,'?'
0602   0570 CD 26 08            CALL    OUTC            ; Output '?'
0603   0573 19                  ADD     HL,DE           ; Offset to correct error code
0604   0574 7E                  LD      A,(HL)          ; First character
0605   0575 CD 26 08            CALL    OUTC            ; Output it
0606   0578 CD A5 09            CALL    GETCHR          ; Get next character
0607   057B CD 26 08            CALL    OUTC            ; Output it
0608   057E 21 DE 04            LD      HL,ERRMSG       ; "Error" message
0609   0581 CD EB 12    ERRIN:  CALL    PRS             ; Output message
0610   0584 2A A1 80            LD      HL,(LINEAT)     ; Get line of error
0611   0587 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   058A CD 15 08            CALL    CPDEHL          ; See if cold start error
0613   058D CA B1 01            JP      Z,CSTART        ; Cold start error - Restart
0614   0590 7C                  LD      A,H             ; Was it a direct error?
0615   0591 A5                  AND     L               ; Line = -1 if direct error
0616   0592 3C                  INC     A
0617   0593 C4 86 19            CALL    NZ,LINEIN       ; No - output line of error
0618   0596 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   0597 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   0598             
0621   0598 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   0599 32 8A 80            LD      (CTLOFG),A      ; Enable output
0623   059C CD 40 0C            CALL    STTLIN          ; Start new line
0624   059F 21 EA 04            LD      HL,OKMSG        ; "Ok" message
0625   05A2 CD EB 12            CALL    PRS             ; Output "Ok"
0626   05A5 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   05A8 22 A1 80            LD      (LINEAT),HL     ; Save as current line
0628   05AB CD 92 07            CALL    GETLIN          ; Get an input line
0629   05AE DA A5 05            JP      C,GETCMD        ; Get line again if break
0630   05B1 CD A5 09            CALL    GETCHR          ; Get first character
0631   05B4 3C                  INC     A               ; Test if end of line
0632   05B5 3D                  DEC     A               ; Without affecting Carry
0633   05B6 CA A5 05            JP      Z,GETCMD        ; Nothing entered - Get another
0634   05B9 F5                  PUSH    AF              ; Save Carry status
0635   05BA CD 71 0A            CALL    ATOH            ; Get line number into DE
0636   05BD D5                  PUSH    DE              ; Save line number
0637   05BE CD A9 06            CALL    CRUNCH          ; Tokenise rest of line
0638   05C1 47                  LD      B,A             ; Length of tokenised line
0639   05C2 D1                  POP     DE              ; Restore line number
0640   05C3 F1                  POP     AF              ; Restore Carry
0641   05C4 D2 85 09            JP      NC,EXCUTE       ; No line number - Direct mode
0642   05C7 D5                  PUSH    DE              ; Save line number
0643   05C8 C5                  PUSH    BC              ; Save length of tokenised line
0644   05C9 AF                  XOR     A
0645   05CA 32 11 81            LD      (LSTBIN),A      ; Clear last byte input
0646   05CD CD A5 09            CALL    GETCHR          ; Get next character
0647   05D0 B7                  OR      A               ; Set flags
0648   05D1 F5                  PUSH    AF              ; And save them
0649   05D2 CD 39 06            CALL    SRCHLN          ; Search for line number in DE
0650   05D5 DA DE 05            JP      C,LINFND        ; Jump if line found
0651   05D8 F1                  POP     AF              ; Get status
0652   05D9 F5                  PUSH    AF              ; And re-save
0653   05DA CA 12 0B            JP      Z,ULERR         ; Nothing after number - Error
0654   05DD B7                  OR      A               ; Clear Carry
0655   05DE C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   05DF D2 F5 05            JP      NC,INEWLN       ; Line not found - Insert new
0657   05E2 EB                  EX      DE,HL           ; Next line address in DE
0658   05E3 2A 1B 81            LD      HL,(PROGND)     ; End of program
0659   05E6 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   05E7 02                  LD      (BC),A
0661   05E8 03                  INC     BC              ; Next destination
0662   05E9 13                  INC     DE              ; Next source
0663   05EA CD 15 08            CALL    CPDEHL          ; All done?
0664   05ED C2 E6 05            JP      NZ,SFTPRG       ; More to do
0665   05F0 60                  LD      H,B             ; HL - New end of program
0666   05F1 69                  LD      L,C
0667   05F2 22 1B 81            LD      (PROGND),HL     ; Update end of program
0668   05F5             
0669   05F5 D1          INEWLN: POP     DE              ; Get address of line,
0670   05F6 F1                  POP     AF              ; Get status
0671   05F7 CA 1C 06            JP      Z,SETPTR        ; No text - Set up pointers
0672   05FA 2A 1B 81            LD      HL,(PROGND)     ; Get end of program
0673   05FD E3                  EX      (SP),HL         ; Get length of input line
0674   05FE C1                  POP     BC              ; End of program to BC
0675   05FF 09                  ADD     HL,BC           ; Find new end
0676   0600 E5                  PUSH    HL              ; Save new end
0677   0601 CD 19 05            CALL    MOVUP           ; Make space for line
0678   0604 E1                  POP     HL              ; Restore new end
0679   0605 22 1B 81            LD      (PROGND),HL     ; Update end of program pointer
0680   0608 EB                  EX      DE,HL           ; Get line to move up in HL
0681   0609 74                  LD      (HL),H          ; Save MSB
0682   060A D1                  POP     DE              ; Get new line number
0683   060B 23                  INC     HL              ; Skip pointer
0684   060C 23                  INC     HL
0685   060D 73                  LD      (HL),E          ; Save LSB of line number
0686   060E 23                  INC     HL
0687   060F 72                  LD      (HL),D          ; Save MSB of line number
0688   0610 23                  INC     HL              ; To first byte in line
0689   0611 11 A6 80            LD      DE,BUFFER       ; Copy buffer to program
0690   0614 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   0615 77                  LD      (HL),A          ; Save destinations
0692   0616 23                  INC     HL              ; Next source
0693   0617 13                  INC     DE              ; Next destination
0694   0618 B7                  OR      A               ; Done?
0695   0619 C2 14 06            JP      NZ,MOVBUF       ; No - Repeat
0696   061C CD 65 06    SETPTR: CALL    RUNFST          ; Set line pointers
0697   061F 23                  INC     HL              ; To LSB of pointer
0698   0620 EB                  EX      DE,HL           ; Address to DE
0699   0621 62          PTRLP:  LD      H,D             ; Address to HL
0700   0622 6B                  LD      L,E
0701   0623 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   0624 23                  INC     HL              ; To MSB of pointer
0703   0625 B6                  OR      (HL)            ; Compare with MSB pointer
0704   0626 CA A5 05            JP      Z,GETCMD        ; Get command line if end
0705   0629 23                  INC     HL              ; To LSB of line number
0706   062A 23                  INC     HL              ; Skip line number
0707   062B 23                  INC     HL              ; Point to first byte in line
0708   062C AF                  XOR     A               ; Looking for 00 byte
0709   062D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   062E 23                  INC     HL              ; Move to next byte
0711   062F C2 2D 06            JP      NZ,FNDEND       ; No - Keep looking
0712   0632 EB                  EX      DE,HL           ; Next line address to HL
0713   0633 73                  LD      (HL),E          ; Save LSB of pointer
0714   0634 23                  INC     HL
0715   0635 72                  LD      (HL),D          ; Save MSB of pointer
0716   0636 C3 21 06            JP      PTRLP           ; Do next line
0717   0639             
0718   0639 2A A3 80    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   063C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   063D 4D                  LD      C,L
0721   063E 7E                  LD      A,(HL)          ; Get address of next line
0722   063F 23                  INC     HL
0723   0640 B6                  OR      (HL)            ; End of program found?
0724   0641 2B                  DEC     HL
0725   0642 C8                  RET     Z               ; Yes - Line not found
0726   0643 23                  INC     HL
0727   0644 23                  INC     HL
0728   0645 7E                  LD      A,(HL)          ; Get LSB of line number
0729   0646 23                  INC     HL
0730   0647 66                  LD      H,(HL)          ; Get MSB of line number
0731   0648 6F                  LD      L,A
0732   0649 CD 15 08            CALL    CPDEHL          ; Compare with line in DE
0733   064C 60                  LD      H,B             ; HL = Start of this line
0734   064D 69                  LD      L,C
0735   064E 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   064F 23                  INC     HL
0737   0650 66                  LD      H,(HL)          ; Get MSB of next line address
0738   0651 6F                  LD      L,A             ; Next line to HL
0739   0652 3F                  CCF
0740   0653 C8                  RET     Z               ; Lines found - Exit
0741   0654 3F                  CCF
0742   0655 D0                  RET     NC              ; Line not found,at line after
0743   0656 C3 3C 06            JP      SRCHLP          ; Keep looking
0744   0659             
0745   0659 C0          NEW:    RET     NZ              ; Return if any more on line
0746   065A 2A A3 80    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   065D AF                  XOR     A               ; Set program area to empty
0748   065E 77                  LD      (HL),A          ; Save LSB = 00
0749   065F 23                  INC     HL
0750   0660 77                  LD      (HL),A          ; Save MSB = 00
0751   0661 23                  INC     HL
0752   0662 22 1B 81            LD      (PROGND),HL     ; Set program end
0753   0665             
0754   0665 2A A3 80    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   0668 2B                  DEC     HL
0756   0669             
0757   0669 22 13 81    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   066C 2A F4 80            LD      HL,(LSTRAM)     ; Get end of RAM
0759   066F 22 08 81            LD      (STRBOT),HL     ; Clear string space
0760   0672 AF                  XOR     A
0761   0673 CD B5 09            CALL    RESTOR          ; Reset DATA pointers
0762   0676 2A 1B 81            LD      HL,(PROGND)     ; Get end of program
0763   0679 22 1D 81            LD      (VAREND),HL     ; Clear variables
0764   067C 22 1F 81            LD      (ARREND),HL     ; Clear arrays
0765   067F             
0766   067F C1          CLREG:  POP     BC              ; Save return address
0767   0680 2A 9F 80            LD      HL,(STRSPC)     ; Get end of working RAN
0768   0683 F9                  LD      SP,HL           ; Set stack
0769   0684 21 F8 80            LD      HL,TMSTPL       ; Temporary string pool
0770   0687 22 F6 80            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   068A AF                  XOR     A               ; A = 00
0772   068B 6F                  LD      L,A             ; HL = 0000
0773   068C 67                  LD      H,A
0774   068D 22 19 81            LD      (CONTAD),HL     ; No CONTinue
0775   0690 32 10 81            LD      (FORFLG),A      ; Clear FOR flag
0776   0693 22 23 81            LD      (FNRGNM),HL     ; Clear FN argument
0777   0696 E5                  PUSH    HL              ; HL = 0000
0778   0697 C5                  PUSH    BC              ; Put back return
0779   0698 2A 13 81    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   069B C9                  RET                     ; Return to execution driver
0781   069C             
0782   069C 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   069E CD 26 08            CALL    OUTC            ; Output character
0784   06A1 3E 20               LD      A,' '           ; Space
0785   06A3 CD 26 08            CALL    OUTC            ; Output character
0786   06A6 C3 93 80            JP      RINPUT          ; Get input line
0787   06A9             
0788   06A9 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   06AA 32 F3 80            LD      (DATFLG),A      ; Reset literal flag
0790   06AD 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   06AF 11 A6 80            LD      DE,BUFFER       ; Start of input buffer
0792   06B2 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   06B3 FE 20               CP      ' '             ; Is it a space?
0794   06B5 CA 31 07            JP      Z,MOVDIR        ; Yes - Copy direct
0795   06B8 47                  LD      B,A             ; Save character
0796   06B9 FE 22               CP      '"'             ; Is it a quote?
0797   06BB CA 51 07            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   06BE B7                  OR      A               ; Is it end of buffer?
0799   06BF CA 58 07            JP      Z,ENDBUF        ; Yes - End buffer
0800   06C2 3A F3 80            LD      A,(DATFLG)      ; Get data type
0801   06C5 B7                  OR      A               ; Literal?
0802   06C6 7E                  LD      A,(HL)          ; Get byte to copy
0803   06C7 C2 31 07            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   06CA FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   06CC 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   06CE CA 31 07            JP      Z,MOVDIR        ; Yes - replace it
0807   06D1 7E                  LD      A,(HL)          ; Get byte again
0808   06D2 FE 30               CP      '0'             ; Is it less than '0'
0809   06D4 DA DC 06            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   06D7 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   06D9 DA 31 07            JP      C,MOVDIR        ; Yes - copy it direct
0812   06DC D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   06DD 11 D5 02            LD      DE,WORDS-1      ; Point to table
0814   06E0 C5                  PUSH    BC              ; Save count
0815   06E1 01 2D 07            LD      BC,RETNAD       ; Where to return to
0816   06E4 C5                  PUSH    BC              ; Save return address
0817   06E5 06 7F               LD      B,ZEND-1        ; First token value -1
0818   06E7 7E                  LD      A,(HL)          ; Get byte
0819   06E8 FE 61               CP      'a'             ; Less than 'a' ?
0820   06EA DA F5 06            JP      C,SEARCH        ; Yes - search for words
0821   06ED FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   06EF D2 F5 06            JP      NC,SEARCH       ; Yes - search for words
0823   06F2 E6 5F               AND     01011111B       ; Force upper case
0824   06F4 77                  LD      (HL),A          ; Replace byte
0825   06F5 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   06F6 EB                  EX      DE,HL
0827   06F7 23          GETNXT: INC     HL              ; Get next reserved word
0828   06F8 B6                  OR      (HL)            ; Start of word?
0829   06F9 F2 F7 06            JP      P,GETNXT        ; No - move on
0830   06FC 04                  INC     B               ; Increment token value
0831   06FD 7E                  LD      A, (HL)         ; Get byte from table
0832   06FE E6 7F               AND     01111111B       ; Strip bit 7
0833   0700 C8                  RET     Z               ; Return if end of list
0834   0701 B9                  CP      C               ; Same character as in buffer?
0835   0702 C2 F7 06            JP      NZ,GETNXT       ; No - get next word
0836   0705 EB                  EX      DE,HL
0837   0706 E5                  PUSH    HL              ; Save start of word
0838   0707             
0839   0707 13          NXTBYT: INC     DE              ; Look through rest of word
0840   0708 1A                  LD      A,(DE)          ; Get byte from table
0841   0709 B7                  OR      A               ; End of word ?
0842   070A FA 29 07            JP      M,MATCH         ; Yes - Match found
0843   070D 4F                  LD      C,A             ; Save it
0844   070E 78                  LD      A,B             ; Get token value
0845   070F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   0711 C2 18 07            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   0714 CD A5 09            CALL    GETCHR          ; Get next character
0848   0717 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   0718 23          NOSPC:  INC     HL              ; Next byte
0850   0719 7E                  LD      A,(HL)          ; Get byte
0851   071A FE 61               CP      'a'             ; Less than 'a' ?
0852   071C DA 21 07            JP      C,NOCHNG        ; Yes - don't change
0853   071F E6 5F               AND     01011111B       ; Make upper case
0854   0721 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   0722 CA 07 07            JP      Z,NXTBYT        ; Yes - keep testing
0856   0725 E1                  POP     HL              ; Get back start of word
0857   0726 C3 F5 06            JP      SEARCH          ; Look at next word
0858   0729             
0859   0729 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   072A F1                  POP     AF              ; Throw away return
0861   072B EB                  EX      DE,HL
0862   072C C9                  RET                     ; Return to "RETNAD"
0863   072D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   072E 79                  LD      A,C             ; Get token value
0865   072F C1                  POP     BC              ; Restore buffer length
0866   0730 D1                  POP     DE              ; Get destination address
0867   0731 23          MOVDIR: INC     HL              ; Next source in buffer
0868   0732 12                  LD      (DE),A          ; Put byte in buffer
0869   0733 13                  INC     DE              ; Move up buffer
0870   0734 0C                  INC     C               ; Increment length of buffer
0871   0735 D6 3A               SUB     ':'             ; End of statement?
0872   0737 CA 3F 07            JP      Z,SETLIT        ; Jump if multi-statement line
0873   073A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   073C C2 42 07            JP      NZ,TSTREM       ; No - see if REM
0875   073F 32 F3 80    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   0742 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   0744 C2 B2 06            JP      NZ,CRNCLP       ; No - Leave flag
0878   0747 47                  LD      B,A             ; Copy rest of buffer
0879   0748 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   0749 B7                  OR      A               ; End of line ?
0881   074A CA 58 07            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   074D B8                  CP      B               ; End of statement ?
0883   074E CA 31 07            JP      Z,MOVDIR        ; Yes - Get next one
0884   0751 23          CPYLIT: INC     HL              ; Move up source string
0885   0752 12                  LD      (DE),A          ; Save in destination
0886   0753 0C                  INC     C               ; Increment length
0887   0754 13                  INC     DE              ; Move up destination
0888   0755 C3 48 07            JP      NXTCHR          ; Repeat
0889   0758             
0890   0758 21 A5 80    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   075B 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   075C 13                  INC     DE
0893   075D 12                  LD      (DE),A          ; A = 00
0894   075E 13                  INC     DE
0895   075F 12                  LD      (DE),A          ; A = 00
0896   0760 C9                  RET
0897   0761             
0898   0761 3A 89 80    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   0764 B7                  OR      A               ; Is it zero?
0900   0765 3E 00               LD      A,0             ; Zero A - Leave flags
0901   0767 32 89 80            LD      (NULFLG),A      ; Zero null flag
0902   076A C2 75 07            JP      NZ,ECHDEL       ; Set - Echo it
0903   076D 05                  DEC     B               ; Decrement length
0904   076E CA 92 07            JP      Z,GETLIN        ; Get line again if empty
0905   0771 CD 26 08            CALL    OUTC            ; Output null character
0906   0774 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   0775 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   0776 2B                  DEC     HL              ; Back space buffer
0909   0777 CA 89 07            JP      Z,OTKLN         ; No buffer - Try again
0910   077A 7E                  LD      A,(HL)          ; Get deleted byte
0911   077B CD 26 08            CALL    OUTC            ; Echo it
0912   077E C3 9B 07            JP      MORINP          ; Get more input
0913   0781             
0914   0781 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   0782 2B                  DEC     HL              ; Back space buffer
0916   0783 CD 26 08            CALL    OUTC            ; Output character in A
0917   0786 C2 9B 07            JP      NZ,MORINP       ; Not end - Get more
0918   0789 CD 26 08    OTKLN:  CALL    OUTC            ; Output character in A
0919   078C CD 4D 0C    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   078F C3 92 07            JP      TTYLIN          ; Get line again
0921   0792             
0922   0792             GETLIN:
0923   0792 21 A6 80    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   0795 06 01               LD      B,1             ; Set buffer as empty
0925   0797 AF                  XOR     A
0926   0798 32 89 80            LD      (NULFLG),A      ; Clear null flag
0927   079B CD 50 08    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   079E 4F                  LD      C,A             ; Save character in C
0929   079F FE 7F               CP      DEL             ; Delete character?
0930   07A1 CA 61 07            JP      Z,DODEL         ; Yes - Process it
0931   07A4 3A 89 80            LD      A,(NULFLG)      ; Get null flag
0932   07A7 B7                  OR      A               ; Test null flag status
0933   07A8 CA B4 07            JP      Z,PROCES        ; Reset - Process character
0934   07AB 3E 00               LD      A,0             ; Set a null
0935   07AD CD 26 08            CALL    OUTC            ; Output null
0936   07B0 AF                  XOR     A               ; Clear A
0937   07B1 32 89 80            LD      (NULFLG),A      ; Reset null flag
0938   07B4 79          PROCES: LD      A,C             ; Get character
0939   07B5 FE 07               CP      CTRLG           ; Bell?
0940   07B7 CA F8 07            JP      Z,PUTCTL        ; Yes - Save it
0941   07BA FE 03               CP      CTRLC           ; Is it control "C"?
0942   07BC CC 4D 0C            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   07BF 37                  SCF                     ; Flag break
0944   07C0 C8                  RET     Z               ; Return if control "C"
0945   07C1 FE 0D               CP      CR              ; Is it enter?
0946   07C3 CA 48 0C            JP      Z,ENDINP        ; Yes - Terminate input
0947   07C6 FE 15               CP      CTRLU           ; Is it control "U"?
0948   07C8 CA 8C 07            JP      Z,KILIN         ; Yes - Get another line
0949   07CB FE 40               CP      '@'             ; Is it "kill line"?
0950   07CD CA 89 07            JP      Z,OTKLN         ; Yes - Kill line
0951   07D0 FE 5F               CP      '_'             ; Is it delete?
0952   07D2 CA 81 07            JP      Z,DELCHR        ; Yes - Delete character
0953   07D5 FE 08               CP      BKSP            ; Is it backspace?
0954   07D7 CA 81 07            JP      Z,DELCHR        ; Yes - Delete character
0955   07DA FE 12               CP      CTRLR           ; Is it control "R"?
0956   07DC C2 F3 07            JP      NZ,PUTBUF       ; No - Put in buffer
0957   07DF C5                  PUSH    BC              ; Save buffer length
0958   07E0 D5                  PUSH    DE              ; Save DE
0959   07E1 E5                  PUSH    HL              ; Save buffer address
0960   07E2 36 00               LD      (HL),0          ; Mark end of buffer
0961   07E4 CD FD 1D            CALL    OUTNCR          ; Output and do CRLF
0962   07E7 21 A6 80            LD      HL,BUFFER       ; Point to buffer start
0963   07EA CD EB 12            CALL    PRS             ; Output buffer
0964   07ED E1                  POP     HL              ; Restore buffer address
0965   07EE D1                  POP     DE              ; Restore DE
0966   07EF C1                  POP     BC              ; Restore buffer length
0967   07F0 C3 9B 07            JP      MORINP          ; Get another character
0968   07F3             
0969   07F3 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   07F5 DA 9B 07            JP      C,MORINP        ; Yes - Ignore
0971   07F8 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   07F9 FE 49               CP      72+1            ; Test for line overflow
0973   07FB 3E 07               LD      A,CTRLG         ; Set a bell
0974   07FD D2 0D 08            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   0800 79                  LD      A,C             ; Get character
0976   0801 71                  LD      (HL),C          ; Save in buffer
0977   0802 32 11 81            LD      (LSTBIN),A      ; Save last input byte
0978   0805 23                  INC     HL              ; Move up buffer
0979   0806 04                  INC     B               ; Increment length
0980   0807 CD 26 08    OUTIT:  CALL    OUTC            ; Output the character entered
0981   080A C3 9B 07            JP      MORINP          ; Get another character
0982   080D             
0983   080D CD 26 08    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   0810 3E 08               LD      A,BKSP          ; Set back space
0985   0812 C3 07 08            JP      OUTIT           ; Output it and get more
0986   0815             
0987   0815 7C          CPDEHL: LD      A,H             ; Get H
0988   0816 92                  SUB     D               ; Compare with D
0989   0817 C0                  RET     NZ              ; Different - Exit
0990   0818 7D                  LD      A,L             ; Get L
0991   0819 93                  SUB     E               ; Compare with E
0992   081A C9                  RET                     ; Return status
0993   081B             
0994   081B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   081C E3                  EX      (SP),HL         ; Address of test byte
0996   081D BE                  CP      (HL)            ; Same as in code string?
0997   081E 23                  INC     HL              ; Return address
0998   081F E3                  EX      (SP),HL         ; Put it back
0999   0820 CA A5 09            JP      Z,GETCHR        ; Yes - Get next character
1000   0823 C3 4D 05            JP      SNERR           ; Different - ?SN Error
1001   0826             
1002   0826 F5          OUTC:   PUSH    AF              ; Save character
1003   0827 3A 8A 80            LD      A,(CTLOFG)      ; Get control "O" flag
1004   082A B7                  OR      A               ; Is it set?
1005   082B C2 20 13            JP      NZ,POPAF        ; Yes - don't output
1006   082E F1                  POP     AF              ; Restore character
1007   082F C5                  PUSH    BC              ; Save buffer length
1008   0830 F5                  PUSH    AF              ; Save character
1009   0831 FE 20               CP      ' '             ; Is it a control code?
1010   0833 DA 4A 08            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   0836 3A 87 80            LD      A,(LWIDTH)      ; Get line width
1012   0839 47                  LD      B,A             ; To B
1013   083A 3A F0 80            LD      A,(CURPOS)      ; Get cursor position
1014   083D 04                  INC     B               ; Width 255?
1015   083E CA 46 08            JP      Z,INCLEN        ; Yes - No width limit
1016   0841 05                  DEC     B               ; Restore width
1017   0842 B8                  CP      B               ; At end of line?
1018   0843 CC 4D 0C            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   0846 3C          INCLEN: INC     A               ; Move on one character
1020   0847 32 F0 80            LD      (CURPOS),A      ; Save new position
1021   084A F1          DINPOS: POP     AF              ; Restore character
1022   084B C1                  POP     BC              ; Restore buffer length
1023   084C CD E6 1D            CALL    MONOUT          ; Send it
1024   084F C9                  RET
1025   0850             
1026   0850 CD AA 1C    CLOTST: CALL    GETINP          ; Get input character
1027   0853 E6 7F               AND     01111111B       ; Strip bit 7
1028   0855 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   0857 C0                  RET     NZ              ; No don't flip flag
1030   0858 3A 8A 80            LD      A,(CTLOFG)      ; Get flag
1031   085B 2F                  CPL                     ; Flip it
1032   085C 32 8A 80            LD      (CTLOFG),A      ; Put it back
1033   085F AF                  XOR     A               ; Null character
1034   0860 C9                  RET
1035   0861             
1036   0861 CD 71 0A    LIST:   CALL    ATOH            ; ASCII number to DE
1037   0864 C0                  RET     NZ              ; Return if anything extra
1038   0865 C1                  POP     BC              ; Rubbish - Not needed
1039   0866 CD 39 06            CALL    SRCHLN          ; Search for line number in DE
1040   0869 C5                  PUSH    BC              ; Save address of line
1041   086A CD B7 08            CALL    SETLIN          ; Set up lines counter
1042   086D E1          LISTLP: POP     HL              ; Restore address of line
1043   086E 4E                  LD      C,(HL)          ; Get LSB of next line
1044   086F 23                  INC     HL
1045   0870 46                  LD      B,(HL)          ; Get MSB of next line
1046   0871 23                  INC     HL
1047   0872 78                  LD      A,B             ; BC = 0 (End of program)?
1048   0873 B1                  OR      C
1049   0874 CA 98 05            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   0877 CD C0 08            CALL    COUNT           ; Count lines
1051   087A CD D0 09            CALL    TSTBRK          ; Test for break key
1052   087D C5                  PUSH    BC              ; Save address of next line
1053   087E CD 4D 0C            CALL    PRNTCRLF        ; Output CRLF
1054   0881 5E                  LD      E,(HL)          ; Get LSB of line number
1055   0882 23                  INC     HL
1056   0883 56                  LD      D,(HL)          ; Get MSB of line number
1057   0884 23                  INC     HL
1058   0885 E5                  PUSH    HL              ; Save address of line start
1059   0886 EB                  EX      DE,HL           ; Line number to HL
1060   0887 CD 8E 19            CALL    PRNTHL          ; Output line number in decimal
1061   088A 3E 20               LD      A,' '           ; Space after line number
1062   088C E1                  POP     HL              ; Restore start of line address
1063   088D CD 26 08    LSTLP2: CALL    OUTC            ; Output character in A
1064   0890 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   0891 B7                  OR      A               ; End of line?
1066   0892 23                  INC     HL              ; To next byte in line
1067   0893 CA 6D 08            JP      Z,LISTLP        ; Yes - get next line
1068   0896 F2 8D 08            JP      P,LSTLP2        ; No token - output it
1069   0899 D6 7F               SUB     ZEND-1          ; Find and output word
1070   089B 4F                  LD      C,A             ; Token offset+1 to C
1071   089C 11 D6 02            LD      DE,WORDS        ; Reserved word list
1072   089F 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   08A0 13                  INC     DE              ; Move on to next
1074   08A1 B7                  OR      A               ; Is it start of word?
1075   08A2 F2 9F 08            JP      P,FNDTOK        ; No - Keep looking for word
1076   08A5 0D                  DEC     C               ; Count words
1077   08A6 C2 9F 08            JP      NZ,FNDTOK       ; Not there - keep looking
1078   08A9 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   08AB CD 26 08            CALL    OUTC            ; Output first character
1080   08AE 1A                  LD      A,(DE)          ; Get next character
1081   08AF 13                  INC     DE              ; Move on to next
1082   08B0 B7                  OR      A               ; Is it end of word?
1083   08B1 F2 A9 08            JP      P,OUTWRD        ; No - output the rest
1084   08B4 C3 90 08            JP      LSTLP3          ; Next byte in line
1085   08B7             
1086   08B7 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   08B8 2A 8D 80            LD      HL,(LINESN)     ; Get LINES number
1088   08BB 22 8B 80            LD      (LINESC),HL     ; Save in LINES counter
1089   08BE E1                  POP     HL
1090   08BF C9                  RET
1091   08C0             
1092   08C0 E5          COUNT:  PUSH    HL              ; Save code string address
1093   08C1 D5                  PUSH    DE
1094   08C2 2A 8B 80            LD      HL,(LINESC)     ; Get LINES counter
1095   08C5 11 FF FF            LD      DE,-1
1096   08C8 ED 5A               ADC     HL,DE           ; Decrement
1097   08CA 22 8B 80            LD      (LINESC),HL     ; Put it back
1098   08CD D1                  POP     DE
1099   08CE E1                  POP     HL              ; Restore code string address
1100   08CF F0                  RET     P               ; Return if more lines to go
1101   08D0 E5                  PUSH    HL              ; Save code string address
1102   08D1 2A 8D 80            LD      HL,(LINESN)     ; Get LINES number
1103   08D4 22 8B 80            LD      (LINESC),HL     ; Reset LINES counter
1104   08D7 CD AA 1C            CALL    GETINP          ; Get input character
1105   08DA FE 03               CP      CTRLC           ; Is it control "C"?
1106   08DC CA E3 08            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   08DF E1                  POP     HL              ; Restore code string address
1108   08E0 C3 C0 08            JP      COUNT           ; Keep on counting
1109   08E3             
1110   08E3 2A 8D 80    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   08E6 22 8B 80            LD      (LINESC),HL     ; Reset LINES counter
1112   08E9 C3 47 02            JP      BRKRET          ; Go and output "Break"
1113   08EC             
1114   08EC 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   08EE 32 10 81            LD      (FORFLG),A      ; Save "FOR" flag
1116   08F1 CD 53 0B            CALL    LET             ; Set up initial index
1117   08F4 C1                  POP     BC              ; Drop RETurn address
1118   08F5 E5                  PUSH    HL              ; Save code string address
1119   08F6 CD 3C 0B            CALL    DATA            ; Get next statement address
1120   08F9 22 0C 81            LD      (LOOPST),HL     ; Save it for start of loop
1121   08FC 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   08FF 39                  ADD     HL,SP           ; Point to it
1123   0900 CD FA 04    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   0903 D1                  POP     DE              ; Get code string address
1125   0904 C2 1C 09            JP      NZ,FORFND       ; No nesting found
1126   0907 09                  ADD     HL,BC           ; Move into "FOR" block
1127   0908 D5                  PUSH    DE              ; Save code string address
1128   0909 2B                  DEC     HL
1129   090A 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   090B 2B                  DEC     HL
1131   090C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   090D 23                  INC     HL
1133   090E 23                  INC     HL
1134   090F E5                  PUSH    HL              ; Save block address
1135   0910 2A 0C 81            LD      HL,(LOOPST)     ; Get address of loop statement
1136   0913 CD 15 08            CALL    CPDEHL          ; Compare the FOR loops
1137   0916 E1                  POP     HL              ; Restore block address
1138   0917 C2 00 09            JP      NZ,FORSLP       ; Different FORs - Find another
1139   091A D1                  POP     DE              ; Restore code string address
1140   091B F9                  LD      SP,HL           ; Remove all nested loops
1141   091C             
1142   091C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   091D 0E 08               LD      C,8
1144   091F CD 2A 05            CALL    CHKSTK          ; Check for 8 levels of stack
1145   0922 E5                  PUSH    HL              ; Save code string address
1146   0923 2A 0C 81            LD      HL,(LOOPST)     ; Get first statement of loop
1147   0926 E3                  EX      (SP),HL         ; Save and restore code string
1148   0927 E5                  PUSH    HL              ; Re-save code string address
1149   0928 2A A1 80            LD      HL,(LINEAT)     ; Get current line number
1150   092B E3                  EX      (SP),HL         ; Save and restore code string
1151   092C CD 15 0E            CALL    TSTNUM          ; Make sure it's a number
1152   092F CD 1B 08            CALL    CHKSYN          ; Make sure "TO" is next
1153   0932 A6                  .BYTE   ZTO          ; "TO" token
1154   0933 CD 12 0E            CALL    GETNUM          ; Get "TO" expression value
1155   0936 E5                  PUSH    HL              ; Save code string address
1156   0937 CD 40 18            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   093A E1                  POP     HL              ; Restore code string address
1158   093B C5                  PUSH    BC              ; Save "TO" value in block
1159   093C D5                  PUSH    DE
1160   093D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   0940 51                  LD      D,C             ; C=0
1162   0941 5A                  LD      E,D             ; D=0
1163   0942 7E                  LD      A,(HL)          ; Get next byte in code string
1164   0943 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   0945 3E 01               LD      A,1             ; Sign of step = 1
1166   0947 C2 58 09            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   094A CD A5 09            CALL    GETCHR          ; Jump over "STEP" token
1168   094D CD 12 0E            CALL    GETNUM          ; Get step value
1169   0950 E5                  PUSH    HL              ; Save code string address
1170   0951 CD 40 18            CALL    BCDEFP          ; Move STEP to BCDE
1171   0954 CD F4 17            CALL    TSTSGN          ; Test sign of FPREG
1172   0957 E1                  POP     HL              ; Restore code string address
1173   0958 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   0959 D5                  PUSH    DE
1175   095A F5                  PUSH    AF              ; Save sign of STEP
1176   095B 33                  INC     SP              ; Don't save flags
1177   095C E5                  PUSH    HL              ; Save code string address
1178   095D 2A 13 81            LD      HL,(BRKLIN)     ; Get address of index variable
1179   0960 E3                  EX      (SP),HL         ; Save and restore code string
1180   0961 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   0963 C5                  PUSH    BC              ; Save it
1182   0964 33                  INC     SP              ; Don't save C
1183   0965             
1184   0965 CD D0 09    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   0968 22 13 81            LD      (BRKLIN),HL     ; Save code address for break
1186   096B 7E                  LD      A,(HL)          ; Get next byte in code string
1187   096C FE 3A               CP      ':'             ; Multi statement line?
1188   096E CA 85 09            JP      Z,EXCUTE        ; Yes - Execute it
1189   0971 B7                  OR      A               ; End of line?
1190   0972 C2 4D 05            JP      NZ,SNERR        ; No - Syntax error
1191   0975 23                  INC     HL              ; Point to address of next line
1192   0976 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   0977 23                  INC     HL
1194   0978 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   0979 CA F7 09            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   097C 23                  INC     HL              ; Point to line number
1197   097D 5E                  LD      E,(HL)          ; Get LSB of line number
1198   097E 23                  INC     HL
1199   097F 56                  LD      D,(HL)          ; Get MSB of line number
1200   0980 EB                  EX      DE,HL           ; Line number to HL
1201   0981 22 A1 80            LD      (LINEAT),HL     ; Save as current line number
1202   0984 EB                  EX      DE,HL           ; Line number back to DE
1203   0985 CD A5 09    EXCUTE: CALL    GETCHR          ; Get key word
1204   0988 11 65 09            LD      DE,RUNCNT       ; Where to RETurn to
1205   098B D5                  PUSH    DE              ; Save for RETurn
1206   098C C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   098D D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   098F DA 53 0B            JP      C,LET           ; No - try to assign it
1209   0992 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   0994 D2 4D 05            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   0997 07                  RLCA                    ; Double it
1212   0998 4F                  LD      C,A             ; BC = Offset into table
1213   0999 06 00               LD      B,0
1214   099B EB                  EX      DE,HL           ; Save code string address
1215   099C 21 F5 03            LD      HL,WORDTB       ; Keyword address table
1216   099F 09                  ADD     HL,BC           ; Point to routine address
1217   09A0 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   09A1 23                  INC     HL
1219   09A2 46                  LD      B,(HL)          ; Get MSB of routine address
1220   09A3 C5                  PUSH    BC              ; Save routine address
1221   09A4 EB                  EX      DE,HL           ; Restore code string address
1222   09A5             
1223   09A5 23          GETCHR: INC     HL              ; Point to next character
1224   09A6 7E                  LD      A,(HL)          ; Get next code string byte
1225   09A7 FE 3A               CP      ':'             ; Z if ':'
1226   09A9 D0                  RET     NC              ; NC if > "9"
1227   09AA FE 20               CP      ' '
1228   09AC CA A5 09            JP      Z,GETCHR        ; Skip over spaces
1229   09AF FE 30               CP      '0'
1230   09B1 3F                  CCF                     ; NC if < '0'
1231   09B2 3C                  INC     A               ; Test for zero - Leave carry
1232   09B3 3D                  DEC     A               ; Z if Null
1233   09B4 C9                  RET
1234   09B5             
1235   09B5 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   09B6 2A A3 80            LD      HL,(BASTXT)     ; Point to start of program
1237   09B9 CA CA 09            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   09BC EB                  EX      DE,HL           ; Restore code string address
1239   09BD CD 71 0A            CALL    ATOH            ; Get line number to DE
1240   09C0 E5                  PUSH    HL              ; Save code string address
1241   09C1 CD 39 06            CALL    SRCHLN          ; Search for line number in DE
1242   09C4 60                  LD      H,B             ; HL = Address of line
1243   09C5 69                  LD      L,C
1244   09C6 D1                  POP     DE              ; Restore code string address
1245   09C7 D2 12 0B            JP      NC,ULERR        ; ?UL Error if not found
1246   09CA 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   09CB 22 21 81    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   09CE EB                  EX      DE,HL           ; Restore code string address
1249   09CF C9                  RET
1250   09D0             
1251   09D0             
1252   09D0 DF          TSTBRK: RST     18H             ; Check input status
1253   09D1 C8                  RET     Z               ; No key, go back
1254   09D2 D7                  RST     10H             ; Get the key into A
1255   09D3 FE 1B               CP      ESC             ; Escape key?
1256   09D5 28 11               JR      Z,BRK           ; Yes, break
1257   09D7 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   09D9 28 0D               JR      Z,BRK           ; Yes, break
1259   09DB FE 13               CP      CTRLS           ; Stop scrolling?
1260   09DD C0                  RET     NZ              ; Other key, ignore
1261   09DE             
1262   09DE             
1263   09DE D7          STALL:  RST     10H             ; Wait for key
1264   09DF FE 11               CP      CTRLQ           ; Resume scrolling?
1265   09E1 C8                  RET      Z              ; Release the chokehold
1266   09E2 FE 03               CP      CTRLC           ; Second break?
1267   09E4 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   09E6 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   09E8             
1270   09E8 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   09EA 32 92 80            LD      (BRKFLG),A      ; Store it
1272   09ED             
1273   09ED             
1274   09ED C0          STOP:   RET     NZ              ; Exit if anything else
1275   09EE F6                  .BYTE   0F6H            ; Flag "STOP"
1276   09EF C0          PEND:   RET     NZ              ; Exit if anything else
1277   09F0 22 13 81            LD      (BRKLIN),HL     ; Save point of break
1278   09F3 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   09F4 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   09F6 C1                  POP     BC              ; Return not needed and more
1281   09F7 2A A1 80    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   09FA F5                  PUSH    AF              ; Save STOP / END status
1283   09FB 7D                  LD      A,L             ; Is it direct break?
1284   09FC A4                  AND     H
1285   09FD 3C                  INC     A               ; Line is -1 if direct break
1286   09FE CA 0A 0A            JP      Z,NOLIN         ; Yes - No line number
1287   0A01 22 17 81            LD      (ERRLIN),HL     ; Save line of break
1288   0A04 2A 13 81            LD      HL,(BRKLIN)     ; Get point of break
1289   0A07 22 19 81            LD      (CONTAD),HL     ; Save point to CONTinue
1290   0A0A AF          NOLIN:  XOR     A
1291   0A0B 32 8A 80            LD      (CTLOFG),A      ; Enable output
1292   0A0E CD 40 0C            CALL    STTLIN          ; Start a new line
1293   0A11 F1                  POP     AF              ; Restore STOP / END status
1294   0A12 21 F0 04            LD      HL,BRKMSG       ; "Break" message
1295   0A15 C2 81 05            JP      NZ,ERRIN        ; "in line" wanted?
1296   0A18 C3 98 05            JP      PRNTOK          ; Go to command mode
1297   0A1B             
1298   0A1B 2A 19 81    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   0A1E 7C                  LD      A,H             ; Is it zero?
1300   0A1F B5                  OR      L
1301   0A20 1E 20               LD      E,CN            ; ?CN Error
1302   0A22 CA 61 05            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   0A25 EB                  EX      DE,HL           ; Save code string address
1304   0A26 2A 17 81            LD      HL,(ERRLIN)     ; Get line of last break
1305   0A29 22 A1 80            LD      (LINEAT),HL     ; Set up current line number
1306   0A2C EB                  EX      DE,HL           ; Restore code string address
1307   0A2D C9                  RET                     ; CONTinue where left off
1308   0A2E             
1309   0A2E CD 73 15    NULL:   CALL    GETINT          ; Get integer 0-255
1310   0A31 C0                  RET     NZ              ; Return if bad value
1311   0A32 32 86 80            LD      (NULLS),A       ; Set nulls number
1312   0A35 C9                  RET
1313   0A36             
1314   0A36             
1315   0A36 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   0A37 2A 8F 80            LD      HL,(CHKSUM)     ; Get check sum
1317   0A3A 06 00               LD      B,0             ; BC - Value of byte
1318   0A3C 4F                  LD      C,A
1319   0A3D 09                  ADD     HL,BC           ; Add byte to check sum
1320   0A3E 22 8F 80            LD      (CHKSUM),HL     ; Re-save check sum
1321   0A41 E1                  POP     HL              ; Restore address in array
1322   0A42 C9                  RET
1323   0A43             
1324   0A43 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   0A44 FE 41               CP      'A'             ; < 'a' ?
1326   0A46 D8                  RET     C               ; Carry set if not letter
1327   0A47 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   0A49 3F                  CCF
1329   0A4A C9                  RET                     ; Carry set if not letter
1330   0A4B             
1331   0A4B CD A5 09    FPSINT: CALL    GETCHR          ; Get next character
1332   0A4E CD 12 0E    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   0A51 CD F4 17    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   0A54 FA 6C 0A            JP      M,FCERR         ; Negative - ?FC Error
1335   0A57 3A 2C 81    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   0A5A FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   0A5C DA 9C 18            JP      C,FPINT         ; Yes - convert it
1338   0A5F 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   0A62 11 00 00            LD      DE,0000
1340   0A65 E5                  PUSH    HL              ; Save code string address
1341   0A66 CD 6F 18            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   0A69 E1                  POP     HL              ; Restore code string address
1343   0A6A 51                  LD      D,C             ; MSB to D
1344   0A6B C8                  RET     Z               ; Return if in range
1345   0A6C 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   0A6E C3 61 05            JP      ERROR           ; Output error-
1347   0A71             
1348   0A71 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   0A72 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   0A75 CD A5 09    GTLNLP: CALL    GETCHR          ; Get next character
1351   0A78 D0                  RET     NC              ; Exit if not a digit
1352   0A79 E5                  PUSH    HL              ; Save code string address
1353   0A7A F5                  PUSH    AF              ; Save digit
1354   0A7B 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   0A7E CD 15 08            CALL    CPDEHL          ; Number in range?
1356   0A81 DA 4D 05            JP      C,SNERR         ; No - ?SN Error
1357   0A84 62                  LD      H,D             ; HL = Number
1358   0A85 6B                  LD      L,E
1359   0A86 19                  ADD     HL,DE           ; Times 2
1360   0A87 29                  ADD     HL,HL           ; Times 4
1361   0A88 19                  ADD     HL,DE           ; Times 5
1362   0A89 29                  ADD     HL,HL           ; Times 10
1363   0A8A F1                  POP     AF              ; Restore digit
1364   0A8B D6 30               SUB     '0'             ; Make it 0 to 9
1365   0A8D 5F                  LD      E,A             ; DE = Value of digit
1366   0A8E 16 00               LD      D,0
1367   0A90 19                  ADD     HL,DE           ; Add to number
1368   0A91 EB                  EX      DE,HL           ; Number to DE
1369   0A92 E1                  POP     HL              ; Restore code string address
1370   0A93 C3 75 0A            JP      GTLNLP          ; Go to next character
1371   0A96             
1372   0A96 CA 69 06    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   0A99 CD 4E 0A            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   0A9C 2B                  DEC     HL              ; Cancel increment
1375   0A9D CD A5 09            CALL    GETCHR          ; Get next character
1376   0AA0 E5                  PUSH    HL              ; Save code string address
1377   0AA1 2A F4 80            LD      HL,(LSTRAM)     ; Get end of RAM
1378   0AA4 CA B9 0A            JP      Z,STORED        ; No value given - Use stored
1379   0AA7 E1                  POP     HL              ; Restore code string address
1380   0AA8 CD 1B 08            CALL    CHKSYN          ; Check for comma
1381   0AAB 2C                  .BYTE      ','
1382   0AAC D5                  PUSH    DE              ; Save number
1383   0AAD CD 4E 0A            CALL    POSINT          ; Get integer 0 to 32767
1384   0AB0 2B                  DEC     HL              ; Cancel increment
1385   0AB1 CD A5 09            CALL    GETCHR          ; Get next character
1386   0AB4 C2 4D 05            JP      NZ,SNERR        ; ?SN Error if more on line
1387   0AB7 E3                  EX      (SP),HL         ; Save code string address
1388   0AB8 EB                  EX      DE,HL           ; Number to DE
1389   0AB9 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   0ABA 93                  SUB     E               ; Subtract LSB of string space
1391   0ABB 5F                  LD      E,A             ; Save LSB
1392   0ABC 7C                  LD      A,H             ; Get MSB of new RAM top
1393   0ABD 9A                  SBC     A,D             ; Subtract MSB of string space
1394   0ABE 57                  LD      D,A             ; Save MSB
1395   0ABF DA 42 05            JP      C,OMERR         ; ?OM Error if not enough mem
1396   0AC2 E5                  PUSH    HL              ; Save RAM top
1397   0AC3 2A 1B 81            LD      HL,(PROGND)     ; Get program end
1398   0AC6 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   0AC9 09                  ADD     HL,BC           ; Get lowest address
1400   0ACA CD 15 08            CALL    CPDEHL          ; Enough memory?
1401   0ACD D2 42 05            JP      NC,OMERR        ; No - ?OM Error
1402   0AD0 EB                  EX      DE,HL           ; RAM top to HL
1403   0AD1 22 9F 80            LD      (STRSPC),HL     ; Set new string space
1404   0AD4 E1                  POP     HL              ; End of memory to use
1405   0AD5 22 F4 80            LD      (LSTRAM),HL     ; Set new top of RAM
1406   0AD8 E1                  POP     HL              ; Restore code string address
1407   0AD9 C3 69 06            JP      INTVAR          ; Initialise variables
1408   0ADC             
1409   0ADC CA 65 06    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   0ADF CD 69 06            CALL    INTVAR          ; Initialise variables
1411   0AE2 01 65 09            LD      BC,RUNCNT       ; Execution driver loop
1412   0AE5 C3 F8 0A            JP      RUNLIN          ; RUN from line number
1413   0AE8             
1414   0AE8 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   0AEA CD 2A 05            CALL    CHKSTK          ; Check for 3 levels of stack
1416   0AED C1                  POP     BC              ; Get return address
1417   0AEE E5                  PUSH    HL              ; Save code string for RETURN
1418   0AEF E5                  PUSH    HL              ; And for GOSUB routine
1419   0AF0 2A A1 80            LD      HL,(LINEAT)     ; Get current line
1420   0AF3 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   0AF4 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   0AF6 F5                  PUSH    AF              ; Save token
1423   0AF7 33                  INC     SP              ; Don't save flags
1424   0AF8             
1425   0AF8 C5          RUNLIN: PUSH    BC              ; Save return address
1426   0AF9 CD 71 0A    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   0AFC CD 3E 0B            CALL    REM             ; Get end of line
1428   0AFF E5                  PUSH    HL              ; Save end of line
1429   0B00 2A A1 80            LD      HL,(LINEAT)     ; Get current line
1430   0B03 CD 15 08            CALL    CPDEHL          ; Line after current?
1431   0B06 E1                  POP     HL              ; Restore end of line
1432   0B07 23                  INC     HL              ; Start of next line
1433   0B08 DC 3C 06            CALL    C,SRCHLP        ; Line is after current line
1434   0B0B D4 39 06            CALL    NC,SRCHLN       ; Line is before current line
1435   0B0E 60                  LD      H,B             ; Set up code string address
1436   0B0F 69                  LD      L,C
1437   0B10 2B                  DEC     HL              ; Incremented after
1438   0B11 D8                  RET     C               ; Line found
1439   0B12 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   0B14 C3 61 05            JP      ERROR           ; Output error message
1441   0B17             
1442   0B17 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   0B18 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   0B1A CD F6 04            CALL    BAKSTK          ; Look "GOSUB" block
1445   0B1D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   0B1E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   0B20 1E 04               LD      E,RG            ; ?RG Error
1448   0B22 C2 61 05            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   0B25 E1                  POP     HL              ; Get RETURN line number
1450   0B26 22 A1 80            LD      (LINEAT),HL     ; Save as current
1451   0B29 23                  INC     HL              ; Was it from direct statement?
1452   0B2A 7C                  LD      A,H
1453   0B2B B5                  OR      L               ; Return to line
1454   0B2C C2 36 0B            JP      NZ,RETLIN       ; No - Return to line
1455   0B2F 3A 11 81            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   0B32 B7                  OR      A               ; If so buffer is corrupted
1457   0B33 C2 97 05            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   0B36 21 65 09    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   0B39 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   0B3A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   0B3B E1          NXTDTA: POP     HL              ; Restore code string address
1462   0B3C             
1463   0B3C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   0B3E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   0B40 06 00               LD      B,0
1466   0B42 79          NXTSTL: LD      A,C             ; Statement and byte
1467   0B43 48                  LD      C,B
1468   0B44 47                  LD      B,A             ; Statement end byte
1469   0B45 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   0B46 B7                  OR      A               ; End of line?
1471   0B47 C8                  RET     Z               ; Yes - Exit
1472   0B48 B8                  CP      B               ; End of statement?
1473   0B49 C8                  RET     Z               ; Yes - Exit
1474   0B4A 23                  INC     HL              ; Next byte
1475   0B4B FE 22               CP      '"'             ; Literal string?
1476   0B4D CA 42 0B            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   0B50 C3 45 0B            JP      NXTSTT          ; Keep looking
1478   0B53             
1479   0B53 CD 08 10    LET:    CALL    GETVAR          ; Get variable name
1480   0B56 CD 1B 08            CALL    CHKSYN          ; Make sure "=" follows
1481   0B59 B4                  .BYTE      ZEQUAL          ; "=" token
1482   0B5A D5                  PUSH    DE              ; Save address of variable
1483   0B5B 3A F2 80            LD      A,(TYPE)        ; Get data type
1484   0B5E F5                  PUSH    AF              ; Save type
1485   0B5F CD 24 0E            CALL    EVAL            ; Evaluate expression
1486   0B62 F1                  POP     AF              ; Restore type
1487   0B63 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   0B64 22 13 81            LD      (BRKLIN),HL     ; Save address of variable
1489   0B67 1F                  RRA                     ; Adjust type
1490   0B68 CD 17 0E            CALL    CHKTYP          ; Check types are the same
1491   0B6B CA A6 0B            JP      Z,LETNUM        ; Numeric - Move value
1492   0B6E E5          LETSTR: PUSH    HL              ; Save address of string var
1493   0B6F 2A 29 81            LD      HL,(FPREG)      ; Pointer to string entry
1494   0B72 E5                  PUSH    HL              ; Save it on stack
1495   0B73 23                  INC     HL              ; Skip over length
1496   0B74 23                  INC     HL
1497   0B75 5E                  LD      E,(HL)          ; LSB of string address
1498   0B76 23                  INC     HL
1499   0B77 56                  LD      D,(HL)          ; MSB of string address
1500   0B78 2A A3 80            LD      HL,(BASTXT)     ; Point to start of program
1501   0B7B CD 15 08            CALL    CPDEHL          ; Is string before program?
1502   0B7E D2 95 0B            JP      NC,CRESTR       ; Yes - Create string entry
1503   0B81 2A 9F 80            LD      HL,(STRSPC)     ; Point to string space
1504   0B84 CD 15 08            CALL    CPDEHL          ; Is string literal in program?
1505   0B87 D1                  POP     DE              ; Restore address of string
1506   0B88 D2 9D 0B            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   0B8B 21 04 81            LD      HL,TMPSTR       ; Temporary string pool
1508   0B8E CD 15 08            CALL    CPDEHL          ; Is string in temporary pool?
1509   0B91 D2 9D 0B            JP      NC,MVSTPT       ; No - Set up pointer
1510   0B94 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   0B95 D1          CRESTR: POP     DE              ; Restore address of string
1512   0B96 CD 4C 14            CALL    BAKTMP          ; Back to last tmp-str entry
1513   0B99 EB                  EX      DE,HL           ; Address of string entry
1514   0B9A CD 85 12            CALL    SAVSTR          ; Save string in string area
1515   0B9D CD 4C 14    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   0BA0 E1                  POP     HL              ; Get string pointer
1517   0BA1 CD 4F 18            CALL    DETHL4          ; Move string pointer to var
1518   0BA4 E1                  POP     HL              ; Restore code string address
1519   0BA5 C9                  RET
1520   0BA6             
1521   0BA6 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   0BA7 CD 4C 18            CALL    FPTHL           ; Move value to variable
1523   0BAA D1                  POP     DE              ; Restore address of variable
1524   0BAB E1                  POP     HL              ; Restore code string address
1525   0BAC C9                  RET
1526   0BAD             
1527   0BAD CD 73 15    ON:     CALL    GETINT          ; Get integer 0-255
1528   0BB0 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   0BB1 47                  LD      B,A             ; Save in B
1530   0BB2 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   0BB4 CA BC 0B            JP      Z,ONGO          ; Yes - Find line number
1532   0BB7 CD 1B 08            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   0BBA 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   0BBB 2B                  DEC     HL              ; Cancel increment
1535   0BBC 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   0BBD 0D          ONGOLP: DEC     C               ; Count branches
1537   0BBE 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   0BBF CA 8D 09            JP      Z,ONJMP         ; Go to that line if right one
1539   0BC2 CD 72 0A            CALL    GETLN           ; Get line number to DE
1540   0BC5 FE 2C               CP      ','             ; Another line number?
1541   0BC7 C0                  RET     NZ              ; No - Drop through
1542   0BC8 C3 BD 0B            JP      ONGOLP          ; Yes - loop
1543   0BCB             
1544   0BCB CD 24 0E    IF:     CALL    EVAL            ; Evaluate expression
1545   0BCE 7E                  LD      A,(HL)          ; Get token
1546   0BCF FE 88               CP      ZGOTO           ; "GOTO" token?
1547   0BD1 CA D9 0B            JP      Z,IFGO          ; Yes - Get line
1548   0BD4 CD 1B 08            CALL    CHKSYN          ; Make sure it's "THEN"
1549   0BD7 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   0BD8 2B                  DEC     HL              ; Cancel increment
1551   0BD9 CD 15 0E    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   0BDC CD F4 17            CALL    TSTSGN          ; Test state of expression
1553   0BDF CA 3E 0B            JP      Z,REM           ; False - Drop through
1554   0BE2 CD A5 09            CALL    GETCHR          ; Get next character
1555   0BE5 DA F9 0A            JP      C,GOTO          ; Number - GOTO that line
1556   0BE8 C3 8C 09            JP      IFJMP           ; Otherwise do statement
1557   0BEB             
1558   0BEB 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   0BEC CD A5 09            CALL    GETCHR          ; Get next character
1560   0BEF CA 4D 0C    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   0BF2 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   0BF3 FE A5               CP      ZTAB            ; "TAB(" token?
1563   0BF5 CA 80 0C            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   0BF8 FE A8               CP      ZSPC            ; "SPC(" token?
1565   0BFA CA 80 0C            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   0BFD E5                  PUSH    HL              ; Save code string address
1567   0BFE FE 2C               CP      ','             ; Comma?
1568   0C00 CA 69 0C            JP      Z,DOCOM         ; Yes - Move to next zone
1569   0C03 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   0C05 CA A3 0C            JP      Z,NEXITM        ; Do semi-colon routine
1571   0C08 C1                  POP     BC              ; Code string address to BC
1572   0C09 CD 24 0E            CALL    EVAL            ; Evaluate expression
1573   0C0C E5                  PUSH    HL              ; Save code string address
1574   0C0D 3A F2 80            LD      A,(TYPE)        ; Get variable type
1575   0C10 B7                  OR      A               ; Is it a string variable?
1576   0C11 C2 39 0C            JP      NZ,PRNTST       ; Yes - Output string contents
1577   0C14 CD 99 19            CALL    NUMASC          ; Convert number to text
1578   0C17 CD A9 12            CALL    CRTST           ; Create temporary string
1579   0C1A 36 20               LD      (HL),' '        ; Followed by a space
1580   0C1C 2A 29 81            LD      HL,(FPREG)      ; Get length of output
1581   0C1F 34                  INC     (HL)            ; Plus 1 for the space
1582   0C20 2A 29 81            LD      HL,(FPREG)      ; < Not needed >
1583   0C23 3A 87 80            LD      A,(LWIDTH)      ; Get width of line
1584   0C26 47                  LD      B,A             ; To B
1585   0C27 04                  INC     B               ; Width 255 (No limit)?
1586   0C28 CA 35 0C            JP      Z,PRNTNB        ; Yes - Output number string
1587   0C2B 04                  INC     B               ; Adjust it
1588   0C2C 3A F0 80            LD      A,(CURPOS)      ; Get cursor position
1589   0C2F 86                  ADD     A,(HL)          ; Add length of string
1590   0C30 3D                  DEC     A               ; Adjust it
1591   0C31 B8                  CP      B               ; Will output fit on this line?
1592   0C32 D4 4D 0C            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   0C35 CD EE 12    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   0C38 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   0C39 C4 EE 12    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   0C3C E1                  POP     HL              ; Restore code string address
1597   0C3D C3 EB 0B            JP      MRPRNT          ; See if more to PRINT
1598   0C40             
1599   0C40 3A F0 80    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   0C43 B7                  OR      A               ; Already at start?
1601   0C44 C8                  RET     Z               ; Yes - Do nothing
1602   0C45 C3 4D 0C            JP      PRNTCRLF        ; Start a new line
1603   0C48             
1604   0C48 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   0C4A 21 A5 80            LD      HL,BUFFER-1     ; Point to buffer
1606   0C4D 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   0C4F CD 26 08            CALL    OUTC            ; Output character
1608   0C52 3E 0A               LD      A,LF            ; Load a LF
1609   0C54 CD 26 08            CALL    OUTC            ; Output character
1610   0C57 AF          DONULL: XOR     A               ; Set to position 0
1611   0C58 32 F0 80            LD      (CURPOS),A      ; Store it
1612   0C5B 3A 86 80            LD      A,(NULLS)       ; Get number of nulls
1613   0C5E 3D          NULLP:  DEC     A               ; Count them
1614   0C5F C8                  RET     Z               ; Return if done
1615   0C60 F5                  PUSH    AF              ; Save count
1616   0C61 AF                  XOR     A               ; Load a null
1617   0C62 CD 26 08            CALL    OUTC            ; Output it
1618   0C65 F1                  POP     AF              ; Restore count
1619   0C66 C3 5E 0C            JP      NULLP           ; Keep counting
1620   0C69             
1621   0C69 3A 88 80    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   0C6C 47                  LD      B,A             ; Save in B
1623   0C6D 3A F0 80            LD      A,(CURPOS)      ; Get current position
1624   0C70 B8                  CP      B               ; Within the limit?
1625   0C71 D4 4D 0C            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   0C74 D2 A3 0C            JP      NC,NEXITM       ; Get next item
1627   0C77 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   0C79 D2 77 0C            JP      NC,ZONELP       ; Repeat if more zones
1629   0C7C 2F                  CPL                     ; Number of spaces to output
1630   0C7D C3 98 0C            JP      ASPCS           ; Output them
1631   0C80             
1632   0C80 F5          DOTAB:  PUSH    AF              ; Save token
1633   0C81 CD 70 15            CALL    FNDNUM          ; Evaluate expression
1634   0C84 CD 1B 08            CALL    CHKSYN          ; Make sure ")" follows
1635   0C87 29                  .BYTE   ")"
1636   0C88 2B                  DEC     HL              ; Back space on to ")"
1637   0C89 F1                  POP     AF              ; Restore token
1638   0C8A D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   0C8C E5                  PUSH    HL              ; Save code string address
1640   0C8D CA 93 0C            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   0C90 3A F0 80            LD      A,(CURPOS)      ; Get current position
1642   0C93 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   0C94 83                  ADD     A,E             ; Total number to print
1644   0C95 D2 A3 0C            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   0C98 3C          ASPCS:  INC     A               ; Output A spaces
1646   0C99 47                  LD      B,A             ; Save number to print
1647   0C9A 3E 20               LD      A,' '           ; Space
1648   0C9C CD 26 08    SPCLP:  CALL    OUTC            ; Output character in A
1649   0C9F 05                  DEC     B               ; Count them
1650   0CA0 C2 9C 0C            JP      NZ,SPCLP        ; Repeat if more
1651   0CA3 E1          NEXITM: POP     HL              ; Restore code string address
1652   0CA4 CD A5 09            CALL    GETCHR          ; Get next character
1653   0CA7 C3 F2 0B            JP      PRNTLP          ; More to print
1654   0CAA             
1655   0CAA 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   0CB0 66726F6D2073746172740D0A00
1656   0CBD             
1657   0CBD 3A 12 81    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   0CC0 B7                  OR      A
1659   0CC1 C2 47 05            JP      NZ,DATSNR       ; READ - ?SN Error
1660   0CC4 C1                  POP     BC              ; Throw away code string addr
1661   0CC5 21 AA 0C            LD      HL,REDO         ; "Redo from start" message
1662   0CC8 CD EB 12            CALL    PRS             ; Output string
1663   0CCB C3 98 06            JP      DOAGN           ; Do last INPUT again
1664   0CCE             
1665   0CCE CD 56 12    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   0CD1 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   0CD2 FE 22               CP      '"'             ; Is there a prompt string?
1668   0CD4 3E 00               LD      A,0             ; Clear A and leave flags
1669   0CD6 32 8A 80            LD      (CTLOFG),A      ; Enable output
1670   0CD9 C2 E8 0C            JP      NZ,NOPMPT       ; No prompt - get input
1671   0CDC CD AA 12            CALL    QTSTR           ; Get string terminated by '"'
1672   0CDF CD 1B 08            CALL    CHKSYN          ; Check for ';' after prompt
1673   0CE2 3B                  .BYTE   ';'
1674   0CE3 E5                  PUSH    HL              ; Save code string address
1675   0CE4 CD EE 12            CALL    PRS1            ; Output prompt string
1676   0CE7 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   0CE8 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   0CE9 CD 9C 06            CALL    PROMPT          ; Get input with "? " prompt
1679   0CEC C1                  POP     BC              ; Restore code string address
1680   0CED DA F4 09            JP      C,INPBRK        ; Break pressed - Exit
1681   0CF0 23                  INC     HL              ; Next byte
1682   0CF1 7E                  LD      A,(HL)          ; Get it
1683   0CF2 B7                  OR      A               ; End of line?
1684   0CF3 2B                  DEC     HL              ; Back again
1685   0CF4 C5                  PUSH    BC              ; Re-save code string address
1686   0CF5 CA 3B 0B            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   0CF8 36 2C               LD      (HL),','        ; Store comma as separator
1688   0CFA C3 02 0D            JP      NXTITM          ; Get next item
1689   0CFD             
1690   0CFD E5          READ:   PUSH    HL              ; Save code string address
1691   0CFE 2A 21 81            LD      HL,(NXTDAT)     ; Next DATA statement
1692   0D01 F6                  .BYTE   0F6H            ; Flag "READ"
1693   0D02 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   0D03 32 12 81            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   0D06 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   0D07 C3 0E 0D            JP      GTVLUS          ; Get values
1697   0D0A             
1698   0D0A CD 1B 08    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   0D0D 2C                  .BYTE      ','
1700   0D0E CD 08 10    GTVLUS: CALL    GETVAR          ; Get variable name
1701   0D11 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   0D12 D5                  PUSH    DE              ; Save variable address
1703   0D13 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   0D14 FE 2C               CP      ','             ; Comma?
1705   0D16 CA 36 0D            JP      Z,ANTVLU        ; Yes - Get another value
1706   0D19 3A 12 81            LD      A,(READFG)      ; Is it READ?
1707   0D1C B7                  OR      A
1708   0D1D C2 A3 0D            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   0D20 3E 3F               LD      A,'?'           ; More INPUT needed
1710   0D22 CD 26 08            CALL    OUTC            ; Output character
1711   0D25 CD 9C 06            CALL    PROMPT          ; Get INPUT with prompt
1712   0D28 D1                  POP     DE              ; Variable address
1713   0D29 C1                  POP     BC              ; Code string address
1714   0D2A DA F4 09            JP      C,INPBRK        ; Break pressed
1715   0D2D 23                  INC     HL              ; Point to next DATA byte
1716   0D2E 7E                  LD      A,(HL)          ; Get byte
1717   0D2F B7                  OR      A               ; Is it zero (No input) ?
1718   0D30 2B                  DEC     HL              ; Back space INPUT pointer
1719   0D31 C5                  PUSH    BC              ; Save code string address
1720   0D32 CA 3B 0B            JP      Z,NXTDTA        ; Find end of buffer
1721   0D35 D5                  PUSH    DE              ; Save variable address
1722   0D36 3A F2 80    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   0D39 B7                  OR      A               ; Is it numeric?
1724   0D3A CA 60 0D            JP      Z,INPBIN        ; Yes - Convert to binary
1725   0D3D CD A5 09            CALL    GETCHR          ; Get next character
1726   0D40 57                  LD      D,A             ; Save input character
1727   0D41 47                  LD      B,A             ; Again
1728   0D42 FE 22               CP      '"'             ; Start of literal sting?
1729   0D44 CA 54 0D            JP      Z,STRENT        ; Yes - Create string entry
1730   0D47 3A 12 81            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   0D4A B7                  OR      A
1732   0D4B 57                  LD      D,A             ; Save 00 if "INPUT"
1733   0D4C CA 51 0D            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   0D4F 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   0D51 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   0D53 2B                  DEC     HL              ; Back space for DTSTR
1737   0D54 CD AD 12    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   0D57 EB                  EX      DE,HL           ; String address to DE
1739   0D58 21 6B 0D            LD      HL,LTSTND       ; Where to go after LETSTR
1740   0D5B E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   0D5C D5                  PUSH    DE              ; Save address of string
1742   0D5D C3 6E 0B            JP      LETSTR          ; Assign string to variable
1743   0D60             
1744   0D60 CD A5 09    INPBIN: CALL    GETCHR          ; Get next character
1745   0D63 CD FB 18            CALL    ASCTFP          ; Convert ASCII to FP number
1746   0D66 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   0D67 CD 4C 18            CALL    FPTHL           ; Move FPREG to variable
1748   0D6A E1                  POP     HL              ; Restore input pointer
1749   0D6B 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   0D6C CD A5 09            CALL    GETCHR          ; Get next character
1751   0D6F CA 77 0D            JP      Z,MORDT         ; End of line - More needed?
1752   0D72 FE 2C               CP      ','             ; Another value?
1753   0D74 C2 BD 0C            JP      NZ,BADINP       ; No - Bad input
1754   0D77 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   0D78 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   0D79 CD A5 09            CALL    GETCHR          ; Get next character
1757   0D7C C2 0A 0D            JP      NZ,NEDMOR       ; More needed - Get it
1758   0D7F D1                  POP     DE              ; Restore DATA pointer
1759   0D80 3A 12 81            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   0D83 B7                  OR      A
1761   0D84 EB                  EX      DE,HL           ; DATA pointer to HL
1762   0D85 C2 CB 09            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   0D88 D5                  PUSH    DE              ; Save code string address
1764   0D89 B6                  OR      (HL)            ; More input given?
1765   0D8A 21 92 0D            LD      HL,EXTIG        ; "?Extra ignored" message
1766   0D8D C4 EB 12            CALL    NZ,PRS          ; Output string if extra given
1767   0D90 E1                  POP     HL              ; Restore code string address
1768   0D91 C9                  RET
1769   0D92             
1770   0D92 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   0D98 2069676E6F7265640D0A00
1771   0DA3             
1772   0DA3 CD 3C 0B    FDTLP:  CALL    DATA            ; Get next statement
1773   0DA6 B7                  OR      A               ; End of line?
1774   0DA7 C2 BC 0D            JP      NZ,FANDT        ; No - See if DATA statement
1775   0DAA 23                  INC     HL
1776   0DAB 7E                  LD      A,(HL)          ; End of program?
1777   0DAC 23                  INC     HL
1778   0DAD B6                  OR      (HL)            ; 00 00 Ends program
1779   0DAE 1E 06               LD      E,OD            ; ?OD Error
1780   0DB0 CA 61 05            JP      Z,ERROR         ; Yes - Out of DATA
1781   0DB3 23                  INC     HL
1782   0DB4 5E                  LD      E,(HL)          ; LSB of line number
1783   0DB5 23                  INC     HL
1784   0DB6 56                  LD      D,(HL)          ; MSB of line number
1785   0DB7 EB                  EX      DE,HL
1786   0DB8 22 0E 81            LD      (DATLIN),HL     ; Set line of current DATA item
1787   0DBB EB                  EX      DE,HL
1788   0DBC CD A5 09    FANDT:  CALL    GETCHR          ; Get next character
1789   0DBF FE 83               CP      ZDATA           ; "DATA" token
1790   0DC1 C2 A3 0D            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   0DC4 C3 36 0D            JP      ANTVLU          ; Found - Convert input
1792   0DC7             
1793   0DC7 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   0DCA C4 08 10    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   0DCD 22 13 81            LD      (BRKLIN),HL     ; Save code string address
1796   0DD0 CD F6 04            CALL    BAKSTK          ; Look for "FOR" block
1797   0DD3 C2 53 05            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   0DD6 F9                  LD      SP,HL           ; Clear nested loops
1799   0DD7 D5                  PUSH    DE              ; Save index address
1800   0DD8 7E                  LD      A,(HL)          ; Get sign of STEP
1801   0DD9 23                  INC     HL
1802   0DDA F5                  PUSH    AF              ; Save sign of STEP
1803   0DDB D5                  PUSH    DE              ; Save index address
1804   0DDC CD 32 18            CALL    PHLTFP          ; Move index value to FPREG
1805   0DDF E3                  EX      (SP),HL         ; Save address of TO value
1806   0DE0 E5                  PUSH    HL              ; Save address of index
1807   0DE1 CD 9F 15            CALL    ADDPHL          ; Add STEP to index value
1808   0DE4 E1                  POP     HL              ; Restore address of index
1809   0DE5 CD 4C 18            CALL    FPTHL           ; Move value to index variable
1810   0DE8 E1                  POP     HL              ; Restore address of TO value
1811   0DE9 CD 43 18            CALL    LOADFP          ; Move TO value to BCDE
1812   0DEC E5                  PUSH    HL              ; Save address of line of FOR
1813   0DED CD 6F 18            CALL    CMPNUM          ; Compare index with TO value
1814   0DF0 E1                  POP     HL              ; Restore address of line num
1815   0DF1 C1                  POP     BC              ; Address of sign of STEP
1816   0DF2 90                  SUB     B               ; Compare with expected sign
1817   0DF3 CD 43 18            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   0DF6 CA 02 0E            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   0DF9 EB                  EX      DE,HL           ; Loop statement line number
1820   0DFA 22 A1 80            LD      (LINEAT),HL     ; Set loop line number
1821   0DFD 69                  LD      L,C             ; Set code string to loop
1822   0DFE 60                  LD      H,B
1823   0DFF C3 61 09            JP      PUTFID          ; Put back "FOR" and continue
1824   0E02             
1825   0E02 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   0E03 2A 13 81            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   0E06 7E                  LD      A,(HL)          ; Get next byte in code string
1828   0E07 FE 2C               CP      ','             ; More NEXTs ?
1829   0E09 C2 65 09            JP      NZ,RUNCNT       ; No - Do next statement
1830   0E0C CD A5 09            CALL    GETCHR          ; Position to index name
1831   0E0F CD CA 0D            CALL    NEXT1           ; Re-enter NEXT routine
1832   0E12             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   0E12             
1834   0E12 CD 24 0E    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   0E15 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   0E16 37          TSTSTR: SCF                     ; Set carry (string)
1837   0E17 3A F2 80    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   0E1A 8F                  ADC     A,A             ; Expected + actual
1839   0E1B B7                  OR      A               ; Clear carry , set parity
1840   0E1C E8                  RET     PE              ; Even parity - Types match
1841   0E1D C3 5F 05            JP      TMERR           ; Different types - Error
1842   0E20             
1843   0E20 CD 1B 08    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   0E23 28                  .BYTE   "("
1845   0E24 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   0E25 16 00               LD      D,0             ; Precedence value
1847   0E27 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   0E28 0E 01               LD      C,1
1849   0E2A CD 2A 05            CALL    CHKSTK          ; Check for 1 level of stack
1850   0E2D CD 9B 0E            CALL    OPRND           ; Get next expression value
1851   0E30 22 15 81    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   0E33 2A 15 81    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   0E36 C1                  POP     BC              ; Precedence value and operator
1854   0E37 78                  LD      A,B             ; Get precedence value
1855   0E38 FE 78               CP      78H             ; "AND" or "OR" ?
1856   0E3A D4 15 0E            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   0E3D 7E                  LD      A,(HL)          ; Get next operator / function
1858   0E3E 16 00               LD      D,0             ; Clear Last relation
1859   0E40 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   0E42 DA 5C 0E            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   0E45 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   0E47 D2 5C 0E            JP      NC,FOPRND       ; Function - Call it
1863   0E4A FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   0E4C 17                  RLA                     ; <- Test for legal
1865   0E4D AA                  XOR     D               ; <- combinations of < = >
1866   0E4E BA                  CP      D               ; <- by combining last token
1867   0E4F 57                  LD      D,A             ; <- with current one
1868   0E50 DA 4D 05            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   0E53 22 0A 81            LD      (CUROPR),HL     ; Save address of current token
1870   0E56 CD A5 09            CALL    GETCHR          ; Get next character
1871   0E59 C3 40 0E            JP      RLTLP           ; Treat the two as one
1872   0E5C             
1873   0E5C 7A          FOPRND: LD      A,D             ; < = > found ?
1874   0E5D B7                  OR      A
1875   0E5E C2 83 0F            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   0E61 7E                  LD      A,(HL)          ; Get operator token
1877   0E62 22 0A 81            LD      (CUROPR),HL     ; Save operator address
1878   0E65 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   0E67 D8                  RET     C               ; Neither - Exit
1880   0E68 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   0E6A D0                  RET     NC              ; No - Exit
1882   0E6B 5F                  LD      E,A             ; Coded operator
1883   0E6C 3A F2 80            LD      A,(TYPE)        ; Get data type
1884   0E6F 3D                  DEC     A               ; FF = numeric , 00 = string
1885   0E70 B3                  OR      E               ; Combine with coded operator
1886   0E71 7B                  LD      A,E             ; Get coded operator
1887   0E72 CA E1 13            JP      Z,CONCAT        ; String concatenation
1888   0E75 07                  RLCA                    ; Times 2
1889   0E76 83                  ADD     A,E             ; Times 3
1890   0E77 5F                  LD      E,A             ; To DE (D is 0)
1891   0E78 21 3F 04            LD      HL,PRITAB       ; Precedence table
1892   0E7B 19                  ADD     HL,DE           ; To the operator concerned
1893   0E7C 78                  LD      A,B             ; Last operator precedence
1894   0E7D 56                  LD      D,(HL)          ; Get evaluation precedence
1895   0E7E BA                  CP      D               ; Compare with eval precedence
1896   0E7F D0                  RET     NC              ; Exit if higher precedence
1897   0E80 23                  INC     HL              ; Point to routine address
1898   0E81 CD 15 0E            CALL    TSTNUM          ; Make sure it's a number
1899   0E84             
1900   0E84 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   0E85 01 33 0E            LD      BC,EVAL3        ; Where to go on prec' break
1902   0E88 C5                  PUSH    BC              ; Save on stack for return
1903   0E89 43                  LD      B,E             ; Save operator
1904   0E8A 4A                  LD      C,D             ; Save precedence
1905   0E8B CD 25 18            CALL    STAKFP          ; Move value to stack
1906   0E8E 58                  LD      E,B             ; Restore operator
1907   0E8F 51                  LD      D,C             ; Restore precedence
1908   0E90 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   0E91 23                  INC     HL
1910   0E92 46                  LD      B,(HL)          ; Get MSB of routine address
1911   0E93 23                  INC     HL
1912   0E94 C5                  PUSH    BC              ; Save routine address
1913   0E95 2A 0A 81            LD      HL,(CUROPR)     ; Address of current operator
1914   0E98 C3 27 0E            JP      EVAL1           ; Loop until prec' break
1915   0E9B             
1916   0E9B AF          OPRND:  XOR     A               ; Get operand routine
1917   0E9C 32 F2 80            LD      (TYPE),A        ; Set numeric expected
1918   0E9F CD A5 09            CALL    GETCHR          ; Get next character
1919   0EA2 1E 24               LD      E,MO            ; ?MO Error
1920   0EA4 CA 61 05            JP      Z,ERROR         ; No operand - Error
1921   0EA7 DA FB 18            JP      C,ASCTFP        ; Number - Get value
1922   0EAA CD 43 0A            CALL    CHKLTR          ; See if a letter
1923   0EAD D2 02 0F            JP      NC,CONVAR       ; Letter - Find variable
1924   0EB0 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1925   0EB2 20 12               JR		NZ, NOTAMP
1926   0EB4 CD A5 09            CALL    GETCHR          ; Get next character
1927   0EB7 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   0EB9 CA 3F 1D            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   0EBC FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   0EBE CA AF 1D            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   0EC1 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   0EC3 CA 61 05            JP      Z,ERROR         ;
1933   0EC6 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   0EC8 CA 9B 0E            JP      Z,OPRND         ; Yes - Look for operand
1935   0ECB FE 2E               CP      '.'             ; '.' ?
1936   0ECD CA FB 18            JP      Z,ASCTFP        ; Yes - Create FP number
1937   0ED0 FE AD               CP      ZMINUS          ; '-' Token ?
1938   0ED2 CA F1 0E            JP      Z,MINUS         ; Yes - Do minus
1939   0ED5 FE 22               CP      '"'             ; Literal string ?
1940   0ED7 CA AA 12            JP      Z,QTSTR         ; Get string terminated by '"'
1941   0EDA FE AA               CP      ZNOT            ; "NOT" Token ?
1942   0EDC CA E3 0F            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   0EDF FE A7               CP      ZFN             ; "FN" Token ?
1944   0EE1 CA 0E 12            JP      Z,DOFN          ; Yes - Do FN routine
1945   0EE4 D6 B6               SUB     ZSGN            ; Is it a function?
1946   0EE6 D2 13 0F            JP      NC,FNOFST       ; Yes - Evaluate function
1947   0EE9 CD 20 0E    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   0EEC CD 1B 08            CALL    CHKSYN          ; Make sure ")" follows
1949   0EEF 29                  .BYTE   ")"
1950   0EF0 C9                  RET
1951   0EF1             
1952   0EF1 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   0EF3 CD 27 0E            CALL    EVAL1           ; Evaluate until prec' break
1954   0EF6 2A 15 81            LD      HL,(NXTOPR)     ; Get next operator address
1955   0EF9 E5                  PUSH    HL              ; Save next operator address
1956   0EFA CD 1D 18            CALL    INVSGN          ; Negate value
1957   0EFD CD 15 0E    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   0F00 E1                  POP     HL              ; Restore next operator address
1959   0F01 C9                  RET
1960   0F02             
1961   0F02 CD 08 10    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   0F05 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   0F06 EB                  EX      DE,HL           ; Variable address to HL
1964   0F07 22 29 81            LD      (FPREG),HL      ; Save address of variable
1965   0F0A 3A F2 80            LD      A,(TYPE)        ; Get type
1966   0F0D B7                  OR      A               ; Numeric?
1967   0F0E CC 32 18            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   0F11 E1                  POP     HL              ; Restore code string address
1969   0F12 C9                  RET
1970   0F13             
1971   0F13 06 00       FNOFST: LD      B,0             ; Get address of function
1972   0F15 07                  RLCA                    ; Double function offset
1973   0F16 4F                  LD      C,A             ; BC = Offset in function table
1974   0F17 C5                  PUSH    BC              ; Save adjusted token value
1975   0F18 CD A5 09            CALL    GETCHR          ; Get next character
1976   0F1B 79                  LD      A,C             ; Get adjusted token value
1977   0F1C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   0F1E DA 3A 0F            JP      C,FNVAL         ; No - Do function
1979   0F21 CD 20 0E            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   0F24 CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
1981   0F27 2C                  .BYTE      ','
1982   0F28 CD 16 0E            CALL    TSTSTR          ; Make sure it's a string
1983   0F2B EB                  EX      DE,HL           ; Save code string address
1984   0F2C 2A 29 81            LD      HL,(FPREG)      ; Get address of string
1985   0F2F E3                  EX      (SP),HL         ; Save address of string
1986   0F30 E5                  PUSH    HL              ; Save adjusted token value
1987   0F31 EB                  EX      DE,HL           ; Restore code string address
1988   0F32 CD 73 15            CALL    GETINT          ; Get integer 0-255
1989   0F35 EB                  EX      DE,HL           ; Save code string address
1990   0F36 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   0F37 C3 42 0F            JP      GOFUNC          ; Jump to string function
1992   0F3A             
1993   0F3A CD E9 0E    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   0F3D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   0F3E 11 FD 0E            LD      DE,RETNUM       ; Return number from function
1996   0F41 D5                  PUSH    DE              ; Save on stack
1997   0F42 01 9E 02    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   0F45 09                  ADD     HL,BC           ; Point to right address
1999   0F46 4E                  LD      C,(HL)          ; Get LSB of address
2000   0F47 23                  INC     HL              ;
2001   0F48 66                  LD      H,(HL)          ; Get MSB of address
2002   0F49 69                  LD      L,C             ; Address to HL
2003   0F4A E9                  JP      (HL)            ; Jump to function
2004   0F4B             
2005   0F4B 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   0F4C FE AD               CP      ZMINUS          ; '-' token ?
2007   0F4E C8                  RET     Z               ; Yes - Return
2008   0F4F FE 2D               CP      '-'             ; '-' ASCII ?
2009   0F51 C8                  RET     Z               ; Yes - Return
2010   0F52 14                  INC     D               ; Inc to flag positive exponent
2011   0F53 FE 2B               CP      '+'             ; '+' ASCII ?
2012   0F55 C8                  RET     Z               ; Yes - Return
2013   0F56 FE AC               CP      ZPLUS           ; '+' token ?
2014   0F58 C8                  RET     Z               ; Yes - Return
2015   0F59 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   0F5A C9                  RET                     ; Return "NZ"
2017   0F5B             
2018   0F5B F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   0F5C AF          PAND:   XOR     A               ; Flag "AND"
2020   0F5D F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   0F5E CD 15 0E            CALL    TSTNUM          ; Make sure it's a number
2022   0F61 CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
2023   0F64 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   0F65 EB                  EX      DE,HL           ; <- Get last
2025   0F66 C1                  POP     BC              ; <-  value
2026   0F67 E3                  EX      (SP),HL         ; <-  from
2027   0F68 EB                  EX      DE,HL           ; <-  stack
2028   0F69 CD 35 18            CALL    FPBCDE          ; Move last value to FPREG
2029   0F6C F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   0F6D CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
2031   0F70 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   0F71 C1                  POP     BC              ; Get value
2033   0F72 79                  LD      A,C             ; Get LSB
2034   0F73 21 CC 11            LD      HL,ACPASS       ; Address of save AC as current
2035   0F76 C2 7E 0F            JP      NZ,POR1         ; Jump if OR
2036   0F79 A3                  AND     E               ; "AND" LSBs
2037   0F7A 4F                  LD      C,A             ; Save LSB
2038   0F7B 78                  LD      A,B             ; Get MBS
2039   0F7C A2                  AND     D               ; "AND" MSBs
2040   0F7D E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   0F7E             
2042   0F7E B3          POR1:   OR      E               ; "OR" LSBs
2043   0F7F 4F                  LD      C,A             ; Save LSB
2044   0F80 78                  LD      A,B             ; Get MSB
2045   0F81 B2                  OR      D               ; "OR" MSBs
2046   0F82 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   0F83             
2048   0F83 21 95 0F    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   0F86 3A F2 80            LD      A,(TYPE)        ; Get data type
2050   0F89 1F                  RRA                     ; Carry set = string
2051   0F8A 7A                  LD      A,D             ; Get last precedence value
2052   0F8B 17                  RLA                     ; Times 2 plus carry
2053   0F8C 5F                  LD      E,A             ; To E
2054   0F8D 16 64               LD      D,64H           ; Relational precedence
2055   0F8F 78                  LD      A,B             ; Get current precedence
2056   0F90 BA                  CP      D               ; Compare with last
2057   0F91 D0                  RET     NC              ; Eval if last was rel' or log'
2058   0F92 C3 84 0E            JP      STKTHS          ; Stack this one and get next
2059   0F95             
2060   0F95 97 0F       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   0F97 79          CMPLG1: LD      A,C             ; Get data type
2062   0F98 B7                  OR      A
2063   0F99 1F                  RRA
2064   0F9A C1                  POP     BC              ; Get last expression to BCDE
2065   0F9B D1                  POP     DE
2066   0F9C F5                  PUSH    AF              ; Save status
2067   0F9D CD 17 0E            CALL    CHKTYP          ; Check that types match
2068   0FA0 21 D9 0F            LD      HL,CMPRES       ; Result to comparison
2069   0FA3 E5                  PUSH    HL              ; Save for RETurn
2070   0FA4 CA 6F 18            JP      Z,CMPNUM        ; Compare values if numeric
2071   0FA7 AF                  XOR     A               ; Compare two strings
2072   0FA8 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2073   0FAB D5                  PUSH    DE              ; Save string name
2074   0FAC CD 2E 14            CALL    GSTRCU          ; Get current string
2075   0FAF 7E                  LD      A,(HL)          ; Get length of string
2076   0FB0 23                  INC     HL
2077   0FB1 23                  INC     HL
2078   0FB2 4E                  LD      C,(HL)          ; Get LSB of address
2079   0FB3 23                  INC     HL
2080   0FB4 46                  LD      B,(HL)          ; Get MSB of address
2081   0FB5 D1                  POP     DE              ; Restore string name
2082   0FB6 C5                  PUSH    BC              ; Save address of string
2083   0FB7 F5                  PUSH    AF              ; Save length of string
2084   0FB8 CD 32 14            CALL    GSTRDE          ; Get second string
2085   0FBB CD 43 18            CALL    LOADFP          ; Get address of second string
2086   0FBE F1                  POP     AF              ; Restore length of string 1
2087   0FBF 57                  LD      D,A             ; Length to D
2088   0FC0 E1                  POP     HL              ; Restore address of string 1
2089   0FC1 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   0FC2 B2                  OR      D               ; Bytes of string 1 to do
2091   0FC3 C8                  RET     Z               ; Exit if all bytes compared
2092   0FC4 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   0FC5 D6 01               SUB     1
2094   0FC7 D8                  RET     C               ; Exit if end of string 1
2095   0FC8 AF                  XOR     A
2096   0FC9 BB                  CP      E               ; Bytes of string 2 to do
2097   0FCA 3C                  INC     A
2098   0FCB D0                  RET     NC              ; Exit if end of string 2
2099   0FCC 15                  DEC     D               ; Count bytes in string 1
2100   0FCD 1D                  DEC     E               ; Count bytes in string 2
2101   0FCE 0A                  LD      A,(BC)          ; Byte in string 2
2102   0FCF BE                  CP      (HL)            ; Compare to byte in string 1
2103   0FD0 23                  INC     HL              ; Move up string 1
2104   0FD1 03                  INC     BC              ; Move up string 2
2105   0FD2 CA C1 0F            JP      Z,CMPSTR        ; Same - Try next bytes
2106   0FD5 3F                  CCF                     ; Flag difference (">" or "<")
2107   0FD6 C3 FF 17            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   0FD9             
2109   0FD9 3C          CMPRES: INC     A               ; Increment current value
2110   0FDA 8F                  ADC     A,A             ; Double plus carry
2111   0FDB C1                  POP     BC              ; Get other value
2112   0FDC A0                  AND     B               ; Combine them
2113   0FDD C6 FF               ADD     A,-1            ; Carry set if different
2114   0FDF 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   0FE0 C3 06 18            JP      FLGREL          ; Set current value & continue
2116   0FE3             
2117   0FE3 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   0FE5 CD 27 0E            CALL    EVAL1           ; Eval until precedence break
2119   0FE8 CD 15 0E            CALL    TSTNUM          ; Make sure it's a number
2120   0FEB CD 57 0A            CALL    DEINT           ; Get integer -32768 - 32767
2121   0FEE 7B                  LD      A,E             ; Get LSB
2122   0FEF 2F                  CPL                     ; Invert LSB
2123   0FF0 4F                  LD      C,A             ; Save "NOT" of LSB
2124   0FF1 7A                  LD      A,D             ; Get MSB
2125   0FF2 2F                  CPL                     ; Invert MSB
2126   0FF3 CD CC 11            CALL    ACPASS          ; Save AC as current
2127   0FF6 C1                  POP     BC              ; Clean up stack
2128   0FF7 C3 33 0E            JP      EVAL3           ; Continue evaluation
2129   0FFA             
2130   0FFA 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   0FFB CD A5 09            CALL    GETCHR          ; Get next character
2132   0FFE C8                  RET     Z               ; End of DIM statement
2133   0FFF CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
2134   1002 2C                  .BYTE      ','
2135   1003 01 FA 0F    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   1006 C5                  PUSH    BC              ; Save on stack
2137   1007 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   1008 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   1009 32 F1 80            LD      (LCRFLG),A      ; Set locate / create flag
2140   100C 46                  LD      B,(HL)          ; Get First byte of name
2141   100D CD 43 0A    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   1010 DA 4D 05            JP      C,SNERR         ; ?SN Error if not a letter
2143   1013 AF                  XOR     A
2144   1014 4F                  LD      C,A             ; Clear second byte of name
2145   1015 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2146   1018 CD A5 09            CALL    GETCHR          ; Get next character
2147   101B DA 24 10            JP      C,SVNAM2        ; Numeric - Save in name
2148   101E CD 43 0A            CALL    CHKLTR          ; See if a letter
2149   1021 DA 31 10            JP      C,CHARTY        ; Not a letter - Check type
2150   1024 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   1025 CD A5 09    ENDNAM: CALL    GETCHR          ; Get next character
2152   1028 DA 25 10            JP      C,ENDNAM        ; Numeric - Get another
2153   102B CD 43 0A            CALL    CHKLTR          ; See if a letter
2154   102E D2 25 10            JP      NC,ENDNAM       ; Letter - Get another
2155   1031 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   1033 C2 40 10            JP      NZ,NOTSTR       ; No - Numeric variable
2157   1036 3C                  INC     A               ; A = 1 (string type)
2158   1037 32 F2 80            LD      (TYPE),A        ; Set type to string
2159   103A 0F                  RRCA                    ; A = 80H , Flag for string
2160   103B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   103C 4F                  LD      C,A             ; Resave second byte on name
2162   103D CD A5 09            CALL    GETCHR          ; Get next character
2163   1040 3A 10 81    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   1043 3D                  DEC     A
2165   1044 CA ED 10            JP      Z,ARLDSV        ; Yes - Get array name
2166   1047 F2 50 10            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   104A 7E                  LD      A,(HL)          ; Get byte again
2168   104B D6 28               SUB     '('             ; Subscripted variable?
2169   104D CA C5 10            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   1050             
2171   1050 AF          NSCFOR: XOR     A               ; Simple variable
2172   1051 32 10 81            LD      (FORFLG),A      ; Clear "FOR" flag
2173   1054 E5                  PUSH    HL              ; Save code string address
2174   1055 50                  LD      D,B             ; DE = Variable name to find
2175   1056 59                  LD      E,C
2176   1057 2A 23 81            LD      HL,(FNRGNM)     ; FN argument name
2177   105A CD 15 08            CALL    CPDEHL          ; Is it the FN argument?
2178   105D 11 25 81            LD      DE,FNARG        ; Point to argument value
2179   1060 CA 35 17            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   1063 2A 1D 81            LD      HL,(VAREND)     ; End of variables
2181   1066 EB                  EX      DE,HL           ; Address of end of search
2182   1067 2A 1B 81            LD      HL,(PROGND)     ; Start of variables address
2183   106A CD 15 08    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   106D CA 83 10            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   1070 79                  LD      A,C             ; Get second byte of name
2186   1071 96                  SUB     (HL)            ; Compare with name in list
2187   1072 23                  INC     HL              ; Move on to first byte
2188   1073 C2 78 10            JP      NZ,FNTHR        ; Different - Find another
2189   1076 78                  LD      A,B             ; Get first byte of name
2190   1077 96                  SUB     (HL)            ; Compare with name in list
2191   1078 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   1079 CA B7 10            JP      Z,RETADR        ; Found - Return address
2193   107C 23                  INC     HL              ; <- Skip
2194   107D 23                  INC     HL              ; <- over
2195   107E 23                  INC     HL              ; <- F.P.
2196   107F 23                  INC     HL              ; <- value
2197   1080 C3 6A 10            JP      FNDVAR          ; Keep looking
2198   1083             
2199   1083 E1          CFEVAL: POP     HL              ; Restore code string address
2200   1084 E3                  EX      (SP),HL         ; Get return address
2201   1085 D5                  PUSH    DE              ; Save address of variable
2202   1086 11 05 0F            LD      DE,FRMEVL       ; Return address in EVAL
2203   1089 CD 15 08            CALL    CPDEHL          ; Called from EVAL ?
2204   108C D1                  POP     DE              ; Restore address of variable
2205   108D CA BA 10            JP      Z,RETNUL        ; Yes - Return null variable
2206   1090 E3                  EX      (SP),HL         ; Put back return
2207   1091 E5                  PUSH    HL              ; Save code string address
2208   1092 C5                  PUSH    BC              ; Save variable name
2209   1093 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   1096 2A 1F 81            LD      HL,(ARREND)     ; End of arrays
2211   1099 E5                  PUSH    HL              ; Save end of arrays
2212   109A 09                  ADD     HL,BC           ; Move up 6 bytes
2213   109B C1                  POP     BC              ; Source address in BC
2214   109C E5                  PUSH    HL              ; Save new end address
2215   109D CD 19 05            CALL    MOVUP           ; Move arrays up
2216   10A0 E1                  POP     HL              ; Restore new end address
2217   10A1 22 1F 81            LD      (ARREND),HL     ; Set new end address
2218   10A4 60                  LD      H,B             ; End of variables to HL
2219   10A5 69                  LD      L,C
2220   10A6 22 1D 81            LD      (VAREND),HL     ; Set new end address
2221   10A9             
2222   10A9 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   10AA 36 00               LD      (HL),0          ; Zero byte in variable
2224   10AC CD 15 08            CALL    CPDEHL          ; Done them all?
2225   10AF C2 A9 10            JP      NZ,ZEROLP       ; No - Keep on going
2226   10B2 D1                  POP     DE              ; Get variable name
2227   10B3 73                  LD      (HL),E          ; Store second character
2228   10B4 23                  INC     HL
2229   10B5 72                  LD      (HL),D          ; Store first character
2230   10B6 23                  INC     HL
2231   10B7 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   10B8 E1                  POP     HL              ; Restore code string address
2233   10B9 C9                  RET
2234   10BA             
2235   10BA 32 2C 81    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   10BD 21 E9 04            LD      HL,ZERBYT       ; Also set a null string
2237   10C0 22 29 81            LD      (FPREG),HL      ; Save for EVAL
2238   10C3 E1                  POP     HL              ; Restore code string address
2239   10C4 C9                  RET
2240   10C5             
2241   10C5 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   10C6 2A F1 80            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   10C9 E3                  EX      (SP),HL         ; Save and get code string
2244   10CA 57                  LD      D,A             ; Zero number of dimensions
2245   10CB D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   10CC C5                  PUSH    BC              ; Save array name
2247   10CD CD 4B 0A            CALL    FPSINT          ; Get subscript (0-32767)
2248   10D0 C1                  POP     BC              ; Restore array name
2249   10D1 F1                  POP     AF              ; Get number of dimensions
2250   10D2 EB                  EX      DE,HL
2251   10D3 E3                  EX      (SP),HL         ; Save subscript value
2252   10D4 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   10D5 EB                  EX      DE,HL
2254   10D6 3C                  INC     A               ; Count dimensions
2255   10D7 57                  LD      D,A             ; Save in D
2256   10D8 7E                  LD      A,(HL)          ; Get next byte in code string
2257   10D9 FE 2C               CP      ','             ; Comma (more to come)?
2258   10DB CA CB 10            JP      Z,SCPTLP        ; Yes - More subscripts
2259   10DE CD 1B 08            CALL    CHKSYN          ; Make sure ")" follows
2260   10E1 29                  .BYTE      ")"
2261   10E2 22 15 81            LD      (NXTOPR),HL     ; Save code string address
2262   10E5 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   10E6 22 F1 80            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   10E9 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   10EB D5                  PUSH    DE              ; Save number of dimensions (D)
2266   10EC 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   10ED             
2268   10ED E5          ARLDSV: PUSH    HL              ; Save code string address
2269   10EE F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   10EF 2A 1D 81            LD      HL,(VAREND)     ; Start of arrays
2271   10F2 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   10F3 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   10F4 EB                  EX      DE,HL
2274   10F5 2A 1F 81            LD      HL,(ARREND)     ; End of arrays
2275   10F8 EB                  EX      DE,HL           ; Current array pointer
2276   10F9 CD 15 08            CALL    CPDEHL          ; End of arrays found?
2277   10FC CA 25 11            JP      Z,CREARY        ; Yes - Create array
2278   10FF 7E                  LD      A,(HL)          ; Get second byte of name
2279   1100 B9                  CP      C               ; Compare with name given
2280   1101 23                  INC     HL              ; Move on
2281   1102 C2 07 11            JP      NZ,NXTARY       ; Different - Find next array
2282   1105 7E                  LD      A,(HL)          ; Get first byte of name
2283   1106 B8                  CP      B               ; Compare with name given
2284   1107 23          NXTARY: INC     HL              ; Move on
2285   1108 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   1109 23                  INC     HL
2287   110A 56                  LD      D,(HL)          ; Get MSB of next array address
2288   110B 23                  INC     HL
2289   110C C2 F3 10            JP      NZ,FNDARY       ; Not found - Keep looking
2290   110F 3A F1 80            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   1112 B7                  OR      A
2292   1113 C2 56 05            JP      NZ,DDERR        ; Create - ?DD Error
2293   1116 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   1117 44                  LD      B,H             ; BC Points to array dim'ns
2295   1118 4D                  LD      C,L
2296   1119 CA 35 17            JP      Z,POPHRT        ; Jump if array load/save
2297   111C 96                  SUB     (HL)            ; Same number of dimensions?
2298   111D CA 83 11            JP      Z,FINDEL        ; Yes - Find element
2299   1120 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   1122 C3 61 05            JP      ERROR           ; Output error
2301   1125             
2302   1125 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   1128 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   1129 CA 6C 0A            JP      Z,FCERR         ; Yes - ?FC Error
2305   112C 71                  LD      (HL),C          ; Save second byte of name
2306   112D 23                  INC     HL
2307   112E 70                  LD      (HL),B          ; Save first byte of name
2308   112F 23                  INC     HL
2309   1130 4F                  LD      C,A             ; Number of dimensions to C
2310   1131 CD 2A 05            CALL    CHKSTK          ; Check if enough memory
2311   1134 23                  INC     HL              ; Point to number of dimensions
2312   1135 23                  INC     HL
2313   1136 22 0A 81            LD      (CUROPR),HL     ; Save address of pointer
2314   1139 71                  LD      (HL),C          ; Set number of dimensions
2315   113A 23                  INC     HL
2316   113B 3A F1 80            LD      A,(LCRFLG)      ; Locate of Create?
2317   113E 17                  RLA                     ; Carry set = Create
2318   113F 79                  LD      A,C             ; Get number of dimensions
2319   1140 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   1143 D2 48 11            JP      NC,DEFSIZ       ; Locate - Set default size
2321   1146 C1                  POP     BC              ; Get specified dimension size
2322   1147 03                  INC     BC              ; Include zero element
2323   1148 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   1149 23                  INC     HL
2325   114A 70                  LD      (HL),B          ; Save MSB of dimension size
2326   114B 23                  INC     HL
2327   114C F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   114D E5                  PUSH    HL              ; Save address of dim'n size
2329   114E CD E0 18            CALL    MLDEBC          ; Multiply DE by BC to find
2330   1151 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   1152 E1                  POP     HL              ; Restore address of dimension
2332   1153 F1                  POP     AF              ; Restore number of dimensions
2333   1154 3D                  DEC     A               ; Count them
2334   1155 C2 40 11            JP      NZ,CRARLP       ; Do next dimension if more
2335   1158 F5                  PUSH    AF              ; Save locate/create flag
2336   1159 42                  LD      B,D             ; MSB of memory needed
2337   115A 4B                  LD      C,E             ; LSB of memory needed
2338   115B EB                  EX      DE,HL
2339   115C 19                  ADD     HL,DE           ; Add bytes to array start
2340   115D DA 42 05            JP      C,OMERR         ; Too big - Error
2341   1160 CD 33 05            CALL    ENFMEM          ; See if enough memory
2342   1163 22 1F 81            LD      (ARREND),HL     ; Save new end of array
2343   1166             
2344   1166 2B          ZERARY: DEC     HL              ; Back through array data
2345   1167 36 00               LD      (HL),0          ; Set array element to zero
2346   1169 CD 15 08            CALL    CPDEHL          ; All elements zeroed?
2347   116C C2 66 11            JP      NZ,ZERARY       ; No - Keep on going
2348   116F 03                  INC     BC              ; Number of bytes + 1
2349   1170 57                  LD      D,A             ; A=0
2350   1171 2A 0A 81            LD      HL,(CUROPR)     ; Get address of array
2351   1174 5E                  LD      E,(HL)          ; Number of dimensions
2352   1175 EB                  EX      DE,HL           ; To HL
2353   1176 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   1177 09                  ADD     HL,BC           ; Add number of bytes
2355   1178 EB                  EX      DE,HL           ; Bytes needed to DE
2356   1179 2B                  DEC     HL
2357   117A 2B                  DEC     HL
2358   117B 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   117C 23                  INC     HL
2360   117D 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   117E 23                  INC     HL
2362   117F F1                  POP     AF              ; Locate / Create?
2363   1180 DA A7 11            JP      C,ENDDIM        ; A is 0 , End if create
2364   1183 47          FINDEL: LD      B,A             ; Find array element
2365   1184 4F                  LD      C,A
2366   1185 7E                  LD      A,(HL)          ; Number of dimensions
2367   1186 23                  INC     HL
2368   1187 16                  .BYTE      16H             ; Skip "POP HL"
2369   1188 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   1189 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   118A 23                  INC     HL
2372   118B 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   118C 23                  INC     HL
2374   118D E3                  EX      (SP),HL         ; Save address - Get index
2375   118E F5                  PUSH    AF              ; Save number of dim'ns
2376   118F CD 15 08            CALL    CPDEHL          ; Dimension too large?
2377   1192 D2 20 11            JP      NC,BSERR        ; Yes - ?BS Error
2378   1195 E5                  PUSH    HL              ; Save index
2379   1196 CD E0 18            CALL    MLDEBC          ; Multiply previous by size
2380   1199 D1                  POP     DE              ; Index supplied to DE
2381   119A 19                  ADD     HL,DE           ; Add index to pointer
2382   119B F1                  POP     AF              ; Number of dimensions
2383   119C 3D                  DEC     A               ; Count them
2384   119D 44                  LD      B,H             ; MSB of pointer
2385   119E 4D                  LD      C,L             ; LSB of pointer
2386   119F C2 88 11            JP      NZ,FNDELP       ; More - Keep going
2387   11A2 29                  ADD     HL,HL           ; 4 Bytes per element
2388   11A3 29                  ADD     HL,HL
2389   11A4 C1                  POP     BC              ; Start of array
2390   11A5 09                  ADD     HL,BC           ; Point to element
2391   11A6 EB                  EX      DE,HL           ; Address of element to DE
2392   11A7 2A 15 81    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   11AA C9                  RET
2394   11AB             
2395   11AB 2A 1F 81    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   11AE EB                  EX      DE,HL           ; To DE
2397   11AF 21 00 00            LD      HL,0            ; End of free memory
2398   11B2 39                  ADD     HL,SP           ; Current stack value
2399   11B3 3A F2 80            LD      A,(TYPE)        ; Dummy argument type
2400   11B6 B7                  OR      A
2401   11B7 CA C7 11            JP      Z,FRENUM        ; Numeric - Free variable space
2402   11BA CD 2E 14            CALL    GSTRCU          ; Current string to pool
2403   11BD CD 2E 13            CALL    GARBGE          ; Garbage collection
2404   11C0 2A 9F 80            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   11C3 EB                  EX      DE,HL           ; To DE
2406   11C4 2A 08 81            LD      HL,(STRBOT)     ; Bottom of string space
2407   11C7 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   11C8 93                  SUB     E               ; Subtract LSB of beginning
2409   11C9 4F                  LD      C,A             ; Save difference if C
2410   11CA 7C                  LD      A,H             ; Get MSB of end
2411   11CB 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   11CC 41          ACPASS: LD      B,C             ; Return integer AC
2413   11CD 50          ABPASS: LD      D,B             ; Return integer AB
2414   11CE 1E 00               LD      E,0
2415   11D0 21 F2 80            LD      HL,TYPE         ; Point to type
2416   11D3 73                  LD      (HL),E          ; Set type to numeric
2417   11D4 06 90               LD      B,80H+16        ; 16 bit integer
2418   11D6 C3 0B 18            JP      RETINT          ; Return the integr
2419   11D9             
2420   11D9 3A F0 80    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   11DC 47          PASSA:  LD      B,A             ; Put A into AB
2422   11DD AF                  XOR     A               ; Zero A
2423   11DE C3 CD 11            JP      ABPASS          ; Return integer AB
2424   11E1             
2425   11E1 CD 64 12    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   11E4 CD 56 12            CALL    IDTEST          ; Test for illegal direct
2427   11E7 01 3C 0B            LD      BC,DATA         ; To get next statement
2428   11EA C5                  PUSH    BC              ; Save address for RETurn
2429   11EB D5                  PUSH    DE              ; Save address of function ptr
2430   11EC CD 1B 08            CALL    CHKSYN          ; Make sure "(" follows
2431   11EF 28                  .BYTE      "("
2432   11F0 CD 08 10            CALL    GETVAR          ; Get argument variable name
2433   11F3 E5                  PUSH    HL              ; Save code string address
2434   11F4 EB                  EX      DE,HL           ; Argument address to HL
2435   11F5 2B                  DEC     HL
2436   11F6 56                  LD      D,(HL)          ; Get first byte of arg name
2437   11F7 2B                  DEC     HL
2438   11F8 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   11F9 E1                  POP     HL              ; Restore code string address
2440   11FA CD 15 0E            CALL    TSTNUM          ; Make sure numeric argument
2441   11FD CD 1B 08            CALL    CHKSYN          ; Make sure ")" follows
2442   1200 29                  .BYTE      ")"
2443   1201 CD 1B 08            CALL    CHKSYN          ; Make sure "=" follows
2444   1204 B4                  .BYTE      ZEQUAL          ; "=" token
2445   1205 44                  LD      B,H             ; Code string address to BC
2446   1206 4D                  LD      C,L
2447   1207 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   1208 71                  LD      (HL),C          ; Save LSB of FN code string
2449   1209 23                  INC     HL
2450   120A 70                  LD      (HL),B          ; Save MSB of FN code string
2451   120B C3 A3 12            JP      SVSTAD          ; Save address and do function
2452   120E             
2453   120E CD 64 12    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   1211 D5                  PUSH    DE              ; Save function pointer address
2455   1212 CD E9 0E            CALL    EVLPAR          ; Evaluate expression in "()"
2456   1215 CD 15 0E            CALL    TSTNUM          ; Make sure numeric result
2457   1218 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   1219 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   121A 23                  INC     HL
2460   121B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   121C 23                  INC     HL
2462   121D 7A                  LD      A,D             ; And function DEFined?
2463   121E B3                  OR      E
2464   121F CA 59 05            JP      Z,UFERR         ; No - ?UF Error
2465   1222 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   1223 23                  INC     HL
2467   1224 66                  LD      H,(HL)          ; Get MSB of argument address
2468   1225 6F                  LD      L,A             ; HL = Arg variable address
2469   1226 E5                  PUSH    HL              ; Save it
2470   1227 2A 23 81            LD      HL,(FNRGNM)     ; Get old argument name
2471   122A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   122B 22 23 81            LD      (FNRGNM),HL     ; Set new argument name
2473   122E 2A 27 81            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   1231 E5                  PUSH    HL              ; Save it
2475   1232 2A 25 81            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   1235 E5                  PUSH    HL              ; Save it
2477   1236 21 25 81            LD      HL,FNARG        ; HL = Value of argument
2478   1239 D5                  PUSH    DE              ; Save FN code string address
2479   123A CD 4C 18            CALL    FPTHL           ; Move FPREG to argument
2480   123D E1                  POP     HL              ; Get FN code string address
2481   123E CD 12 0E            CALL    GETNUM          ; Get value from function
2482   1241 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   1242 CD A5 09            CALL    GETCHR          ; Get next character
2484   1245 C2 4D 05            JP      NZ,SNERR        ; Bad character in FN - Error
2485   1248 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   1249 22 25 81            LD      (FNARG),HL      ; Restore it
2487   124C E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   124D 22 27 81            LD      (FNARG+2),HL    ; Restore it
2489   1250 E1                  POP     HL              ; Get name of old arg
2490   1251 22 23 81            LD      (FNRGNM),HL     ; Restore it
2491   1254 E1                  POP     HL              ; Restore code string address
2492   1255 C9                  RET
2493   1256             
2494   1256 E5          IDTEST: PUSH    HL              ; Save code string address
2495   1257 2A A1 80            LD      HL,(LINEAT)     ; Get current line number
2496   125A 23                  INC     HL              ; -1 means direct statement
2497   125B 7C                  LD      A,H
2498   125C B5                  OR      L
2499   125D E1                  POP     HL              ; Restore code string address
2500   125E C0                  RET     NZ              ; Return if in program
2501   125F 1E 16               LD      E,ID            ; ?ID Error
2502   1261 C3 61 05            JP      ERROR
2503   1264             
2504   1264 CD 1B 08    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   1267 A7                  .BYTE      ZFN             ; "FN" token
2506   1268 3E 80               LD      A,80H
2507   126A 32 10 81            LD      (FORFLG),A      ; Flag FN name to find
2508   126D B6                  OR      (HL)            ; FN name has bit 7 set
2509   126E 47                  LD      B,A             ; in first byte of name
2510   126F CD 0D 10            CALL    GTFNAM          ; Get FN name
2511   1272 C3 15 0E            JP      TSTNUM          ; Make sure numeric function
2512   1275             
2513   1275 CD 15 0E    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   1278 CD 99 19            CALL    NUMASC          ; Turn number into text
2515   127B CD A9 12    STR1:   CALL    CRTST           ; Create string entry for it
2516   127E CD 2E 14            CALL    GSTRCU          ; Current string to pool
2517   1281 01 89 14            LD      BC,TOPOOL       ; Save in string pool
2518   1284 C5                  PUSH    BC              ; Save address on stack
2519   1285             
2520   1285 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   1286 23                  INC     HL
2522   1287 23                  INC     HL
2523   1288 E5                  PUSH    HL              ; Save pointer to string
2524   1289 CD 04 13            CALL    TESTR           ; See if enough string space
2525   128C E1                  POP     HL              ; Restore pointer to string
2526   128D 4E                  LD      C,(HL)          ; Get LSB of address
2527   128E 23                  INC     HL
2528   128F 46                  LD      B,(HL)          ; Get MSB of address
2529   1290 CD 9D 12            CALL    CRTMST          ; Create string entry
2530   1293 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   1294 6F                  LD      L,A             ; Length of string
2532   1295 CD 21 14            CALL    TOSTRA          ; Move to string area
2533   1298 D1                  POP     DE              ; Restore pointer to MSB
2534   1299 C9                  RET
2535   129A             
2536   129A CD 04 13    MKTMST: CALL    TESTR           ; See if enough string space
2537   129D 21 04 81    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   12A0 E5                  PUSH    HL              ; Save it
2539   12A1 77                  LD      (HL),A          ; Save length of string
2540   12A2 23                  INC     HL
2541   12A3 23          SVSTAD: INC     HL
2542   12A4 73                  LD      (HL),E          ; Save LSB of address
2543   12A5 23                  INC     HL
2544   12A6 72                  LD      (HL),D          ; Save MSB of address
2545   12A7 E1                  POP     HL              ; Restore pointer
2546   12A8 C9                  RET
2547   12A9             
2548   12A9 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   12AA 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   12AC 50                  LD      D,B             ; Quote to D
2551   12AD E5          DTSTR:  PUSH    HL              ; Save start
2552   12AE 0E FF               LD      C,-1            ; Set counter to -1
2553   12B0 23          QTSTLP: INC     HL              ; Move on
2554   12B1 7E                  LD      A,(HL)          ; Get byte
2555   12B2 0C                  INC     C               ; Count bytes
2556   12B3 B7                  OR      A               ; End of line?
2557   12B4 CA BF 12            JP      Z,CRTSTE        ; Yes - Create string entry
2558   12B7 BA                  CP      D               ; Terminator D found?
2559   12B8 CA BF 12            JP      Z,CRTSTE        ; Yes - Create string entry
2560   12BB B8                  CP      B               ; Terminator B found?
2561   12BC C2 B0 12            JP      NZ,QTSTLP       ; No - Keep looking
2562   12BF FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   12C1 CC A5 09            CALL    Z,GETCHR        ; Yes - Get next character
2564   12C4 E3                  EX      (SP),HL         ; Starting quote
2565   12C5 23                  INC     HL              ; First byte of string
2566   12C6 EB                  EX      DE,HL           ; To DE
2567   12C7 79                  LD      A,C             ; Get length
2568   12C8 CD 9D 12            CALL    CRTMST          ; Create string entry
2569   12CB 11 04 81    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   12CE 2A F6 80            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   12D1 22 29 81            LD      (FPREG),HL      ; Save address of string ptr
2572   12D4 3E 01               LD      A,1
2573   12D6 32 F2 80            LD      (TYPE),A        ; Set type to string
2574   12D9 CD 4F 18            CALL    DETHL4          ; Move string to pool
2575   12DC CD 15 08            CALL    CPDEHL          ; Out of string pool?
2576   12DF 22 F6 80            LD      (TMSTPT),HL     ; Save new pointer
2577   12E2 E1                  POP     HL              ; Restore code string address
2578   12E3 7E                  LD      A,(HL)          ; Get next code byte
2579   12E4 C0                  RET     NZ              ; Return if pool OK
2580   12E5 1E 1E               LD      E,ST            ; ?ST Error
2581   12E7 C3 61 05            JP      ERROR           ; String pool overflow
2582   12EA             
2583   12EA 23          PRNUMS: INC     HL              ; Skip leading space
2584   12EB CD A9 12    PRS:    CALL    CRTST           ; Create string entry for it
2585   12EE CD 2E 14    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   12F1 CD 43 18            CALL    LOADFP          ; Move string block to BCDE
2587   12F4 1C                  INC     E               ; Length + 1
2588   12F5 1D          PRSLP:  DEC     E               ; Count characters
2589   12F6 C8                  RET     Z               ; End of string
2590   12F7 0A                  LD      A,(BC)          ; Get byte to output
2591   12F8 CD 26 08            CALL    OUTC            ; Output character in A
2592   12FB FE 0D               CP      CR              ; Return?
2593   12FD CC 57 0C            CALL    Z,DONULL        ; Yes - Do nulls
2594   1300 03                  INC     BC              ; Next byte in string
2595   1301 C3 F5 12            JP      PRSLP           ; More characters to output
2596   1304             
2597   1304 B7          TESTR:  OR      A               ; Test if enough room
2598   1305 0E                  .BYTE      0EH             ; No garbage collection done
2599   1306 F1          GRBDON: POP     AF              ; Garbage collection done
2600   1307 F5                  PUSH    AF              ; Save status
2601   1308 2A 9F 80            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   130B EB                  EX      DE,HL           ; To DE
2603   130C 2A 08 81            LD      HL,(STRBOT)     ; Bottom of string area
2604   130F 2F                  CPL                     ; Negate length (Top down)
2605   1310 4F                  LD      C,A             ; -Length to BC
2606   1311 06 FF               LD      B,-1            ; BC = -ve length of string
2607   1313 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   1314 23                  INC     HL              ; Plus one for 2's complement
2609   1315 CD 15 08            CALL    CPDEHL          ; Below string RAM area?
2610   1318 DA 22 13            JP      C,TESTOS        ; Tidy up if not done else err
2611   131B 22 08 81            LD      (STRBOT),HL     ; Save new bottom of area
2612   131E 23                  INC     HL              ; Point to first byte of string
2613   131F EB                  EX      DE,HL           ; Address to DE
2614   1320 F1          POPAF:  POP     AF              ; Throw away status push
2615   1321 C9                  RET
2616   1322             
2617   1322 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   1323 1E 1A               LD      E,OS            ; ?OS Error
2619   1325 CA 61 05            JP      Z,ERROR         ; Yes - Not enough string apace
2620   1328 BF                  CP      A               ; Flag garbage collect done
2621   1329 F5                  PUSH    AF              ; Save status
2622   132A 01 06 13            LD      BC,GRBDON       ; Garbage collection done
2623   132D C5                  PUSH    BC              ; Save for RETurn
2624   132E 2A F4 80    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   1331 22 08 81    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   1334 21 00 00            LD      HL,0
2627   1337 E5                  PUSH    HL              ; Flag no string found
2628   1338 2A 9F 80            LD      HL,(STRSPC)     ; Get bottom of string space
2629   133B E5                  PUSH    HL              ; Save bottom of string space
2630   133C 21 F8 80            LD      HL,TMSTPL       ; Temporary string pool
2631   133F EB          GRBLP:  EX      DE,HL
2632   1340 2A F6 80            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   1343 EB                  EX      DE,HL
2634   1344 CD 15 08            CALL    CPDEHL          ; Temporary string pool done?
2635   1347 01 3F 13            LD      BC,GRBLP        ; Loop until string pool done
2636   134A C2 93 13            JP      NZ,STPOOL       ; No - See if in string area
2637   134D 2A 1B 81            LD      HL,(PROGND)     ; Start of simple variables
2638   1350 EB          SMPVAR: EX      DE,HL
2639   1351 2A 1D 81            LD      HL,(VAREND)     ; End of simple variables
2640   1354 EB                  EX      DE,HL
2641   1355 CD 15 08            CALL    CPDEHL          ; All simple strings done?
2642   1358 CA 66 13            JP      Z,ARRLP         ; Yes - Do string arrays
2643   135B 7E                  LD      A,(HL)          ; Get type of variable
2644   135C 23                  INC     HL
2645   135D 23                  INC     HL
2646   135E B7                  OR      A               ; "S" flag set if string
2647   135F CD 96 13            CALL    STRADD          ; See if string in string area
2648   1362 C3 50 13            JP      SMPVAR          ; Loop until simple ones done
2649   1365             
2650   1365 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   1366 EB          ARRLP:  EX      DE,HL
2652   1367 2A 1F 81            LD      HL,(ARREND)     ; End of string arrays
2653   136A EB                  EX      DE,HL
2654   136B CD 15 08            CALL    CPDEHL          ; All string arrays done?
2655   136E CA BC 13            JP      Z,SCNEND        ; Yes - Move string if found
2656   1371 CD 43 18            CALL    LOADFP          ; Get array name to BCDE
2657   1374 7B                  LD      A,E             ; Get type of array
2658   1375 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   1376 09                  ADD     HL,BC           ; Start of next array
2660   1377 B7                  OR      A               ; Test type of array
2661   1378 F2 65 13            JP      P,GNXARY        ; Numeric array - Ignore it
2662   137B 22 0A 81            LD      (CUROPR),HL     ; Save address of next array
2663   137E E1                  POP     HL              ; Get address of num of dim'ns
2664   137F 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   1380 06 00               LD      B,0
2666   1382 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   1383 09                  ADD     HL,BC
2668   1384 23                  INC     HL              ; Plus one for number of dim'ns
2669   1385 EB          GRBARY: EX      DE,HL
2670   1386 2A 0A 81            LD      HL,(CUROPR)     ; Get address of next array
2671   1389 EB                  EX      DE,HL
2672   138A CD 15 08            CALL    CPDEHL          ; Is this array finished?
2673   138D CA 66 13            JP      Z,ARRLP         ; Yes - Get next one
2674   1390 01 85 13            LD      BC,GRBARY       ; Loop until array all done
2675   1393 C5          STPOOL: PUSH    BC              ; Save return address
2676   1394 F6 80               OR      80H             ; Flag string type
2677   1396 7E          STRADD: LD      A,(HL)          ; Get string length
2678   1397 23                  INC     HL
2679   1398 23                  INC     HL
2680   1399 5E                  LD      E,(HL)          ; Get LSB of string address
2681   139A 23                  INC     HL
2682   139B 56                  LD      D,(HL)          ; Get MSB of string address
2683   139C 23                  INC     HL
2684   139D F0                  RET     P               ; Not a string - Return
2685   139E B7                  OR      A               ; Set flags on string length
2686   139F C8                  RET     Z               ; Null string - Return
2687   13A0 44                  LD      B,H             ; Save variable pointer
2688   13A1 4D                  LD      C,L
2689   13A2 2A 08 81            LD      HL,(STRBOT)     ; Bottom of new area
2690   13A5 CD 15 08            CALL    CPDEHL          ; String been done?
2691   13A8 60                  LD      H,B             ; Restore variable pointer
2692   13A9 69                  LD      L,C
2693   13AA D8                  RET     C               ; String done - Ignore
2694   13AB E1                  POP     HL              ; Return address
2695   13AC E3                  EX      (SP),HL         ; Lowest available string area
2696   13AD CD 15 08            CALL    CPDEHL          ; String within string area?
2697   13B0 E3                  EX      (SP),HL         ; Lowest available string area
2698   13B1 E5                  PUSH    HL              ; Re-save return address
2699   13B2 60                  LD      H,B             ; Restore variable pointer
2700   13B3 69                  LD      L,C
2701   13B4 D0                  RET     NC              ; Outside string area - Ignore
2702   13B5 C1                  POP     BC              ; Get return , Throw 2 away
2703   13B6 F1                  POP     AF              ;
2704   13B7 F1                  POP     AF              ;
2705   13B8 E5                  PUSH    HL              ; Save variable pointer
2706   13B9 D5                  PUSH    DE              ; Save address of current
2707   13BA C5                  PUSH    BC              ; Put back return address
2708   13BB C9                  RET                     ; Go to it
2709   13BC             
2710   13BC D1          SCNEND: POP     DE              ; Addresses of strings
2711   13BD E1                  POP     HL              ;
2712   13BE 7D                  LD      A,L             ; HL = 0 if no more to do
2713   13BF B4                  OR      H
2714   13C0 C8                  RET     Z               ; No more to do - Return
2715   13C1 2B                  DEC     HL
2716   13C2 46                  LD      B,(HL)          ; MSB of address of string
2717   13C3 2B                  DEC     HL
2718   13C4 4E                  LD      C,(HL)          ; LSB of address of string
2719   13C5 E5                  PUSH    HL              ; Save variable address
2720   13C6 2B                  DEC     HL
2721   13C7 2B                  DEC     HL
2722   13C8 6E                  LD      L,(HL)          ; HL = Length of string
2723   13C9 26 00               LD      H,0
2724   13CB 09                  ADD     HL,BC           ; Address of end of string+1
2725   13CC 50                  LD      D,B             ; String address to DE
2726   13CD 59                  LD      E,C
2727   13CE 2B                  DEC     HL              ; Last byte in string
2728   13CF 44                  LD      B,H             ; Address to BC
2729   13D0 4D                  LD      C,L
2730   13D1 2A 08 81            LD      HL,(STRBOT)     ; Current bottom of string area
2731   13D4 CD 1C 05            CALL    MOVSTR          ; Move string to new address
2732   13D7 E1                  POP     HL              ; Restore variable address
2733   13D8 71                  LD      (HL),C          ; Save new LSB of address
2734   13D9 23                  INC     HL
2735   13DA 70                  LD      (HL),B          ; Save new MSB of address
2736   13DB 69                  LD      L,C             ; Next string area+1 to HL
2737   13DC 60                  LD      H,B
2738   13DD 2B                  DEC     HL              ; Next string area address
2739   13DE C3 31 13            JP      GARBLP          ; Look for more strings
2740   13E1             
2741   13E1 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   13E2 E5                  PUSH    HL              ;
2743   13E3 2A 29 81            LD      HL,(FPREG)      ; Get first string
2744   13E6 E3                  EX      (SP),HL         ; Save first string
2745   13E7 CD 9B 0E            CALL    OPRND           ; Get second string
2746   13EA E3                  EX      (SP),HL         ; Restore first string
2747   13EB CD 16 0E            CALL    TSTSTR          ; Make sure it's a string
2748   13EE 7E                  LD      A,(HL)          ; Get length of second string
2749   13EF E5                  PUSH    HL              ; Save first string
2750   13F0 2A 29 81            LD      HL,(FPREG)      ; Get second string
2751   13F3 E5                  PUSH    HL              ; Save second string
2752   13F4 86                  ADD     A,(HL)          ; Add length of second string
2753   13F5 1E 1C               LD      E,LS            ; ?LS Error
2754   13F7 DA 61 05            JP      C,ERROR         ; String too long - Error
2755   13FA CD 9A 12            CALL    MKTMST          ; Make temporary string
2756   13FD D1                  POP     DE              ; Get second string to DE
2757   13FE CD 32 14            CALL    GSTRDE          ; Move to string pool if needed
2758   1401 E3                  EX      (SP),HL         ; Get first string
2759   1402 CD 31 14            CALL    GSTRHL          ; Move to string pool if needed
2760   1405 E5                  PUSH    HL              ; Save first string
2761   1406 2A 06 81            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   1409 EB                  EX      DE,HL           ; To DE
2763   140A CD 18 14            CALL    SSTSA           ; First string to string area
2764   140D CD 18 14            CALL    SSTSA           ; Second string to string area
2765   1410 21 30 0E            LD      HL,EVAL2        ; Return to evaluation loop
2766   1413 E3                  EX      (SP),HL         ; Save return,get code string
2767   1414 E5                  PUSH    HL              ; Save code string address
2768   1415 C3 CB 12            JP      TSTOPL          ; To temporary string to pool
2769   1418             
2770   1418 E1          SSTSA:  POP     HL              ; Return address
2771   1419 E3                  EX      (SP),HL         ; Get string block,save return
2772   141A 7E                  LD      A,(HL)          ; Get length of string
2773   141B 23                  INC     HL
2774   141C 23                  INC     HL
2775   141D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   141E 23                  INC     HL
2777   141F 46                  LD      B,(HL)          ; Get MSB of string address
2778   1420 6F                  LD      L,A             ; Length to L
2779   1421 2C          TOSTRA: INC     L               ; INC - DECed after
2780   1422 2D          TSALP:  DEC     L               ; Count bytes moved
2781   1423 C8                  RET     Z               ; End of string - Return
2782   1424 0A                  LD      A,(BC)          ; Get source
2783   1425 12                  LD      (DE),A          ; Save destination
2784   1426 03                  INC     BC              ; Next source
2785   1427 13                  INC     DE              ; Next destination
2786   1428 C3 22 14            JP      TSALP           ; Loop until string moved
2787   142B             
2788   142B CD 16 0E    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   142E 2A 29 81    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   1431 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   1432 CD 4C 14    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   1435 EB                  EX      DE,HL           ; Restore DE
2793   1436 C0                  RET     NZ              ; No - Return
2794   1437 D5                  PUSH    DE              ; Save string
2795   1438 50                  LD      D,B             ; String block address to DE
2796   1439 59                  LD      E,C
2797   143A 1B                  DEC     DE              ; Point to length
2798   143B 4E                  LD      C,(HL)          ; Get string length
2799   143C 2A 08 81            LD      HL,(STRBOT)     ; Current bottom of string area
2800   143F CD 15 08            CALL    CPDEHL          ; Last one in string area?
2801   1442 C2 4A 14            JP      NZ,POPHL        ; No - Return
2802   1445 47                  LD      B,A             ; Clear B (A=0)
2803   1446 09                  ADD     HL,BC           ; Remove string from str' area
2804   1447 22 08 81            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   144A E1          POPHL:  POP     HL              ; Restore string
2806   144B C9                  RET
2807   144C             
2808   144C 2A F6 80    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   144F 2B                  DEC     HL              ; Back
2810   1450 46                  LD      B,(HL)          ; Get MSB of address
2811   1451 2B                  DEC     HL              ; Back
2812   1452 4E                  LD      C,(HL)          ; Get LSB of address
2813   1453 2B                  DEC     HL              ; Back
2814   1454 2B                  DEC     HL              ; Back
2815   1455 CD 15 08            CALL    CPDEHL          ; String last in string pool?
2816   1458 C0                  RET     NZ              ; Yes - Leave it
2817   1459 22 F6 80            LD      (TMSTPT),HL     ; Save new string pool top
2818   145C C9                  RET
2819   145D             
2820   145D 01 DC 11    LEN:    LD      BC,PASSA        ; To return integer A
2821   1460 C5                  PUSH    BC              ; Save address
2822   1461 CD 2B 14    GETLEN: CALL    GETSTR          ; Get string and its length
2823   1464 AF                  XOR     A
2824   1465 57                  LD      D,A             ; Clear D
2825   1466 32 F2 80            LD      (TYPE),A        ; Set type to numeric
2826   1469 7E                  LD      A,(HL)          ; Get length of string
2827   146A B7                  OR      A               ; Set status flags
2828   146B C9                  RET
2829   146C             
2830   146C 01 DC 11    ASC:    LD      BC,PASSA        ; To return integer A
2831   146F C5                  PUSH    BC              ; Save address
2832   1470 CD 61 14    GTFLNM: CALL    GETLEN          ; Get length of string
2833   1473 CA 6C 0A            JP      Z,FCERR         ; Null string - Error
2834   1476 23                  INC     HL
2835   1477 23                  INC     HL
2836   1478 5E                  LD      E,(HL)          ; Get LSB of address
2837   1479 23                  INC     HL
2838   147A 56                  LD      D,(HL)          ; Get MSB of address
2839   147B 1A                  LD      A,(DE)          ; Get first byte of string
2840   147C C9                  RET
2841   147D             
2842   147D 3E 01       CHR:    LD      A,1             ; One character string
2843   147F CD 9A 12            CALL    MKTMST          ; Make a temporary string
2844   1482 CD 76 15            CALL    MAKINT          ; Make it integer A
2845   1485 2A 06 81            LD      HL,(TMPSTR+2)   ; Get address of string
2846   1488 73                  LD      (HL),E          ; Save character
2847   1489 C1          TOPOOL: POP     BC              ; Clean up stack
2848   148A C3 CB 12            JP      TSTOPL          ; Temporary string to pool
2849   148D             
2850   148D CD 26 15    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   1490 AF                  XOR     A               ; Start at first byte in string
2852   1491 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   1492 4F                  LD      C,A             ; Starting position in string
2854   1493 E5          MID1:   PUSH    HL              ; Save string block address
2855   1494 7E                  LD      A,(HL)          ; Get length of string
2856   1495 B8                  CP      B               ; Compare with number given
2857   1496 DA 9B 14            JP      C,ALLFOL        ; All following bytes required
2858   1499 78                  LD      A,B             ; Get new length
2859   149A 11                  .BYTE      11H             ; Skip "LD C,0"
2860   149B 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   149D C5                  PUSH    BC              ; Save position in string
2862   149E CD 04 13            CALL    TESTR           ; See if enough string space
2863   14A1 C1                  POP     BC              ; Get position in string
2864   14A2 E1                  POP     HL              ; Restore string block address
2865   14A3 E5                  PUSH    HL              ; And re-save it
2866   14A4 23                  INC     HL
2867   14A5 23                  INC     HL
2868   14A6 46                  LD      B,(HL)          ; Get LSB of address
2869   14A7 23                  INC     HL
2870   14A8 66                  LD      H,(HL)          ; Get MSB of address
2871   14A9 68                  LD      L,B             ; HL = address of string
2872   14AA 06 00               LD      B,0             ; BC = starting address
2873   14AC 09                  ADD     HL,BC           ; Point to that byte
2874   14AD 44                  LD      B,H             ; BC = source string
2875   14AE 4D                  LD      C,L
2876   14AF CD 9D 12            CALL    CRTMST          ; Create a string entry
2877   14B2 6F                  LD      L,A             ; Length of new string
2878   14B3 CD 21 14            CALL    TOSTRA          ; Move string to string area
2879   14B6 D1                  POP     DE              ; Clear stack
2880   14B7 CD 32 14            CALL    GSTRDE          ; Move to string pool if needed
2881   14BA C3 CB 12            JP      TSTOPL          ; Temporary string to pool
2882   14BD             
2883   14BD CD 26 15    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   14C0 D1                  POP     DE              ; Get string length
2885   14C1 D5                  PUSH    DE              ; And re-save
2886   14C2 1A                  LD      A,(DE)          ; Get length
2887   14C3 90                  SUB     B               ; Move back N bytes
2888   14C4 C3 91 14            JP      RIGHT1          ; Go and get sub-string
2889   14C7             
2890   14C7 EB          MID:    EX      DE,HL           ; Get code string address
2891   14C8 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   14C9 CD 2B 15            CALL    MIDNUM          ; Get number supplied
2893   14CC 04                  INC     B               ; Is it character zero?
2894   14CD 05                  DEC     B
2895   14CE CA 6C 0A            JP      Z,FCERR         ; Yes - Error
2896   14D1 C5                  PUSH    BC              ; Save starting position
2897   14D2 1E FF               LD      E,255           ; All of string
2898   14D4 FE 29               CP      ')'             ; Any length given?
2899   14D6 CA E0 14            JP      Z,RSTSTR        ; No - Rest of string
2900   14D9 CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
2901   14DC 2C                  .BYTE      ','
2902   14DD CD 73 15            CALL    GETINT          ; Get integer 0-255
2903   14E0 CD 1B 08    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   14E3 29                  .BYTE      ")"
2905   14E4 F1                  POP     AF              ; Restore starting position
2906   14E5 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   14E6 01 93 14            LD      BC,MID1         ; Continuation of MID$ routine
2908   14E9 C5                  PUSH    BC              ; Save for return
2909   14EA 3D                  DEC     A               ; Starting position-1
2910   14EB BE                  CP      (HL)            ; Compare with length
2911   14EC 06 00               LD      B,0             ; Zero bytes length
2912   14EE D0                  RET     NC              ; Null string if start past end
2913   14EF 4F                  LD      C,A             ; Save starting position-1
2914   14F0 7E                  LD      A,(HL)          ; Get length of string
2915   14F1 91                  SUB     C               ; Subtract start
2916   14F2 BB                  CP      E               ; Enough string for it?
2917   14F3 47                  LD      B,A             ; Save maximum length available
2918   14F4 D8                  RET     C               ; Truncate string if needed
2919   14F5 43                  LD      B,E             ; Set specified length
2920   14F6 C9                  RET                     ; Go and create string
2921   14F7             
2922   14F7 CD 61 14    VAL:    CALL    GETLEN          ; Get length of string
2923   14FA CA 14 16            JP      Z,RESZER        ; Result zero
2924   14FD 5F                  LD      E,A             ; Save length
2925   14FE 23                  INC     HL
2926   14FF 23                  INC     HL
2927   1500 7E                  LD      A,(HL)          ; Get LSB of address
2928   1501 23                  INC     HL
2929   1502 66                  LD      H,(HL)          ; Get MSB of address
2930   1503 6F                  LD      L,A             ; HL = String address
2931   1504 E5                  PUSH    HL              ; Save string address
2932   1505 19                  ADD     HL,DE
2933   1506 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   1507 72                  LD      (HL),D          ; Zero it to terminate
2935   1508 E3                  EX      (SP),HL         ; Save string end,get start
2936   1509 C5                  PUSH    BC              ; Save end+1 byte
2937   150A 7E                  LD      A,(HL)          ; Get starting byte
2938   150B FE 24           CP	'$'		; Hex number indicated? [function added]
2939   150D C2 15 15        JP	NZ,VAL1
2940   1510 CD 3F 1D        CALL	HEXTFP		; Convert Hex to FPREG
2941   1513 18 0D           JR	VAL3
2942   1515 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   1517 C2 1F 15        JP	NZ,VAL2
2944   151A CD AF 1D        CALL	BINTFP		; Convert Bin to FPREG
2945   151D 18 03           JR	VAL3
2946   151F CD FB 18    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   1522 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   1523 E1                  POP     HL              ; Restore end+1 address
2949   1524 70                  LD      (HL),B          ; Put back original byte
2950   1525 C9                  RET
2951   1526             
2952   1526 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   1527 CD 1B 08            CALL    CHKSYN          ; Make sure ")" follows
2954   152A 29                  .BYTE      ")"
2955   152B C1          MIDNUM: POP     BC              ; Get return address
2956   152C D1                  POP     DE              ; Get number supplied
2957   152D C5                  PUSH    BC              ; Re-save return address
2958   152E 43                  LD      B,E             ; Number to B
2959   152F C9                  RET
2960   1530             
2961   1530 CD 76 15    INP:    CALL    MAKINT          ; Make it integer A
2962   1533 32 84 80            LD      (INPORT),A      ; Set input port
2963   1536 CD 83 80            CALL    INPSUB          ; Get input from port
2964   1539 C3 DC 11            JP      PASSA           ; Return integer A
2965   153C             
2966   153C CD 60 15    POUT:   CALL    SETIO           ; Set up port number
2967   153F C3 4B 80            JP      OUTSUB          ; Output data and return
2968   1542             
2969   1542 CD 60 15    WAIT:   CALL    SETIO           ; Set up port number
2970   1545 F5                  PUSH    AF              ; Save AND mask
2971   1546 1E 00               LD      E,0             ; Assume zero if none given
2972   1548 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   1549 CD A5 09            CALL    GETCHR          ; Get next character
2974   154C CA 56 15            JP      Z,NOXOR         ; No XOR byte given
2975   154F CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
2976   1552 2C                  .BYTE      ','
2977   1553 CD 73 15            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   1556 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   1557 CD 83 80    WAITLP: CALL    INPSUB          ; Get input
2980   155A AB                  XOR     E               ; Flip selected bits
2981   155B A0                  AND     B               ; Result non-zero?
2982   155C CA 57 15            JP      Z,WAITLP        ; No = keep waiting
2983   155F C9                  RET
2984   1560             
2985   1560 CD 73 15    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   1563 32 84 80            LD      (INPORT),A      ; Set input port
2987   1566 32 4C 80            LD      (OTPORT),A      ; Set output port
2988   1569 CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
2989   156C 2C                  .BYTE      ','
2990   156D C3 73 15            JP      GETINT          ; Get integer 0-255 and return
2991   1570             
2992   1570 CD A5 09    FNDNUM: CALL    GETCHR          ; Get next character
2993   1573 CD 12 0E    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   1576 CD 51 0A    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   1579 7A                  LD      A,D             ; Get MSB of number
2996   157A B7                  OR      A               ; Zero?
2997   157B C2 6C 0A            JP      NZ,FCERR        ; No - Error
2998   157E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   157F CD A5 09            CALL    GETCHR          ; Get next character
3000   1582 7B                  LD      A,E             ; Get number to A
3001   1583 C9                  RET
3002   1584             
3003   1584 CD 57 0A    PEEK:   CALL    DEINT           ; Get memory address
3004   1587 1A                  LD      A,(DE)          ; Get byte in memory
3005   1588 C3 DC 11            JP      PASSA           ; Return integer A
3006   158B             
3007   158B CD 12 0E    POKE:   CALL    GETNUM          ; Get memory address
3008   158E CD 57 0A            CALL    DEINT           ; Get integer -32768 to 3276
3009   1591 D5                  PUSH    DE              ; Save memory address
3010   1592 CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
3011   1595 2C                  .BYTE      ','
3012   1596 CD 73 15            CALL    GETINT          ; Get integer 0-255
3013   1599 D1                  POP     DE              ; Restore memory address
3014   159A 12                  LD      (DE),A          ; Load it into memory
3015   159B C9                  RET
3016   159C             
3017   159C 21 72 1A    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   159F CD 43 18    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   15A2 C3 AE 15            JP      FPADD           ; Add BCDE to FPREG
3020   15A5             
3021   15A5 CD 43 18    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   15A8 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   15A9 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   15AA D1                  POP     DE
3025   15AB CD 1D 18    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   15AE 78          FPADD:  LD      A,B             ; Get FP exponent
3027   15AF B7                  OR      A               ; Is number zero?
3028   15B0 C8                  RET     Z               ; Yes - Nothing to add
3029   15B1 3A 2C 81            LD      A,(FPEXP)       ; Get FPREG exponent
3030   15B4 B7                  OR      A               ; Is this number zero?
3031   15B5 CA 35 18            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   15B8 90                  SUB     B               ; BCDE number larger?
3033   15B9 D2 C8 15            JP      NC,NOSWAP       ; No - Don't swap them
3034   15BC 2F                  CPL                     ; Two's complement
3035   15BD 3C                  INC     A               ;  FP exponent
3036   15BE EB                  EX      DE,HL
3037   15BF CD 25 18            CALL    STAKFP          ; Put FPREG on stack
3038   15C2 EB                  EX      DE,HL
3039   15C3 CD 35 18            CALL    FPBCDE          ; Move BCDE to FPREG
3040   15C6 C1                  POP     BC              ; Restore number from stack
3041   15C7 D1                  POP     DE
3042   15C8 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   15CA D0                  RET     NC              ; Yes - First number is result
3044   15CB F5                  PUSH    AF              ; Save number of bits to scale
3045   15CC CD 5A 18            CALL    SIGNS           ; Set MSBs & sign of result
3046   15CF 67                  LD      H,A             ; Save sign of result
3047   15D0 F1                  POP     AF              ; Restore scaling factor
3048   15D1 CD 73 16            CALL    SCALE           ; Scale BCDE to same exponent
3049   15D4 B4                  OR      H               ; Result to be positive?
3050   15D5 21 29 81            LD      HL,FPREG        ; Point to FPREG
3051   15D8 F2 EE 15            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   15DB CD 53 16            CALL    PLUCDE          ; Add FPREG to CDE
3053   15DE D2 34 16            JP      NC,RONDUP       ; No overflow - Round it up
3054   15E1 23                  INC     HL              ; Point to exponent
3055   15E2 34                  INC     (HL)            ; Increment it
3056   15E3 CA 5C 05            JP      Z,OVERR         ; Number overflowed - Error
3057   15E6 2E 01               LD      L,1             ; 1 bit to shift right
3058   15E8 CD 89 16            CALL    SHRT1           ; Shift result right
3059   15EB C3 34 16            JP      RONDUP          ; Round it up
3060   15EE             
3061   15EE AF          MINCDE: XOR     A               ; Clear A and carry
3062   15EF 90                  SUB     B               ; Negate exponent
3063   15F0 47                  LD      B,A             ; Re-save exponent
3064   15F1 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   15F2 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   15F3 5F                  LD      E,A             ; Save LSB of BCDE
3067   15F4 23                  INC     HL
3068   15F5 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   15F6 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   15F7 57                  LD      D,A             ; Save NMSB of BCDE
3071   15F8 23                  INC     HL
3072   15F9 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   15FA 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   15FB 4F                  LD      C,A             ; Save MSB of BCDE
3075   15FC DC 5F 16    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   15FF             
3077   15FF 68          BNORM:  LD      L,B             ; L = Exponent
3078   1600 63                  LD      H,E             ; H = LSB
3079   1601 AF                  XOR     A
3080   1602 47          BNRMLP: LD      B,A             ; Save bit count
3081   1603 79                  LD      A,C             ; Get MSB
3082   1604 B7                  OR      A               ; Is it zero?
3083   1605 C2 21 16            JP      NZ,PNORM        ; No - Do it bit at a time
3084   1608 4A                  LD      C,D             ; MSB = NMSB
3085   1609 54                  LD      D,H             ; NMSB= LSB
3086   160A 65                  LD      H,L             ; LSB = VLSB
3087   160B 6F                  LD      L,A             ; VLSB= 0
3088   160C 78                  LD      A,B             ; Get exponent
3089   160D D6 08               SUB     8               ; Count 8 bits
3090   160F FE E0               CP      -24-8           ; Was number zero?
3091   1611 C2 02 16            JP      NZ,BNRMLP       ; No - Keep normalising
3092   1614 AF          RESZER: XOR     A               ; Result is zero
3093   1615 32 2C 81    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   1618 C9                  RET
3095   1619             
3096   1619 05          NORMAL: DEC     B               ; Count bits
3097   161A 29                  ADD     HL,HL           ; Shift HL left
3098   161B 7A                  LD      A,D             ; Get NMSB
3099   161C 17                  RLA                     ; Shift left with last bit
3100   161D 57                  LD      D,A             ; Save NMSB
3101   161E 79                  LD      A,C             ; Get MSB
3102   161F 8F                  ADC     A,A             ; Shift left with last bit
3103   1620 4F                  LD      C,A             ; Save MSB
3104   1621 F2 19 16    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   1624 78                  LD      A,B             ; Number of bits shifted
3106   1625 5C                  LD      E,H             ; Save HL in EB
3107   1626 45                  LD      B,L
3108   1627 B7                  OR      A               ; Any shifting done?
3109   1628 CA 34 16            JP      Z,RONDUP        ; No - Round it up
3110   162B 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3111   162E 86                  ADD     A,(HL)          ; Add shifted bits
3112   162F 77                  LD      (HL),A          ; Re-save exponent
3113   1630 D2 14 16            JP      NC,RESZER       ; Underflow - Result is zero
3114   1633 C8                  RET     Z               ; Result is zero
3115   1634 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   1635 21 2C 81    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   1638 B7                  OR      A               ; Any rounding?
3118   1639 FC 46 16            CALL    M,FPROND        ; Yes - Round number up
3119   163C 46                  LD      B,(HL)          ; B = Exponent
3120   163D 23                  INC     HL
3121   163E 7E                  LD      A,(HL)          ; Get sign of result
3122   163F E6 80               AND     10000000B       ; Only bit 7 needed
3123   1641 A9                  XOR     C               ; Set correct sign
3124   1642 4F                  LD      C,A             ; Save correct sign in number
3125   1643 C3 35 18            JP      FPBCDE          ; Move BCDE to FPREG
3126   1646             
3127   1646 1C          FPROND: INC     E               ; Round LSB
3128   1647 C0                  RET     NZ              ; Return if ok
3129   1648 14                  INC     D               ; Round NMSB
3130   1649 C0                  RET     NZ              ; Return if ok
3131   164A 0C                  INC     C               ; Round MSB
3132   164B C0                  RET     NZ              ; Return if ok
3133   164C 0E 80               LD      C,80H           ; Set normal value
3134   164E 34                  INC     (HL)            ; Increment exponent
3135   164F C0                  RET     NZ              ; Return if ok
3136   1650 C3 5C 05            JP      OVERR           ; Overflow error
3137   1653             
3138   1653 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   1654 83                  ADD     A,E             ; Add LSB of BCDE
3140   1655 5F                  LD      E,A             ; Save LSB of BCDE
3141   1656 23                  INC     HL
3142   1657 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   1658 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   1659 57                  LD      D,A             ; Save NMSB of BCDE
3145   165A 23                  INC     HL
3146   165B 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   165C 89                  ADC     A,C             ; Add MSB of BCDE
3148   165D 4F                  LD      C,A             ; Save MSB of BCDE
3149   165E C9                  RET
3150   165F             
3151   165F 21 2D 81    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   1662 7E                  LD      A,(HL)          ; Get sign of result
3153   1663 2F                  CPL                     ; Negate it
3154   1664 77                  LD      (HL),A          ; Put it back
3155   1665 AF                  XOR     A
3156   1666 6F                  LD      L,A             ; Set L to zero
3157   1667 90                  SUB     B               ; Negate exponent,set carry
3158   1668 47                  LD      B,A             ; Re-save exponent
3159   1669 7D                  LD      A,L             ; Load zero
3160   166A 9B                  SBC     A,E             ; Negate LSB
3161   166B 5F                  LD      E,A             ; Re-save LSB
3162   166C 7D                  LD      A,L             ; Load zero
3163   166D 9A                  SBC     A,D             ; Negate NMSB
3164   166E 57                  LD      D,A             ; Re-save NMSB
3165   166F 7D                  LD      A,L             ; Load zero
3166   1670 99                  SBC     A,C             ; Negate MSB
3167   1671 4F                  LD      C,A             ; Re-save MSB
3168   1672 C9                  RET
3169   1673             
3170   1673 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   1675 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   1677 DA 82 16            JP      C,SHRITE        ; No - Shift right A bits
3173   167A 43                  LD      B,E             ; <- Shift
3174   167B 5A                  LD      E,D             ; <- right
3175   167C 51                  LD      D,C             ; <- eight
3176   167D 0E 00               LD      C,0             ; <- bits
3177   167F C3 75 16            JP      SCALLP          ; More bits to shift
3178   1682             
3179   1682 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   1684 6F                  LD      L,A             ; Save bits to shift
3181   1685 AF          SHRLP:  XOR     A               ; Flag for all done
3182   1686 2D                  DEC     L               ; All shifting done?
3183   1687 C8                  RET     Z               ; Yes - Return
3184   1688 79                  LD      A,C             ; Get MSB
3185   1689 1F          SHRT1:  RRA                     ; Shift it right
3186   168A 4F                  LD      C,A             ; Re-save
3187   168B 7A                  LD      A,D             ; Get NMSB
3188   168C 1F                  RRA                     ; Shift right with last bit
3189   168D 57                  LD      D,A             ; Re-save it
3190   168E 7B                  LD      A,E             ; Get LSB
3191   168F 1F                  RRA                     ; Shift right with last bit
3192   1690 5F                  LD      E,A             ; Re-save it
3193   1691 78                  LD      A,B             ; Get underflow
3194   1692 1F                  RRA                     ; Shift right with last bit
3195   1693 47                  LD      B,A             ; Re-save underflow
3196   1694 C3 85 16            JP      SHRLP           ; More bits to do
3197   1697             
3198   1697 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   169B             
3200   169B 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   169C AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   16A0 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   16A4 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   16A8             
3205   16A8 CD F4 17    LOG:    CALL    TSTSGN          ; Test sign of value
3206   16AB B7                  OR      A
3207   16AC EA 6C 0A            JP      PE,FCERR        ; ?FC Error if <= zero
3208   16AF 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3209   16B2 7E                  LD      A,(HL)          ; Get exponent
3210   16B3 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   16B6 11 F3 04            LD      DE,04F3H
3212   16B9 90                  SUB     B               ; Scale value to be < 1
3213   16BA F5                  PUSH    AF              ; Save scale factor
3214   16BB 70                  LD      (HL),B          ; Save new exponent
3215   16BC D5                  PUSH    DE              ; Save SQR(1/2)
3216   16BD C5                  PUSH    BC
3217   16BE CD AE 15            CALL    FPADD           ; Add SQR(1/2) to value
3218   16C1 C1                  POP     BC              ; Restore SQR(1/2)
3219   16C2 D1                  POP     DE
3220   16C3 04                  INC     B               ; Make it SQR(2)
3221   16C4 CD 4A 17            CALL    DVBCDE          ; Divide by SQR(2)
3222   16C7 21 97 16            LD      HL,UNITY        ; Point to 1.
3223   16CA CD A5 15            CALL    SUBPHL          ; Subtract FPREG from 1
3224   16CD 21 9B 16            LD      HL,LOGTAB       ; Coefficient table
3225   16D0 CD 3C 1B            CALL    SUMSER          ; Evaluate sum of series
3226   16D3 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   16D6 11 00 00            LD      DE,0000H
3228   16D9 CD AE 15            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   16DC F1                  POP     AF              ; Restore scale factor
3230   16DD CD 6F 19            CALL    RSCALE          ; Re-scale number
3231   16E0 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   16E3 11 18 72            LD      DE,7218H
3233   16E6 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   16E7             
3235   16E7 C1          MULT:   POP     BC              ; Get number from stack
3236   16E8 D1                  POP     DE
3237   16E9 CD F4 17    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   16EC C8                  RET     Z               ; Return zero if zero
3239   16ED 2E 00               LD      L,0             ; Flag add exponents
3240   16EF CD B2 17            CALL    ADDEXP          ; Add exponents
3241   16F2 79                  LD      A,C             ; Get MSB of multiplier
3242   16F3 32 3B 81            LD      (MULVAL),A      ; Save MSB of multiplier
3243   16F6 EB                  EX      DE,HL
3244   16F7 22 3C 81            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   16FA 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   16FD 50                  LD      D,B
3247   16FE 58                  LD      E,B
3248   16FF 21 FF 15            LD      HL,BNORM        ; Address of normalise
3249   1702 E5                  PUSH    HL              ; Save for return
3250   1703 21 0B 17            LD      HL,MULT8        ; Address of 8 bit multiply
3251   1706 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   1707 E5                  PUSH    HL              ;
3253   1708 21 29 81            LD      HL,FPREG        ; Point to number
3254   170B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   170C 23                  INC     HL              ; Point to NMSB
3256   170D B7                  OR      A               ; Test LSB
3257   170E CA 37 17            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   1711 E5                  PUSH    HL              ; Save address of number
3259   1712 2E 08               LD      L,8             ; 8 bits to multiply by
3260   1714 1F          MUL8LP: RRA                     ; Shift LSB right
3261   1715 67                  LD      H,A             ; Save LSB
3262   1716 79                  LD      A,C             ; Get MSB
3263   1717 D2 25 17            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   171A E5                  PUSH    HL              ; Save LSB and count
3265   171B 2A 3C 81            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   171E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   171F EB                  EX      DE,HL           ; Leave sum in DE
3268   1720 E1                  POP     HL              ; Restore MSB and count
3269   1721 3A 3B 81            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   1724 89                  ADC     A,C             ; Add MSB
3271   1725 1F          NOMADD: RRA                     ; Shift MSB right
3272   1726 4F                  LD      C,A             ; Re-save MSB
3273   1727 7A                  LD      A,D             ; Get NMSB
3274   1728 1F                  RRA                     ; Shift NMSB right
3275   1729 57                  LD      D,A             ; Re-save NMSB
3276   172A 7B                  LD      A,E             ; Get LSB
3277   172B 1F                  RRA                     ; Shift LSB right
3278   172C 5F                  LD      E,A             ; Re-save LSB
3279   172D 78                  LD      A,B             ; Get VLSB
3280   172E 1F                  RRA                     ; Shift VLSB right
3281   172F 47                  LD      B,A             ; Re-save VLSB
3282   1730 2D                  DEC     L               ; Count bits multiplied
3283   1731 7C                  LD      A,H             ; Get LSB of multiplier
3284   1732 C2 14 17            JP      NZ,MUL8LP       ; More - Do it
3285   1735 E1          POPHRT: POP     HL              ; Restore address of number
3286   1736 C9                  RET
3287   1737             
3288   1737 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   1738 5A                  LD      E,D
3290   1739 51                  LD      D,C
3291   173A 4F                  LD      C,A
3292   173B C9                  RET
3293   173C             
3294   173C CD 25 18    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   173F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   1742 11 00 00            LD      DE,0000H
3297   1745 CD 35 18            CALL    FPBCDE          ; Move 10 to FPREG
3298   1748             
3299   1748 C1          DIV:    POP     BC              ; Get number from stack
3300   1749 D1                  POP     DE
3301   174A CD F4 17    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   174D CA 50 05            JP      Z,DZERR         ; Error if division by zero
3303   1750 2E FF               LD      L,-1            ; Flag subtract exponents
3304   1752 CD B2 17            CALL    ADDEXP          ; Subtract exponents
3305   1755 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   1756 34                  INC     (HL)
3307   1757 2B                  DEC     HL              ; Point to MSB
3308   1758 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   1759 32 57 80            LD      (DIV3),A        ; Save for subtraction
3310   175C 2B                  DEC     HL
3311   175D 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   175E 32 53 80            LD      (DIV2),A        ; Save for subtraction
3313   1761 2B                  DEC     HL
3314   1762 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   1763 32 4F 80            LD      (DIV1),A        ; Save for subtraction
3316   1766 41                  LD      B,C             ; Get MSB
3317   1767 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   1768 AF                  XOR     A
3319   1769 4F                  LD      C,A             ; Clear MSB of quotient
3320   176A 57                  LD      D,A             ; Clear NMSB of quotient
3321   176B 5F                  LD      E,A             ; Clear LSB of quotient
3322   176C 32 5A 80            LD      (DIV4),A        ; Clear overflow count
3323   176F E5          DIVLP:  PUSH    HL              ; Save divisor
3324   1770 C5                  PUSH    BC
3325   1771 7D                  LD      A,L             ; Get LSB of number
3326   1772 CD 4E 80            CALL    DIVSUP          ; Subt' divisor from dividend
3327   1775 DE 00               SBC     A,0             ; Count for overflows
3328   1777 3F                  CCF
3329   1778 D2 82 17            JP      NC,RESDIV       ; Restore divisor if borrow
3330   177B 32 5A 80            LD      (DIV4),A        ; Re-save overflow count
3331   177E F1                  POP     AF              ; Scrap divisor
3332   177F F1                  POP     AF
3333   1780 37                  SCF                     ; Set carry to
3334   1781 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   1782             
3336   1782 C1          RESDIV: POP     BC              ; Restore divisor
3337   1783 E1                  POP     HL
3338   1784 79                  LD      A,C             ; Get MSB of quotient
3339   1785 3C                  INC     A
3340   1786 3D                  DEC     A
3341   1787 1F                  RRA                     ; Bit 0 to bit 7
3342   1788 FA 35 16            JP      M,RONDB         ; Done - Normalise result
3343   178B 17                  RLA                     ; Restore carry
3344   178C 7B                  LD      A,E             ; Get LSB of quotient
3345   178D 17                  RLA                     ; Double it
3346   178E 5F                  LD      E,A             ; Put it back
3347   178F 7A                  LD      A,D             ; Get NMSB of quotient
3348   1790 17                  RLA                     ; Double it
3349   1791 57                  LD      D,A             ; Put it back
3350   1792 79                  LD      A,C             ; Get MSB of quotient
3351   1793 17                  RLA                     ; Double it
3352   1794 4F                  LD      C,A             ; Put it back
3353   1795 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   1796 78                  LD      A,B             ; Get MSB of divisor
3355   1797 17                  RLA                     ; Double it
3356   1798 47                  LD      B,A             ; Put it back
3357   1799 3A 5A 80            LD      A,(DIV4)        ; Get VLSB of quotient
3358   179C 17                  RLA                     ; Double it
3359   179D 32 5A 80            LD      (DIV4),A        ; Put it back
3360   17A0 79                  LD      A,C             ; Get MSB of quotient
3361   17A1 B2                  OR      D               ; Merge NMSB
3362   17A2 B3                  OR      E               ; Merge LSB
3363   17A3 C2 6F 17            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   17A6 E5                  PUSH    HL              ; Save divisor
3365   17A7 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3366   17AA 35                  DEC     (HL)            ; Divide by 2
3367   17AB E1                  POP     HL              ; Restore divisor
3368   17AC C2 6F 17            JP      NZ,DIVLP        ; Ok - Keep going
3369   17AF C3 5C 05            JP      OVERR           ; Overflow error
3370   17B2             
3371   17B2 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   17B3 B7                  OR      A               ; Test it
3373   17B4 CA D6 17            JP      Z,OVTST3        ; Zero - Result zero
3374   17B7 7D                  LD      A,L             ; Get add/subtract flag
3375   17B8 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3376   17BB AE                  XOR     (HL)            ; Add or subtract it
3377   17BC 80                  ADD     A,B             ; Add the other exponent
3378   17BD 47                  LD      B,A             ; Save new exponent
3379   17BE 1F                  RRA                     ; Test exponent for overflow
3380   17BF A8                  XOR     B
3381   17C0 78                  LD      A,B             ; Get exponent
3382   17C1 F2 D5 17            JP      P,OVTST2        ; Positive - Test for overflow
3383   17C4 C6 80               ADD     A,80H           ; Add excess 128
3384   17C6 77                  LD      (HL),A          ; Save new exponent
3385   17C7 CA 35 17            JP      Z,POPHRT        ; Zero - Result zero
3386   17CA CD 5A 18            CALL    SIGNS           ; Set MSBs and sign of result
3387   17CD 77                  LD      (HL),A          ; Save new exponent
3388   17CE 2B                  DEC     HL              ; Point to MSB
3389   17CF C9                  RET
3390   17D0             
3391   17D0 CD F4 17    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   17D3 2F                  CPL                     ; Invert sign
3393   17D4 E1                  POP     HL              ; Clean up stack
3394   17D5 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   17D6 E1          OVTST3: POP     HL              ; Clear off return address
3396   17D7 F2 14 16            JP      P,RESZER        ; Result zero
3397   17DA C3 5C 05            JP      OVERR           ; Overflow error
3398   17DD             
3399   17DD CD 40 18    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   17E0 78                  LD      A,B             ; Get exponent
3401   17E1 B7                  OR      A               ; Is it zero?
3402   17E2 C8                  RET     Z               ; Yes - Result is zero
3403   17E3 C6 02               ADD     A,2             ; Multiply by 4
3404   17E5 DA 5C 05            JP      C,OVERR         ; Overflow - ?OV Error
3405   17E8 47                  LD      B,A             ; Re-save exponent
3406   17E9 CD AE 15            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   17EC 21 2C 81            LD      HL,FPEXP        ; Point to exponent
3408   17EF 34                  INC     (HL)            ; Double number (Times 10)
3409   17F0 C0                  RET     NZ              ; Ok - Return
3410   17F1 C3 5C 05            JP      OVERR           ; Overflow error
3411   17F4             
3412   17F4 3A 2C 81    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   17F7 B7                  OR      A
3414   17F8 C8                  RET     Z               ; RETurn if number is zero
3415   17F9 3A 2B 81            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   17FC FE                  .BYTE      0FEH            ; Test sign
3417   17FD 2F          RETREL: CPL                     ; Invert sign
3418   17FE 17                  RLA                     ; Sign bit to carry
3419   17FF 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   1800 C0                  RET     NZ              ; Return -1 if negative
3421   1801 3C                  INC     A               ; Bump to +1
3422   1802 C9                  RET                     ; Positive - Return +1
3423   1803             
3424   1803 CD F4 17    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   1806 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   1808 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   180B 21 2C 81    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   180E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   180F 70                  LD      (HL),B          ; Save exponent
3430   1810 06 00               LD      B,0             ; CDE = integer to normalise
3431   1812 23                  INC     HL              ; Point to sign of result
3432   1813 36 80               LD      (HL),80H        ; Set sign of result
3433   1815 17                  RLA                     ; Carry = sign of integer
3434   1816 C3 FC 15            JP      CONPOS          ; Set sign of result
3435   1819             
3436   1819 CD F4 17    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   181C F0                  RET     P               ; Return if positive
3438   181D 21 2B 81    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   1820 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   1821 EE 80               XOR     80H             ; Invert sign of mantissa
3441   1823 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   1824 C9                  RET
3443   1825             
3444   1825 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   1826 2A 29 81            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   1829 E3                  EX      (SP),HL         ; Stack them,get return
3447   182A E5                  PUSH    HL              ; Re-save return
3448   182B 2A 2B 81            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   182E E3                  EX      (SP),HL         ; Stack them,get return
3450   182F E5                  PUSH    HL              ; Re-save return
3451   1830 EB                  EX      DE,HL           ; Restore code string address
3452   1831 C9                  RET
3453   1832             
3454   1832 CD 43 18    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   1835 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   1836 22 29 81            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   1839 60                  LD      H,B             ; Exponent of number
3458   183A 69                  LD      L,C             ; MSB of number
3459   183B 22 2B 81            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   183E EB                  EX      DE,HL           ; Restore code string address
3461   183F C9                  RET
3462   1840             
3463   1840 21 29 81    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   1843 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   1844 23                  INC     HL
3466   1845 56                  LD      D,(HL)          ; Get NMSB of number
3467   1846 23                  INC     HL
3468   1847 4E                  LD      C,(HL)          ; Get MSB of number
3469   1848 23                  INC     HL
3470   1849 46                  LD      B,(HL)          ; Get exponent of number
3471   184A 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   184B C9                  RET
3473   184C             
3474   184C 11 29 81    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   184F 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   1851 1A          DETHLB: LD      A,(DE)          ; Get source
3477   1852 77                  LD      (HL),A          ; Save destination
3478   1853 13                  INC     DE              ; Next source
3479   1854 23                  INC     HL              ; Next destination
3480   1855 05                  DEC     B               ; Count bytes
3481   1856 C2 51 18            JP      NZ,DETHLB       ; Loop if more
3482   1859 C9                  RET
3483   185A             
3484   185A 21 2B 81    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   185D 7E                  LD      A,(HL)          ; Get MSB
3486   185E 07                  RLCA                    ; Old sign to carry
3487   185F 37                  SCF                     ; Set MSBit
3488   1860 1F                  RRA                     ; Set MSBit of MSB
3489   1861 77                  LD      (HL),A          ; Save new MSB
3490   1862 3F                  CCF                     ; Complement sign
3491   1863 1F                  RRA                     ; Old sign to carry
3492   1864 23                  INC     HL
3493   1865 23                  INC     HL
3494   1866 77                  LD      (HL),A          ; Set sign of result
3495   1867 79                  LD      A,C             ; Get MSB
3496   1868 07                  RLCA                    ; Old sign to carry
3497   1869 37                  SCF                     ; Set MSBit
3498   186A 1F                  RRA                     ; Set MSBit of MSB
3499   186B 4F                  LD      C,A             ; Save MSB
3500   186C 1F                  RRA
3501   186D AE                  XOR     (HL)            ; New sign of result
3502   186E C9                  RET
3503   186F             
3504   186F 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   1870 B7                  OR      A
3506   1871 CA F4 17            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   1874 21 FD 17            LD      HL,RETREL       ; Return relation routine
3508   1877 E5                  PUSH    HL              ; Save for return
3509   1878 CD F4 17            CALL    TSTSGN          ; Test sign of FPREG
3510   187B 79                  LD      A,C             ; Get MSB of number
3511   187C C8                  RET     Z               ; FPREG zero - Number's MSB
3512   187D 21 2B 81            LD      HL,FPREG+2      ; MSB of FPREG
3513   1880 AE                  XOR     (HL)            ; Combine signs
3514   1881 79                  LD      A,C             ; Get MSB of number
3515   1882 F8                  RET     M               ; Exit if signs different
3516   1883 CD 89 18            CALL    CMPFP           ; Compare FP numbers
3517   1886 1F                  RRA                     ; Get carry to sign
3518   1887 A9                  XOR     C               ; Combine with MSB of number
3519   1888 C9                  RET
3520   1889             
3521   1889 23          CMPFP:  INC     HL              ; Point to exponent
3522   188A 78                  LD      A,B             ; Get exponent
3523   188B BE                  CP      (HL)            ; Compare exponents
3524   188C C0                  RET     NZ              ; Different
3525   188D 2B                  DEC     HL              ; Point to MBS
3526   188E 79                  LD      A,C             ; Get MSB
3527   188F BE                  CP      (HL)            ; Compare MSBs
3528   1890 C0                  RET     NZ              ; Different
3529   1891 2B                  DEC     HL              ; Point to NMSB
3530   1892 7A                  LD      A,D             ; Get NMSB
3531   1893 BE                  CP      (HL)            ; Compare NMSBs
3532   1894 C0                  RET     NZ              ; Different
3533   1895 2B                  DEC     HL              ; Point to LSB
3534   1896 7B                  LD      A,E             ; Get LSB
3535   1897 96                  SUB     (HL)            ; Compare LSBs
3536   1898 C0                  RET     NZ              ; Different
3537   1899 E1                  POP     HL              ; Drop RETurn
3538   189A E1                  POP     HL              ; Drop another RETurn
3539   189B C9                  RET
3540   189C             
3541   189C 47          FPINT:  LD      B,A             ; <- Move
3542   189D 4F                  LD      C,A             ; <- exponent
3543   189E 57                  LD      D,A             ; <- to all
3544   189F 5F                  LD      E,A             ; <- bits
3545   18A0 B7                  OR      A               ; Test exponent
3546   18A1 C8                  RET     Z               ; Zero - Return zero
3547   18A2 E5                  PUSH    HL              ; Save pointer to number
3548   18A3 CD 40 18            CALL    BCDEFP          ; Move FPREG to BCDE
3549   18A6 CD 5A 18            CALL    SIGNS           ; Set MSBs & sign of result
3550   18A9 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   18AA 67                  LD      H,A             ; Save combined signs
3552   18AB FC C0 18            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   18AE 3E 98               LD      A,80H+24        ; 24 bits
3554   18B0 90                  SUB     B               ; Bits to shift
3555   18B1 CD 73 16            CALL    SCALE           ; Shift BCDE
3556   18B4 7C                  LD      A,H             ; Get combined sign
3557   18B5 17                  RLA                     ; Sign to carry
3558   18B6 DC 46 16            CALL    C,FPROND        ; Negative - Round number up
3559   18B9 06 00               LD      B,0             ; Zero exponent
3560   18BB DC 5F 16            CALL    C,COMPL         ; If negative make positive
3561   18BE E1                  POP     HL              ; Restore pointer to number
3562   18BF C9                  RET
3563   18C0             
3564   18C0 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   18C1 7A                  LD      A,D             ; Test LSBs
3566   18C2 A3                  AND     E
3567   18C3 3C                  INC     A
3568   18C4 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   18C5 0B                  DEC     BC              ; Decrement MSBs
3570   18C6 C9                  RET
3571   18C7             
3572   18C7 21 2C 81    INT:    LD      HL,FPEXP        ; Point to exponent
3573   18CA 7E                  LD      A,(HL)          ; Get exponent
3574   18CB FE 98               CP      80H+24          ; Integer accuracy only?
3575   18CD 3A 29 81            LD      A,(FPREG)       ; Get LSB
3576   18D0 D0                  RET     NC              ; Yes - Already integer
3577   18D1 7E                  LD      A,(HL)          ; Get exponent
3578   18D2 CD 9C 18            CALL    FPINT           ; F.P to integer
3579   18D5 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   18D7 7B                  LD      A,E             ; Get LSB of number
3581   18D8 F5                  PUSH    AF              ; Save LSB
3582   18D9 79                  LD      A,C             ; Get MSB of number
3583   18DA 17                  RLA                     ; Sign to carry
3584   18DB CD FC 15            CALL    CONPOS          ; Set sign of result
3585   18DE F1                  POP     AF              ; Restore LSB of number
3586   18DF C9                  RET
3587   18E0             
3588   18E0 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   18E3 78                  LD      A,B             ; Test multiplier
3590   18E4 B1                  OR      C
3591   18E5 C8                  RET     Z               ; Return zero if zero
3592   18E6 3E 10               LD      A,16            ; 16 bits
3593   18E8 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   18E9 DA 20 11            JP      C,BSERR         ; ?BS Error if overflow
3595   18EC EB                  EX      DE,HL
3596   18ED 29                  ADD     HL,HL           ; Shift multiplier left
3597   18EE EB                  EX      DE,HL
3598   18EF D2 F6 18            JP      NC,NOMLAD       ; Bit was zero - No add
3599   18F2 09                  ADD     HL,BC           ; Add multiplicand
3600   18F3 DA 20 11            JP      C,BSERR         ; ?BS Error if overflow
3601   18F6 3D          NOMLAD: DEC     A               ; Count bits
3602   18F7 C2 E8 18            JP      NZ,MLDBLP       ; More
3603   18FA C9                  RET
3604   18FB             
3605   18FB FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   18FD F5                  PUSH    AF              ; Save it and flags
3607   18FE CA 07 19            JP      Z,CNVNUM        ; Yes - Convert number
3608   1901 FE 2B               CP      '+'             ; Positive?
3609   1903 CA 07 19            JP      Z,CNVNUM        ; Yes - Convert number
3610   1906 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   1907 CD 14 16    CNVNUM: CALL    RESZER          ; Set result to zero
3612   190A 47                  LD      B,A             ; Digits after point counter
3613   190B 57                  LD      D,A             ; Sign of exponent
3614   190C 5F                  LD      E,A             ; Exponent of ten
3615   190D 2F                  CPL
3616   190E 4F                  LD      C,A             ; Before or after point flag
3617   190F CD A5 09    MANLP:  CALL    GETCHR          ; Get next character
3618   1912 DA 58 19            JP      C,ADDIG         ; Digit - Add to number
3619   1915 FE 2E               CP      '.'
3620   1917 CA 33 19            JP      Z,DPOINT        ; '.' - Flag point
3621   191A FE 45               CP      'E'
3622   191C C2 37 19            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   191F CD A5 09            CALL    GETCHR          ; Get next character
3624   1922 CD 4B 0F            CALL    SGNEXP          ; Get sign of exponent
3625   1925 CD A5 09    EXPLP:  CALL    GETCHR          ; Get next character
3626   1928 DA 7A 19            JP      C,EDIGIT        ; Digit - Add to exponent
3627   192B 14                  INC     D               ; Is sign negative?
3628   192C C2 37 19            JP      NZ,CONEXP       ; No - Scale number
3629   192F AF                  XOR     A
3630   1930 93                  SUB     E               ; Negate exponent
3631   1931 5F                  LD      E,A             ; And re-save it
3632   1932 0C                  INC     C               ; Flag end of number
3633   1933 0C          DPOINT: INC     C               ; Flag point passed
3634   1934 CA 0F 19            JP      Z,MANLP         ; Zero - Get another digit
3635   1937 E5          CONEXP: PUSH    HL              ; Save code string address
3636   1938 7B                  LD      A,E             ; Get exponent
3637   1939 90                  SUB     B               ; Subtract digits after point
3638   193A F4 50 19    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   193D F2 46 19            JP      P,ENDCON        ; Positive - All done
3640   1940 F5                  PUSH    AF              ; Save number of times to /10
3641   1941 CD 3C 17            CALL    DIV10           ; Divide by 10
3642   1944 F1                  POP     AF              ; Restore count
3643   1945 3C                  INC     A               ; Count divides
3644   1946             
3645   1946 C2 3A 19    ENDCON: JP      NZ,SCALMI       ; More to do
3646   1949 D1                  POP     DE              ; Restore code string address
3647   194A F1                  POP     AF              ; Restore sign of number
3648   194B CC 1D 18            CALL    Z,INVSGN        ; Negative - Negate number
3649   194E EB                  EX      DE,HL           ; Code string address to HL
3650   194F C9                  RET
3651   1950             
3652   1950 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   1951 F5          MULTEN: PUSH    AF              ; Save count
3654   1952 CD DD 17            CALL    MLSP10          ; Multiply number by 10
3655   1955 F1                  POP     AF              ; Restore count
3656   1956 3D                  DEC     A               ; Count multiplies
3657   1957 C9                  RET
3658   1958             
3659   1958 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   1959 57                  LD      D,A             ; Save digit
3661   195A 78                  LD      A,B             ; Get digits after point
3662   195B 89                  ADC     A,C             ; Add one if after point
3663   195C 47                  LD      B,A             ; Re-save counter
3664   195D C5                  PUSH    BC              ; Save point flags
3665   195E E5                  PUSH    HL              ; Save code string address
3666   195F D5                  PUSH    DE              ; Save digit
3667   1960 CD DD 17            CALL    MLSP10          ; Multiply number by 10
3668   1963 F1                  POP     AF              ; Restore digit
3669   1964 D6 30               SUB     '0'             ; Make it absolute
3670   1966 CD 6F 19            CALL    RSCALE          ; Re-scale number
3671   1969 E1                  POP     HL              ; Restore code string address
3672   196A C1                  POP     BC              ; Restore point flags
3673   196B D1                  POP     DE              ; Restore sign of exponent
3674   196C C3 0F 19            JP      MANLP           ; Get another digit
3675   196F             
3676   196F CD 25 18    RSCALE: CALL    STAKFP          ; Put number on stack
3677   1972 CD 06 18            CALL    FLGREL          ; Digit to add to FPREG
3678   1975 C1          PADD:   POP     BC              ; Restore number
3679   1976 D1                  POP     DE
3680   1977 C3 AE 15            JP      FPADD           ; Add BCDE to FPREG and return
3681   197A             
3682   197A 7B          EDIGIT: LD      A,E             ; Get digit
3683   197B 07                  RLCA                    ; Times 2
3684   197C 07                  RLCA                    ; Times 4
3685   197D 83                  ADD     A,E             ; Times 5
3686   197E 07                  RLCA                    ; Times 10
3687   197F 86                  ADD     A,(HL)          ; Add next digit
3688   1980 D6 30               SUB     '0'             ; Make it absolute
3689   1982 5F                  LD      E,A             ; Save new digit
3690   1983 C3 25 19            JP      EXPLP           ; Look for another digit
3691   1986             
3692   1986 E5          LINEIN: PUSH    HL              ; Save code string address
3693   1987 21 E5 04            LD      HL,INMSG        ; Output " in "
3694   198A CD EB 12            CALL    PRS             ; Output string at HL
3695   198D E1                  POP     HL              ; Restore code string address
3696   198E EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   198F AF                  XOR     A
3698   1990 06 98               LD      B,80H+24        ; 24 bits
3699   1992 CD 0B 18            CALL    RETINT          ; Return the integer
3700   1995 21 EA 12            LD      HL,PRNUMS       ; Print number string
3701   1998 E5                  PUSH    HL              ; Save for return
3702   1999 21 2E 81    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   199C E5                  PUSH    HL              ; Save for return
3704   199D CD F4 17            CALL    TSTSGN          ; Test sign of FPREG
3705   19A0 36 20               LD      (HL),' '        ; Space at start
3706   19A2 F2 A7 19            JP      P,SPCFST        ; Positive - Space to start
3707   19A5 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   19A7 23          SPCFST: INC     HL              ; First byte of number
3709   19A8 36 30               LD      (HL),'0'        ; '0' if zero
3710   19AA CA 5D 1A            JP      Z,JSTZER        ; Return '0' if zero
3711   19AD E5                  PUSH    HL              ; Save buffer address
3712   19AE FC 1D 18            CALL    M,INVSGN        ; Negate FPREG if negative
3713   19B1 AF                  XOR     A               ; Zero A
3714   19B2 F5                  PUSH    AF              ; Save it
3715   19B3 CD 63 1A            CALL    RNGTST          ; Test number is in range
3716   19B6 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   19B9 11 F8 4F            LD      DE,4FF8H
3718   19BC CD 6F 18            CALL    CMPNUM          ; Compare numbers
3719   19BF B7                  OR      A
3720   19C0 E2 D4 19            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   19C3 F1                  POP     AF              ; Restore count
3722   19C4 CD 51 19            CALL    MULTEN          ; Multiply by ten
3723   19C7 F5                  PUSH    AF              ; Re-save count
3724   19C8 C3 B6 19            JP      SIXDIG          ; Test it again
3725   19CB             
3726   19CB CD 3C 17    GTSIXD: CALL    DIV10           ; Divide by 10
3727   19CE F1                  POP     AF              ; Get count
3728   19CF 3C                  INC     A               ; Count divides
3729   19D0 F5                  PUSH    AF              ; Re-save count
3730   19D1 CD 63 1A            CALL    RNGTST          ; Test number is in range
3731   19D4 CD 9C 15    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   19D7 3C                  INC     A
3733   19D8 CD 9C 18            CALL    FPINT           ; F.P to integer
3734   19DB CD 35 18            CALL    FPBCDE          ; Move BCDE to FPREG
3735   19DE 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   19E1 F1                  POP     AF              ; Restore count
3737   19E2 81                  ADD     A,C             ; 6 digits before point
3738   19E3 3C                  INC     A               ; Add one
3739   19E4 FA F0 19            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   19E7 FE 08               CP      6+1+1           ; More than 999999 ?
3741   19E9 D2 F0 19            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   19EC 3C                  INC     A               ; Adjust for exponent
3743   19ED 47                  LD      B,A             ; Exponent of number
3744   19EE 3E 02               LD      A,2             ; Make it zero after
3745   19F0             
3746   19F0 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   19F1 3D                  DEC     A
3748   19F2 E1                  POP     HL              ; Restore buffer address
3749   19F3 F5                  PUSH    AF              ; Save count
3750   19F4 11 76 1A            LD      DE,POWERS       ; Powers of ten
3751   19F7 05                  DEC     B               ; Count digits before point
3752   19F8 C2 01 1A            JP      NZ,DIGTXT       ; Not zero - Do number
3753   19FB 36 2E               LD      (HL),'.'        ; Save point
3754   19FD 23                  INC     HL              ; Move on
3755   19FE 36 30               LD      (HL),'0'        ; Save zero
3756   1A00 23                  INC     HL              ; Move on
3757   1A01 05          DIGTXT: DEC     B               ; Count digits before point
3758   1A02 36 2E               LD      (HL),'.'        ; Save point in case
3759   1A04 CC 4A 18            CALL    Z,INCHL         ; Last digit - move on
3760   1A07 C5                  PUSH    BC              ; Save digits before point
3761   1A08 E5                  PUSH    HL              ; Save buffer address
3762   1A09 D5                  PUSH    DE              ; Save powers of ten
3763   1A0A CD 40 18            CALL    BCDEFP          ; Move FPREG to BCDE
3764   1A0D E1                  POP     HL              ; Powers of ten table
3765   1A0E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   1A10 04          TRYAGN: INC     B               ; Count subtractions
3767   1A11 7B                  LD      A,E             ; Get LSB
3768   1A12 96                  SUB     (HL)            ; Subtract LSB
3769   1A13 5F                  LD      E,A             ; Save LSB
3770   1A14 23                  INC     HL
3771   1A15 7A                  LD      A,D             ; Get NMSB
3772   1A16 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   1A17 57                  LD      D,A             ; Save NMSB
3774   1A18 23                  INC     HL
3775   1A19 79                  LD      A,C             ; Get MSB
3776   1A1A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   1A1B 4F                  LD      C,A             ; Save MSB
3778   1A1C 2B                  DEC     HL              ; Point back to start
3779   1A1D 2B                  DEC     HL
3780   1A1E D2 10 1A            JP      NC,TRYAGN       ; No overflow - Try again
3781   1A21 CD 53 16            CALL    PLUCDE          ; Restore number
3782   1A24 23                  INC     HL              ; Start of next number
3783   1A25 CD 35 18            CALL    FPBCDE          ; Move BCDE to FPREG
3784   1A28 EB                  EX      DE,HL           ; Save point in table
3785   1A29 E1                  POP     HL              ; Restore buffer address
3786   1A2A 70                  LD      (HL),B          ; Save digit in buffer
3787   1A2B 23                  INC     HL              ; And move on
3788   1A2C C1                  POP     BC              ; Restore digit count
3789   1A2D 0D                  DEC     C               ; Count digits
3790   1A2E C2 01 1A            JP      NZ,DIGTXT       ; More - Do them
3791   1A31 05                  DEC     B               ; Any decimal part?
3792   1A32 CA 41 1A            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   1A35 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   1A36 7E                  LD      A,(HL)          ; Get character
3795   1A37 FE 30               CP      '0'             ; '0' character?
3796   1A39 CA 35 1A            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   1A3C FE 2E               CP      '.'             ; A decimal point?
3798   1A3E C4 4A 18            CALL    NZ,INCHL        ; Move back over digit
3799   1A41             
3800   1A41 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   1A42 CA 60 1A            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   1A45 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   1A47 23                  INC     HL              ; And move on
3804   1A48 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   1A4A F2 51 1A            JP      P,OUTEXP        ; Positive - Output exponent
3806   1A4D 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   1A4F 2F                  CPL                     ; Negate exponent
3808   1A50 3C                  INC     A
3809   1A51 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   1A53 04          EXPTEN: INC     B               ; Count subtractions
3811   1A54 D6 0A               SUB     10              ; Tens digit
3812   1A56 D2 53 1A            JP      NC,EXPTEN       ; More to do
3813   1A59 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   1A5B 23                  INC     HL              ; Move on
3815   1A5C 70                  LD      (HL),B          ; Save MSB of exponent
3816   1A5D 23          JSTZER: INC     HL              ;
3817   1A5E 77                  LD      (HL),A          ; Save LSB of exponent
3818   1A5F 23                  INC     HL
3819   1A60 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   1A61 E1                  POP     HL              ; Restore code string address
3821   1A62 C9                  RET
3822   1A63             
3823   1A63 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   1A66 11 F7 23            LD      DE,23F7H
3825   1A69 CD 6F 18            CALL    CMPNUM          ; Compare numbers
3826   1A6C B7                  OR      A
3827   1A6D E1                  POP     HL              ; Return address to HL
3828   1A6E E2 CB 19            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   1A71 E9                  JP      (HL)            ; Otherwise return to caller
3830   1A72             
3831   1A72 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   1A76             
3833   1A76 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   1A79 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   1A7C E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   1A7F 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   1A82 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   1A85 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   1A88             
3840   1A88 21 1D 18    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   1A8B E3                  EX      (SP),HL         ; To be done after caller
3842   1A8C E9                  JP      (HL)            ; Return to caller
3843   1A8D             
3844   1A8D CD 25 18    SQR:    CALL    STAKFP          ; Put value on stack
3845   1A90 21 72 1A            LD      HL,HALF         ; Set power to 1/2
3846   1A93 CD 32 18            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   1A96             
3848   1A96 C1          POWER:  POP     BC              ; Get base
3849   1A97 D1                  POP     DE
3850   1A98 CD F4 17            CALL    TSTSGN          ; Test sign of power
3851   1A9B 78                  LD      A,B             ; Get exponent of base
3852   1A9C CA DB 1A            JP      Z,EXP           ; Make result 1 if zero
3853   1A9F F2 A6 1A            JP      P,POWER1        ; Positive base - Ok
3854   1AA2 B7                  OR      A               ; Zero to negative power?
3855   1AA3 CA 50 05            JP      Z,DZERR         ; Yes - ?/0 Error
3856   1AA6 B7          POWER1: OR      A               ; Base zero?
3857   1AA7 CA 15 16            JP      Z,SAVEXP        ; Yes - Return zero
3858   1AAA D5                  PUSH    DE              ; Save base
3859   1AAB C5                  PUSH    BC
3860   1AAC 79                  LD      A,C             ; Get MSB of base
3861   1AAD F6 7F               OR      01111111B       ; Get sign status
3862   1AAF CD 40 18            CALL    BCDEFP          ; Move power to BCDE
3863   1AB2 F2 C3 1A            JP      P,POWER2        ; Positive base - Ok
3864   1AB5 D5                  PUSH    DE              ; Save power
3865   1AB6 C5                  PUSH    BC
3866   1AB7 CD C7 18            CALL    INT             ; Get integer of power
3867   1ABA C1                  POP     BC              ; Restore power
3868   1ABB D1                  POP     DE
3869   1ABC F5                  PUSH    AF              ; MSB of base
3870   1ABD CD 6F 18            CALL    CMPNUM          ; Power an integer?
3871   1AC0 E1                  POP     HL              ; Restore MSB of base
3872   1AC1 7C                  LD      A,H             ; but don't affect flags
3873   1AC2 1F                  RRA                     ; Exponent odd or even?
3874   1AC3 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   1AC4 22 2B 81            LD      (FPREG+2),HL    ; Save base in FPREG
3876   1AC7 E1                  POP     HL              ; LSBs of base
3877   1AC8 22 29 81            LD      (FPREG),HL      ; Save in FPREG
3878   1ACB DC 88 1A            CALL    C,NEGAFT        ; Odd power - Negate result
3879   1ACE CC 1D 18            CALL    Z,INVSGN        ; Negative base - Negate it
3880   1AD1 D5                  PUSH    DE              ; Save power
3881   1AD2 C5                  PUSH    BC
3882   1AD3 CD A8 16            CALL    LOG             ; Get LOG of base
3883   1AD6 C1                  POP     BC              ; Restore power
3884   1AD7 D1                  POP     DE
3885   1AD8 CD E9 16            CALL    FPMULT          ; Multiply LOG by power
3886   1ADB             
3887   1ADB CD 25 18    EXP:    CALL    STAKFP          ; Put value on stack
3888   1ADE 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   1AE1 11 3B AA            LD      DE,0AA3BH
3890   1AE4 CD E9 16            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   1AE7 3A 2C 81            LD      A,(FPEXP)       ; Get exponent
3892   1AEA FE 88               CP      80H+8           ; Is it in range?
3893   1AEC D2 D0 17            JP      NC,OVTST1       ; No - Test for overflow
3894   1AEF CD C7 18            CALL    INT             ; Get INT of FPREG
3895   1AF2 C6 80               ADD     A,80H           ; For excess 128
3896   1AF4 C6 02               ADD     A,2             ; Exponent > 126?
3897   1AF6 DA D0 17            JP      C,OVTST1        ; Yes - Test for overflow
3898   1AF9 F5                  PUSH    AF              ; Save scaling factor
3899   1AFA 21 97 16            LD      HL,UNITY        ; Point to 1.
3900   1AFD CD 9F 15            CALL    ADDPHL          ; Add 1 to FPREG
3901   1B00 CD E0 16            CALL    MULLN2          ; Multiply by LN(2)
3902   1B03 F1                  POP     AF              ; Restore scaling factor
3903   1B04 C1                  POP     BC              ; Restore exponent
3904   1B05 D1                  POP     DE
3905   1B06 F5                  PUSH    AF              ; Save scaling factor
3906   1B07 CD AB 15            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   1B0A CD 1D 18            CALL    INVSGN          ; Negate result
3908   1B0D 21 1B 1B            LD      HL,EXPTAB       ; Coefficient table
3909   1B10 CD 4B 1B            CALL    SMSER1          ; Sum the series
3910   1B13 11 00 00            LD      DE,0            ; Zero LSBs
3911   1B16 C1                  POP     BC              ; Scaling factor
3912   1B17 4A                  LD      C,D             ; Zero MSB
3913   1B18 C3 E9 16            JP      FPMULT          ; Scale result to correct value
3914   1B1B             
3915   1B1B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   1B1C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   1B20 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   1B24 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   1B28 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   1B2C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   1B30 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   1B34 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   1B38 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   1B3C             
3925   1B3C CD 25 18    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   1B3F 11 E7 16            LD      DE,MULT         ; Multiply by "X"
3927   1B42 D5                  PUSH    DE              ; To be done after
3928   1B43 E5                  PUSH    HL              ; Save address of table
3929   1B44 CD 40 18            CALL    BCDEFP          ; Move FPREG to BCDE
3930   1B47 CD E9 16            CALL    FPMULT          ; Square the value
3931   1B4A E1                  POP     HL              ; Restore address of table
3932   1B4B CD 25 18    SMSER1: CALL    STAKFP          ; Put value on stack
3933   1B4E 7E                  LD      A,(HL)          ; Get number of coefficients
3934   1B4F 23                  INC     HL              ; Point to start of table
3935   1B50 CD 32 18            CALL    PHLTFP          ; Move coefficient to FPREG
3936   1B53 06                  .BYTE      06H             ; Skip "POP AF"
3937   1B54 F1          SUMLP:  POP     AF              ; Restore count
3938   1B55 C1                  POP     BC              ; Restore number
3939   1B56 D1                  POP     DE
3940   1B57 3D                  DEC     A               ; Cont coefficients
3941   1B58 C8                  RET     Z               ; All done
3942   1B59 D5                  PUSH    DE              ; Save number
3943   1B5A C5                  PUSH    BC
3944   1B5B F5                  PUSH    AF              ; Save count
3945   1B5C E5                  PUSH    HL              ; Save address in table
3946   1B5D CD E9 16            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   1B60 E1                  POP     HL              ; Restore address in table
3948   1B61 CD 43 18            CALL    LOADFP          ; Number at HL to BCDE
3949   1B64 E5                  PUSH    HL              ; Save address in table
3950   1B65 CD AE 15            CALL    FPADD           ; Add coefficient to FPREG
3951   1B68 E1                  POP     HL              ; Restore address in table
3952   1B69 C3 54 1B            JP      SUMLP           ; More coefficients
3953   1B6C             
3954   1B6C CD F4 17    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   1B6F 21 5E 80            LD      HL,SEED+2       ; Random number seed
3956   1B72 FA CD 1B            JP      M,RESEED        ; Negative - Re-seed
3957   1B75 21 7F 80            LD      HL,LSTRND       ; Last random number
3958   1B78 CD 32 18            CALL    PHLTFP          ; Move last RND to FPREG
3959   1B7B 21 5E 80            LD      HL,SEED+2       ; Random number seed
3960   1B7E C8                  RET     Z               ; Return if RND(0)
3961   1B7F 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   1B80 E6 07               AND     00000111B       ; 0 to 7
3963   1B82 06 00               LD      B,0
3964   1B84 77                  LD      (HL),A          ; Re-save seed
3965   1B85 23                  INC     HL              ; Move to coefficient table
3966   1B86 87                  ADD     A,A             ; 4 bytes
3967   1B87 87                  ADD     A,A             ; per entry
3968   1B88 4F                  LD      C,A             ; BC = Offset into table
3969   1B89 09                  ADD     HL,BC           ; Point to coefficient
3970   1B8A CD 43 18            CALL    LOADFP          ; Coefficient to BCDE
3971   1B8D CD E9 16            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   1B90 3A 5D 80            LD      A,(SEED+1)      ; Get (SEED+1)
3973   1B93 3C                  INC     A               ; Add 1
3974   1B94 E6 03               AND     00000011B       ; 0 to 3
3975   1B96 06 00               LD      B,0
3976   1B98 FE 01               CP      1               ; Is it zero?
3977   1B9A 88                  ADC     A,B             ; Yes - Make it 1
3978   1B9B 32 5D 80            LD      (SEED+1),A      ; Re-save seed
3979   1B9E 21 D1 1B            LD      HL,RNDTAB-4     ; Addition table
3980   1BA1 87                  ADD     A,A             ; 4 bytes
3981   1BA2 87                  ADD     A,A             ; per entry
3982   1BA3 4F                  LD      C,A             ; BC = Offset into table
3983   1BA4 09                  ADD     HL,BC           ; Point to value
3984   1BA5 CD 9F 15            CALL    ADDPHL          ; Add value to FPREG
3985   1BA8 CD 40 18    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   1BAB 7B                  LD      A,E             ; Get LSB
3987   1BAC 59                  LD      E,C             ; LSB = MSB
3988   1BAD EE 4F               XOR     01001111B       ; Fiddle around
3989   1BAF 4F                  LD      C,A             ; New MSB
3990   1BB0 36 80               LD      (HL),80H        ; Set exponent
3991   1BB2 2B                  DEC     HL              ; Point to MSB
3992   1BB3 46                  LD      B,(HL)          ; Get MSB
3993   1BB4 36 80               LD      (HL),80H        ; Make value -0.5
3994   1BB6 21 5C 80            LD      HL,SEED         ; Random number seed
3995   1BB9 34                  INC     (HL)            ; Count seed
3996   1BBA 7E                  LD      A,(HL)          ; Get seed
3997   1BBB D6 AB               SUB     171             ; Do it modulo 171
3998   1BBD C2 C4 1B            JP      NZ,RND2         ; Non-zero - Ok
3999   1BC0 77                  LD      (HL),A          ; Zero seed
4000   1BC1 0C                  INC     C               ; Fillde about
4001   1BC2 15                  DEC     D               ; with the
4002   1BC3 1C                  INC     E               ; number
4003   1BC4 CD FF 15    RND2:   CALL    BNORM           ; Normalise number
4004   1BC7 21 7F 80            LD      HL,LSTRND       ; Save random number
4005   1BCA C3 4C 18            JP      FPTHL           ; Move FPREG to last and return
4006   1BCD             
4007   1BCD 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   1BCE 2B                  DEC     HL
4009   1BCF 77                  LD      (HL),A
4010   1BD0 2B                  DEC     HL
4011   1BD1 77                  LD      (HL),A
4012   1BD2 C3 A8 1B            JP      RND1            ; Return RND seed
4013   1BD5             
4014   1BD5 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   1BD9 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   1BDD 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   1BE1             
4018   1BE1 21 2B 1C    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   1BE4 CD 9F 15            CALL    ADDPHL          ; Add it to PPREG
4020   1BE7 CD 25 18    SIN:    CALL    STAKFP          ; Put angle on stack
4021   1BEA 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   1BED 11 DB 0F            LD      DE,0FDBH
4023   1BF0 CD 35 18            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   1BF3 C1                  POP     BC              ; Restore angle
4025   1BF4 D1                  POP     DE
4026   1BF5 CD 4A 17            CALL    DVBCDE          ; Divide angle by 2 PI
4027   1BF8 CD 25 18            CALL    STAKFP          ; Put it on stack
4028   1BFB CD C7 18            CALL    INT             ; Get INT of result
4029   1BFE C1                  POP     BC              ; Restore number
4030   1BFF D1                  POP     DE
4031   1C00 CD AB 15            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   1C03 21 2F 1C            LD      HL,QUARTR       ; Point to 0.25
4033   1C06 CD A5 15            CALL    SUBPHL          ; Subtract value from 0.25
4034   1C09 CD F4 17            CALL    TSTSGN          ; Test sign of value
4035   1C0C 37                  SCF                     ; Flag positive
4036   1C0D F2 17 1C            JP      P,SIN1          ; Positive - Ok
4037   1C10 CD 9C 15            CALL    ROUND           ; Add 0.5 to value
4038   1C13 CD F4 17            CALL    TSTSGN          ; Test sign of value
4039   1C16 B7                  OR      A               ; Flag negative
4040   1C17 F5          SIN1:   PUSH    AF              ; Save sign
4041   1C18 F4 1D 18            CALL    P,INVSGN        ; Negate value if positive
4042   1C1B 21 2F 1C            LD      HL,QUARTR       ; Point to 0.25
4043   1C1E CD 9F 15            CALL    ADDPHL          ; Add 0.25 to value
4044   1C21 F1                  POP     AF              ; Restore sign
4045   1C22 D4 1D 18            CALL    NC,INVSGN       ; Negative - Make positive
4046   1C25 21 33 1C            LD      HL,SINTAB       ; Coefficient table
4047   1C28 C3 3C 1B            JP      SUMSER          ; Evaluate sum of series
4048   1C2B             
4049   1C2B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   1C2F             
4051   1C2F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   1C33             
4053   1C33 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   1C34 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   1C38 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   1C3C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   1C40 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   1C44 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   1C48             
4060   1C48 CD 25 18    TAN:    CALL    STAKFP          ; Put angle on stack
4061   1C4B CD E7 1B            CALL    SIN             ; Get SIN of angle
4062   1C4E C1                  POP     BC              ; Restore angle
4063   1C4F E1                  POP     HL
4064   1C50 CD 25 18            CALL    STAKFP          ; Save SIN of angle
4065   1C53 EB                  EX      DE,HL           ; BCDE = Angle
4066   1C54 CD 35 18            CALL    FPBCDE          ; Angle to FPREG
4067   1C57 CD E1 1B            CALL    COS             ; Get COS of angle
4068   1C5A C3 48 17            JP      DIV             ; TAN = SIN / COS
4069   1C5D             
4070   1C5D CD F4 17    ATN:    CALL    TSTSGN          ; Test sign of value
4071   1C60 FC 88 1A            CALL    M,NEGAFT        ; Negate result after if -ve
4072   1C63 FC 1D 18            CALL    M,INVSGN        ; Negate value if -ve
4073   1C66 3A 2C 81            LD      A,(FPEXP)       ; Get exponent
4074   1C69 FE 81               CP      81H             ; Number less than 1?
4075   1C6B DA 7A 1C            JP      C,ATN1          ; Yes - Get arc tangnt
4076   1C6E 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   1C71 51                  LD      D,C
4078   1C72 59                  LD      E,C
4079   1C73 CD 4A 17            CALL    DVBCDE          ; Get reciprocal of number
4080   1C76 21 A5 15            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   1C79 E5                  PUSH    HL              ; Save for angle > 1
4082   1C7A 21 84 1C    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   1C7D CD 3C 1B            CALL    SUMSER          ; Evaluate sum of series
4084   1C80 21 2B 1C            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   1C83 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   1C84             
4087   1C84 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   1C85 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   1C89 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   1C8D FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   1C91 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   1C95 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   1C99 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   1C9D E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   1CA1 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   1CA5 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   1CA9             
4098   1CA9             
4099   1CA9 C9          ARET:   RET                     ; A RETurn instruction
4100   1CAA             
4101   1CAA D7          GETINP: RST	    10H             ;input a character
4102   1CAB C9                  RET
4103   1CAC             
4104   1CAC             CLS:
4105   1CAC 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   1CAE C3 E6 1D            JP      MONOUT          ; Output character
4107   1CB1             
4108   1CB1 CD 73 15    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   1CB4 7B                  LD      A,E             ; Width to A
4110   1CB5 32 87 80            LD      (LWIDTH),A      ; Set width
4111   1CB8 C9                  RET
4112   1CB9             
4113   1CB9 CD 12 0E    LINES:  CALL    GETNUM          ; Get a number
4114   1CBC CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
4115   1CBF ED 53 8B 80         LD      (LINESC),DE     ; Set lines counter
4116   1CC3 ED 53 8D 80         LD      (LINESN),DE     ; Set lines number
4117   1CC7 C9                  RET
4118   1CC8             
4119   1CC8 CD 57 0A    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   1CCB D5                  PUSH    DE              ; Save number
4121   1CCC E1                  POP     HL              ; Number to HL
4122   1CCD 46                  LD      B,(HL)          ; Get LSB of contents
4123   1CCE 23                  INC     HL
4124   1CCF 7E                  LD      A,(HL)          ; Get MSB of contents
4125   1CD0 C3 CD 11            JP      ABPASS          ; Return integer AB
4126   1CD3             
4127   1CD3 CD 12 0E    DOKE:   CALL    GETNUM          ; Get a number
4128   1CD6 CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
4129   1CD9 D5                  PUSH    DE              ; Save address
4130   1CDA CD 1B 08            CALL    CHKSYN          ; Make sure ',' follows
4131   1CDD 2C                  .BYTE      ','
4132   1CDE CD 12 0E            CALL    GETNUM          ; Get a number
4133   1CE1 CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
4134   1CE4 E3                  EX      (SP),HL         ; Save value,get address
4135   1CE5 73                  LD      (HL),E          ; Save LSB of value
4136   1CE6 23                  INC     HL
4137   1CE7 72                  LD      (HL),D          ; Save MSB of value
4138   1CE8 E1                  POP     HL              ; Restore code string address
4139   1CE9 C9                  RET
4140   1CEA             
4141   1CEA             
4142   1CEA             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   1CEA             
4144   1CEA CD 15 0E    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   1CED CD 57 0A            CALL	DEINT           ; Get integer -32768 to 32767
4146   1CF0 C5                  PUSH	BC              ; Save contents of BC
4147   1CF1 21 2E 81            LD	    HL,PBUFF
4148   1CF4 7A                  LD	    A,D             ; Get high order into A
4149   1CF5 FE 00               CP      $0
4150   1CF7 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   1CF9 CD 22 1D            CALL    BYT2ASC         ; Convert D to ASCII
4152   1CFC 78          		LD      A,B
4153   1CFD FE 30       		CP      '0'
4154   1CFF 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   1D01 70                  LD	    (HL),B          ; Store it to PBUFF
4156   1D02 23                  INC	    HL              ; Next location
4157   1D03 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   1D04 23                  INC     HL              ; Next location
4159   1D05 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   1D06 CD 22 1D            CALL    BYT2ASC         ; Convert E to ASCII
4161   1D09 7A          		LD      A,D
4162   1D0A FE 00               CP      $0
4163   1D0C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   1D0E 78          		LD      A,B
4165   1D0F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   1D11 28 02       		JR      Z,HEX4
4167   1D13 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   1D14 23                  INC     HL              ; Next location
4169   1D15 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   1D16 23                  INC     HL              ; PBUFF+4 to zero
4171   1D17 AF                  XOR     A               ; Terminating character
4172   1D18 77                  LD      (HL),A          ; Store zero to terminate
4173   1D19 23                  INC     HL              ; Make sure PBUFF is terminated
4174   1D1A 77                  LD      (HL),A          ; Store the double zero there
4175   1D1B C1                  POP     BC              ; Get BC back
4176   1D1C 21 2E 81            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   1D1F C3 7B 12            JP      STR1            ; Convert the PBUFF to a string and return it
4178   1D22             
4179   1D22 47          BYT2ASC	LD      B,A             ; Save original value
4180   1D23 E6 0F               AND     $0F             ; Strip off upper nybble
4181   1D25 FE 0A               CP      $0A             ; 0-9?
4182   1D27 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   1D29 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   1D2B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   1D2D 4F                  LD      C,A             ; Save converted char to C
4186   1D2E 78                  LD      A,B             ; Retrieve original value
4187   1D2F 0F                  RRCA                    ; and Rotate it right
4188   1D30 0F                  RRCA
4189   1D31 0F                  RRCA
4190   1D32 0F                  RRCA
4191   1D33 E6 0F               AND     $0F             ; Mask off upper nybble
4192   1D35 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   1D37 38 02               JR      C,ADD301        ; Skip Add 7
4194   1D39 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   1D3B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   1D3D 47                  LD      B,A             ; Store high order byte
4197   1D3E C9                  RET
4198   1D3F             
4199   1D3F             ; Convert "&Hnnnn" to FPREG
4200   1D3F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   1D3F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   1D3F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   1D40 21 00 00            LD      HL,$0000        ; Zero out the value
4204   1D43 CD 58 1D            CALL    GETHEX          ; Check the number for valid hex
4205   1D46 DA 78 1D            JP      C,HXERR         ; First value wasn't hex, HX error
4206   1D49 18 05               JR      HEXLP1          ; Convert first character
4207   1D4B CD 58 1D    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   1D4E 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   1D50 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   1D51 29                  ADD     HL,HL
4211   1D52 29                  ADD     HL,HL
4212   1D53 29                  ADD     HL,HL
4213   1D54 B5                  OR      L               ; Add in D0-D3 into L
4214   1D55 6F                  LD      L,A             ; Save new value
4215   1D56 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   1D58             
4217   1D58 13          GETHEX  INC     DE              ; Next location
4218   1D59 1A                  LD      A,(DE)          ; Load character at pointer
4219   1D5A FE 20               CP      ' '
4220   1D5C CA 58 1D            JP      Z,GETHEX        ; Skip spaces
4221   1D5F D6 30               SUB     $30             ; Get absolute value
4222   1D61 D8                  RET     C               ; < "0", error
4223   1D62 FE 0A               CP      $0A
4224   1D64 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   1D66 D6 07               SUB     $07             ; Reduce to A-F
4226   1D68 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   1D6A D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   1D6B FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   1D6D 3F                  CCF
4230   1D6E C9                  RET                     ; CY set if it wasn't valid hex
4231   1D6F             
4232   1D6F EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   1D70 7A                  LD      A,D             ; Load DE into AC
4234   1D71 4B                  LD      C,E             ; For prep to
4235   1D72 E5                  PUSH    HL
4236   1D73 CD CC 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   1D76 E1                  POP     HL
4238   1D77 C9                  RET
4239   1D78             
4240   1D78 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   1D7A C3 61 05            JP      ERROR
4242   1D7D             
4243   1D7D             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   1D7D CD 15 0E    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   1D80 CD 57 0A            CALL    DEINT           ; Get integer -32768 to 32767
4246   1D83 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   1D84 21 2E 81            LD      HL,PBUFF
4248   1D87 06 11               LD      B,17            ; One higher than max char count
4249   1D89             ZEROSUP:                        ; Suppress leading zeros
4250   1D89 05                  DEC     B               ; Max 16 chars
4251   1D8A 78                  LD      A,B
4252   1D8B FE 01               CP      $01
4253   1D8D 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   1D8F CB 13               RL      E
4255   1D91 CB 12               RL      D
4256   1D93 30 F4               JR      NC,ZEROSUP
4257   1D95 18 04               JR      BITOUT2
4258   1D97             BITOUT:
4259   1D97 CB 13               RL      E
4260   1D99 CB 12               RL      D               ; Top bit now in carry
4261   1D9B             BITOUT2:
4262   1D9B 3E 30               LD      A,'0'           ; Char for '0'
4263   1D9D CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   1D9F 77                  LD      (HL),A
4265   1DA0 23                  INC     HL
4266   1DA1 05                  DEC     B
4267   1DA2 20 F3               JR      NZ,BITOUT
4268   1DA4 AF                  XOR     A               ; Terminating character
4269   1DA5 77                  LD      (HL),A          ; Store zero to terminate
4270   1DA6 23                  INC     HL              ; Make sure PBUFF is terminated
4271   1DA7 77                  LD      (HL),A          ; Store the double zero there
4272   1DA8 C1                  POP     BC
4273   1DA9 21 2E 81            LD      HL,PBUFF
4274   1DAC C3 7B 12            JP      STR1
4275   1DAF             
4276   1DAF             ; Convert "&Bnnnn" to FPREG
4277   1DAF             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   1DAF EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   1DB0 21 00 00            LD      HL,$0000        ; Zero out the value
4280   1DB3 CD CC 1D            CALL    CHKBIN          ; Check the number for valid bin
4281   1DB6 DA DA 1D            JP      C,BINERR        ; First value wasn't bin, HX error
4282   1DB9 D6 30       BINIT:  SUB     '0'
4283   1DBB 29                  ADD     HL,HL           ; Rotate HL left
4284   1DBC B5                  OR      L
4285   1DBD 6F                  LD      L,A
4286   1DBE CD CC 1D            CALL    CHKBIN          ; Get second and addtional characters
4287   1DC1 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   1DC3 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   1DC4 7A                  LD      A,D             ; Load DE into AC
4290   1DC5 4B                  LD      C,E             ; For prep to
4291   1DC6 E5                  PUSH    HL
4292   1DC7 CD CC 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   1DCA E1                  POP     HL
4294   1DCB C9                  RET
4295   1DCC             
4296   1DCC             ; Char is in A, NC if char is 0 or 1
4297   1DCC 13          CHKBIN: INC     DE
4298   1DCD 1A                  LD      A,(DE)
4299   1DCE FE 20               CP      ' '
4300   1DD0 CA CC 1D            JP      Z,CHKBIN        ; Skip spaces
4301   1DD3 FE 30               CP      '0'             ; Set C if < '0'
4302   1DD5 D8                  RET     C
4303   1DD6 FE 32               CP      '2'
4304   1DD8 3F                  CCF                     ; Set C if > '1'
4305   1DD9 C9                  RET
4306   1DDA             
4307   1DDA 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   1DDC C3 61 05            JP      ERROR
4309   1DDF             
4310   1DDF             
4311   1DDF             JJUMP1:
4312   1DDF DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   1DE3 C3 B1 01            JP      CSTART          ; Go and initialise
4314   1DE6             
4315   1DE6             MONOUT:
4316   1DE6 C3 08 00            JP      $0008           ; output a char
4317   1DE9             
4318   1DE9             
4319   1DE9             MONITR:
4320   1DE9 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   1DEC             
4322   1DEC             
4323   1DEC 3E 00       INITST: LD      A,0             ; Clear break flag
4324   1DEE 32 92 80            LD      (BRKFLG),A
4325   1DF1 C3 B8 01            JP      INIT
4326   1DF4             
4327   1DF4 ED 45       ARETN:  RETN                    ; Return from NMI
4328   1DF6             
4329   1DF6             
4330   1DF6 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   1DF7 A0                  AND     B               ; Get common bits
4332   1DF8 C1                  POP     BC              ; Restore bit mask
4333   1DF9 B8                  CP      B               ; Same bit set?
4334   1DFA 3E 00               LD      A,0             ; Return 0 in A
4335   1DFC C9                  RET
4336   1DFD             
4337   1DFD CD 26 08    OUTNCR: CALL    OUTC            ; Output character in A
4338   1E00 C3 4D 0C            JP      PRNTCRLF        ; Output CRLF
4339   1E03             
4340   1E03             .end
tasm: Number of errors = 0
